## 1、main 执行之前和之后执行的代码可能是什么

### 前置知识

代码段(.text) 可执行指令的集合，数据段(.data) 和 BSS段(.bss) 是数据的集合，其中 .data 表示已经初始化(非0)的数据，.bss 表示未初始化(未初始化和初始化为0)的数据   三个部分组成了可执行程序。 

从可执行的程序的角度：如果一个数据未被初始化就不需要为其分配空间，.bss 不占用可执行文件的大小，仅仅记录需要多少空间来存储这些未初始化的数据。

**运行态**时：.data + .text + .bss + 堆 + 栈

**静态分配**的内存在进程结束后由**系统释放**(text + data)，**动态分配**的内存需要**手动释放**(delete + free)

<img src="./C++.assets/c++%E5%90%84%E7%AB%AF.png" alt="c++各端.png" style="zoom: 33%;" />

## 2、指针类型

```cpp
int *p[10] // 指针数组，强调数组，数组内每个元素都是指向 int 类型的指针变量
int (*p)[10] // 数组指针，一个指针类型的变量，指向的是 int 数组
int *p(int) // 函数声明，参数是 int 返回值是 int *
int (*p)(int)  // 函数指针，指向的函数具有 int 类型参数，返回值时 int
```

## 3、new - malloc

### new

1. new简单类型直接调用operator new分配内存；对于复杂的，先调用operator new分配内存，然后在分配的内存上调用构造函数；new[]简单类型计算大小后直接调用库函数，复杂类型先调用operator new[]分配内存，然后在 p 的前四个字节写入数组大小 n，然后调用 n 次构造函数，new[] 会额外存储数组大小  ； **返回的是指向该对象的指针**
2. delete 简单数据类型只是调用 free 函数，复杂是先调用析构函数在调用operator delete；针对简单类型 delete 和delete[]等同。实际分配内存地址为[p-4]，p是指向第一位数据而不是实际起始位置，delete[] 释放的是 p-4 所指向的，但是delete 会直接释放 p 指向的，为被记录(系统记录的是实际 p-4).
3. new[] ，[]中一定是整数，但不一定是常量整数，普通数组必须是一个常量整数
4. delete[] 按照逆序的顺序销毁
5. new 和 delete 是将内存分配和对象构造 / 对象析构和内存释放组合的。allocator不是，它申请一部分内存，不进行初始化对象，只有当需要的时候才进行初始化对象
6. 自动进行类型检查和大小

#### plaine new

普通的 new，抛出异常 std::bad_alloc 而不是返回 NULL

#### nothrow new

空间分配失败时不抛出异常而是返回 NULL

#### placement new

**允许在一块已经分配成功的内存上重新构造对象或对象数组**，不用担心内存分配失败，因为根本不分配内存，唯一一件事就是调用对象的构造函数

1. 主要用途：反复使用一块较大的动态分配的内存来构造不同类型的对象或者他们的数组
2. placement new构造起来的对象数组，要显式的调用他们的析构函数来销毁(析构函数并不释放对象的内存)，**不能delete** (构造起来的对象或者数组并不一定等于分配的大小，delete释放内存会出现内存泄露或者运行时错误)

### malloc

1. 底层由 brk、mmap、munmap系统调用实现
2. brk 时将 堆顶 指针向高地址移动，获得新的地址空间，mmap 是在进程的虚拟地址空间中(堆和栈中间，称为文件映射区域的地方)找一块空闲的虚拟内存；**都是分配虚拟内存，没有分配物理内存**，在第一次访问虚拟地址空间，发生缺页中断，os 负责分配物理地址，然后创建虚拟内存和物理内存之间的映射关系
3. malloc 小于 128k 的内存，使用 brk 分配内存，将 堆顶 指针往高地址推；大于 128k 使用mmap，在堆和栈之间找一块空闲内存分配，brk 分配的内存需要等到高地址内存释放以后才能释放，而 mmap 分配的内存可以单独释放。内存紧缩(>128k时)
4. malloc 是从堆里申请内存，也就是返回的指针式指向堆里的一块内存。
5. malloc/free 的操作对象都是必须明确大小的，而且不能用在动态类上，malloc/free 不能指向构造和析构函数，不能动态对象，理论上可以delete代替，但是一边不建议，不保证每个都能正常运行

### 对比

malloc 是手工计算大小的，new 是类型安全的，无需指定内存块的大小、new/delete是关键字，malloc/free是库函数

delete 对指针所指对象运行适当的析构函数，通过 delete 释放内存 系统支持，free 只是释放内存不会析构对象

调用库函数 - 构造/析构函数 - 分配/释放 

malloc free 是库函数  new delete 是运算符可重载，前者返回 **void 类型指针**，后者返回**具体类型指针** (会调用operator new 是库函数)；delete先调用析构函数，然后调用operator delete函数释放内存(底层使用free)。malloc是库函数，只能动态申请或释放，无法强制要求其做自定义类型对象构造和析构工作。

free 回收的内存不会立刻返回给 os。被 ptmalloc 使用双链表保存，方便下次使用，自动尝试合并

## 4、#define 和 typedef

#define 编译阶段前直接替换文本，不存在函数调用，无返回值，**不进行类型检查**，不是完整的语句，编译器并不知道实际意义，只是替换内容而已

typedef 主要用于定义别名，编译的一部分，检查数据类型，完整的语句，编译器事先知道别名的真实意义

## 5、static & 全局变量

### 作用

1. 隐藏 (most impor) ，函数、变量均可；只能本文件可用
2. 保持变量内容的**持久**，**记忆功能和全局生存期**；存储在**静态数据区**，刚**开始运行**就会**唯一一次初始化**，**全局变量和static变量**都存储在**静态存储区(全局区域)**，静态存储方式
3. 默认初始化为 0 ，**初始化只有一次**，在主程序之前，编译器已经为其分配内存
4. 可以使用静态成员函数作为默认实参

> C中，编译阶段分配好内存之后就会进行初始化，所有无法使用变量对静态局部变量进行初始化
>
> C++中，由于进行初始化必须指向相应的构造函数和析构函数，需要进行特定的操作，而不是仅仅分配内存，所以全局变量和静态对象是在首次用到才会进行构造。按照构造顺序反方向的析构，故可以使用变量进行初始化

1. C++中的类成员声明static

> 1. 函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值。
> 2. 在模块内的static全局变量可以被模块内所有函数访问，但不能被模块外其他函数访问；
> 3. 在模块内的static函数只可被这一模块内的其他函数调用，这个函数的使用范围被限制在声明它的模块内
> 4. 在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝
> 5. 在类中的static成员函数属于整个类所拥有，这个函数不接收this指针， 因而只能访问类的static成员变量
> 6. static类对象必须在类外初始化，static修饰的变量先于对象存在，所以static修饰的变量要在类外初始化
> 7. 由于static修饰的类成员属于类，不属于对象，所有static成员函数没有this指针，this 指针是指向本对象的指针，故不能访问非static类成员
> 8. static成员函数不能被virtual修饰，static成员不属于任何对象或实例；静态成员函数没有this指针，虚函数的实现是为每一个对象分配一个vptr指针，而vptr是通过this指针调用的，虚函数的调用关系 this -> vptr -> ctable -> virtual function

### 不考虑类

不加 static 的全局变量和全局函数是可以通过 **extern** 来实现跨文件访问的**(类除外)**，默认初始化为0，未初始化的**全局静态变量和局部静态变量**都存在于**全局未初始化区**

注意：静态变量在函数内定义时作用范围和局部变量一致，但是函数退出后**仍然存在**只是**不能使用**

### 考虑类

static 成员变量：只与类关联，不与类的对象关联。定义时需要分配空间，不能在类声明中初始化，必须在类定义体外部初始化 (改成员属于类本身，而不是属于类的某个对象，所以存储空间不能依赖于某个对象)，初始化不必标识为 static，可以被非 static 成员函数任意访问 

static 成员函数：不具有 this 指针，**无法访问**类对象的**非 static 成员对象**和**非 static 成员函数**，**不能被声明为 const、虚函数和volatile**；可以**被非 static 成员函数任意访问**。

static 可以通过类名直接访问，也可以通过类的对象访问，都是同一个变量，static 成员变量在全局数据区分配。C++17开始可以在类内初始化但不建议。

## 6、const

### 不考虑类

const 常量在定义时必须初始化，之后无法更改

const 形参可以接收 const 和非const类型的实参

### 考虑类

const 成员变量 ：不能在类定义外部初始化，只能通过构造函数初列表初始化，必须要有析构函数，不同类的const数据成员可以不同，故不能再类中声明时初始化  

const 成员函数：const对象不可以调用非 const成员函数，**非const对象都可以调用**，不可以改变非mutable (用该关键字声明的变量可以在const成员函数中修改) 数据的值。非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象

类的常(const)对象只能访问类的常(const)成员函数，类的const成员变量必须在初始化列表中初始化

只有引用传递或者指针传递可以用是否加 const 重载，值传递不能作为重载的依据

const + const_cast  --> 非const

### 顶层/底层const

顶层 const ：const 修饰的变量**本身**是一个常量，无法修改，指的是指针，就是 * 号的右边

底层 const ：const 修饰的变量**所指向的对象**是一个常量，指的是所指变量，就是 * 号的左边

```cpp
int a = 10;int *const b1 = &a;//顶层 const，b1 本身是一个常量
const int *b2 =&a;//底层const ，b2可变，所指的对象是常量
const int b3 = 20;//顶层 const， b3 是常量不可变
const int* const b4 = &a;//前者是底层const，后者是顶层const b4 不可变
const int& b5 = a;//用于声明引用，都是底层const
```

## 7、拷贝/直接初始化

对于类对象两者有所不同：**直接初始化**直接调用与**实参匹配的构造函数**，**拷贝初始化**总是调用**拷贝构造函数**，拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象。

```cpp
string str1("i am a string") ;//直接初始化
string str2(str1); // 直接初始化，直接调用拷贝构造函数
string str3 = "i am a string"; //拷贝初始化，创建临时对象
string str4 = str1;//拷贝初始化，隐式调用拷贝构造函数，而不是调用赋值运算符函数
```

> 允许编译器临时跳过创建临时对象这一步，直接调用拷贝构造函数要创建的对象，完全等价直接初始化(1 = 3)
>
> 当拷贝构造函数为 private ，3 4 会报错
>
> 使用 explicit 修饰构造函数时，如果构造函数存在隐式转换，报错

## 8、初始化和赋值

在类中，初始化都是调用拷贝构造函数，但是如果类中有对 `=` 重载，此时赋值时会调用重载函数，此时初始化不等于赋值！ ！ ！ 

## 9、野指针/空指针

野指针：指向了无效内存区域，指针便变量未及时初始化

空指针：指针 free 或 delete 后没有及时置空，指向的内存已经被释放

## 10、重写(覆盖) & 重载

### 重写

在派生类中覆盖基类中的同名函数，**重写就是重写函数体**，要求**基类函数必须是虚函数**且

- 与基类的虚函数有相同的参数个数
- 与基类的虚函数有相同的参数类型
- 与基类的虚函数有相同的返回值类型

```cpp
class A {
  public : virtual int fun(int x) {}
}
class B : public A {
  pulic : virtual int fun(int x) override{} //重写，加override可以确保是重写父类的函数，virtual可省
}
```

> 重写是父类和子类之间的垂直关系，重写是不同函数之间的水平关系 ； 重写要求参数列表、返回值相同，重载要求参数列表不同，返回值不要求；重写关系中，调用方法根据对象类型决定，重载根据调用时实参表与形参表的对应关系来选择函数体

### 重载

1. 只能重载已有的运算符
2. 不能改变运算符的优先级和结合率，不能改变操作数的个数
3. 主要是为了**实现类的多态性**，允许对象使用标准的语句进行操作，提高代码的可读性和可维护性

#### 重载方式

1. 成员运算符重载：将运算符重载函数定义为类的成员函数。成员运算符函数比非成员运算符少一个参数，因为隐含的一个参数是对象本身(通过 this 指针传递)
2. 非成员运算符重载：将运算符重载函数定义为类的友元函数或普通函数。非成员运算符函数需要包含所有操作数作为参数。

#### 特殊要求

下标函数 [] 和箭头运算符必须作为成员函数重载

#### 特点 & 要求

1. 当运算符重载为**成员函数**时，this 指针绑定到左侧的运算符对象，成员运算符函数的参数数量比运算符对象的数量少一个，并且至少包含一个类类型的参数。
2. 运算符类型判断：可以通过参数个数来判断重载的是一元运算符还是二元运算符，例如 + 取正 / 加法
3. **下标运算符**必须是成员函数，并且通常返回对所访问元素的引用，为了支持常量对象的访问，最好同时定义下标运算符的常量版本和非常量版本。
4. 箭头运算符必须是类的成员，并且重载后的箭头运算符必须返回类的指针，以便支持连续的对象成员访问。
5. 函数的匹配原则和顺序：名字查找 -> 确定候选函数 -> 寻找最佳匹配

## 11、隐藏

派生类的函数屏蔽了基类中的同名函数

1. 两个函数参数相同，但是基类不是虚函数，b.fun() 此时是子类的虚函数  b.A :: fun() 此时调用的是父类的虚函数
2. 两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。不在一个类中！

> 基类指针指向派生类对象时，基类指针可以直接调用到派生类的覆盖函数，也可以通过 :: 调用到基类被覆盖的虚函数；而基类指针只能调用基类的被隐藏的函数，**无法识别派生类中的隐藏函数**

## 12、构造函数 ！ ！ 

```cpp
Student() {...}; //默认构造函数，没有参数
Student(int a,int n):age(a),num(n){}; //初始化构造函数，有参数和参数列表，成员列表
Student(const Student& s) {this->age=s.age...};//拷贝构造函数，与编译器生成的一致
Student(int r) {this->age = r;this->num = 1002;}; //转换构造函数，形参是其他类型变量，且只有一个形参
Student(const char*name,double score) {this->age=0;this->num=(int)score;};//接受任意类型指定参数的构造函数
Student(double r) {this->age=(int)r*10;this->num=1003;};//转换构造函数，形参是其他类型变量，且只有一个形参
Student s("Demo",56.45) ; //->0 56
Student s6 = 85.64; // --> 850,1003 , 右值是double类型的变量效果一致
Person(Person&& other):name(std::move(other.name),age(other.age)) {} //转移构造函数
```

> 默认构造函数和初始化构造函数在定义类的对象，完成对象的初始化工作
>
> 复制构造函数用于复制本类的对象
>
> 转换构造函数用于将其他类型的变量，隐式转换为本类对象

### 调用拷贝构造函数的时机 ！ ！

1. 用类的一个实例化对象去初始化另一个对象的时候
2. 函数的参数是类的对象时 (非引用传递)
3. 函数的返回值是函数体内局部对象的类的对象时，此时虽然发生(Named return Value优化) NRV优化，但是由于返回方式是**值传递**，所以会在返回值的地方调用拷贝构造函数。(linnux g++不会发生拷贝构造函数) ！ ！

### 初始化方式

赋值初始化：通过在函数体内进行赋值初始化，**在所有的数据成员被分配内存空间后才进行的**，在**构造函数当中做赋值**操作，会产生临时对象，降低程序的效率。

**列表初始化**：在冒号后使用初始化列表进行初始化，**给数据成员分配内存空间时就进行初始化**，初始化这个成员时函数体还未执行，**纯粹的初始化操作**

### 构造函数的执行顺序

1. 虚拟基类的构造函数(多个虚拟基类则按照继承的顺序执行构造函数)
2. 基类的构造函数 (多个普通基类也按照继承的顺序进行构造函数)
3. 类类型的成员对象的构造函数 (按照成员对象在类中的定义顺序)
4. 派生类自己的构造函数

### 必须成员列表初始化 ！ ！ 

1. 当初始化一个引用对象时 (引用必须在声明时初始化，且不能重新赋值)
2. 初始化一个const常量成员时
3. 调用一个基类的构造函数，而它拥有一组参数时
4. 调用一个成员类的构造函数，而它拥有一组参数时
5. 编译器会一一操作初始化列表，以适当的顺序在构造函数之内安插初始化操作，并且在任何显示用户代码前。list中的项目顺序是由类中的成员声明顺序决定的，不是初始化列表中的排序顺序决定的。

#### 成员初始化列表作用  ！ ！ 

1. 编译器会一一操作初始化列表，以适当的顺序在构造函数之内安插初始化操作，并且在任何显示用户代码之前
2. list 中的项目顺序是由类中的成员声明顺序决定的，不是由初始化列表的顺序决定的。

### 移动构造函数

1. 用对象 a 初始化对象 b，如果 a 不在使用，但是 a 的空间还在，此时可以直接使用 a 的空间而不是拷贝构造，避免新空间的分配
2. 移动构造函数中，对于指针采用浅拷贝。
3. 将 a 指针指向 null 即可
4. 拷贝构造函数的参数是左值引用，移动构造函数的初值是右值引用，移动构造函数的参数一定是**右值或将亡值的引用**，move 即是**将左值变为将亡值**

### 如何禁止自动生成拷贝构造函数

1. 重写拷贝构造和拷贝赋值函数，为了避免调用，可以设置为 private
2. 类的成员函数和 friend函数还是可以调用 private，如果只声明不定义，会产生一个连接错误
3. ---> 定义一个base类，在base类中将拷贝构造函数和拷贝赋值函数设置为private，那么派生类不会自动实现这两个函数，且派生类无法访问基类的private，此时派生类也不会自动生成拷贝函数

```cpp
class Base {
private:
    Base(const Base&) {}
    Base& operator=(const Base&) {
        return *this;
    }
};
class Derived : public Base {
public:
    Derived() {}
};
int main() {
    Derived d1;
    // Derived d2 = d1; // 错误：无法访问基类的拷贝构造函数
    // Derived d3;
    // d3 = d1; // 错误：无法访问基类的拷贝赋值函数
    return 0;
} //当基类的拷贝构造函数和拷贝赋值函数不可用时，编译器不会为派生类自动生成默认的拷贝构造函数和拷贝赋值函数。
//这是因为派生类的拷贝操作通常需要调用基类的拷贝操作，而基类的拷贝操作已经被禁用。可以在子类手动重载
```

## 13、深浅拷贝

浅拷贝：只是拷贝一个指针，并没有开辟一个新地址，两个指针指向同一块地址，只能释放一次

深拷贝：会开辟一块新的空间来存放新的值，两者是独立的。在自己实现拷贝赋值时，如果有指针变量需要实现深拷贝

## 14、内联函数

1. 宏只做字符串替换 (编译前)。而内联函数可以进行参数类型检查 (编译前)，且具有返回值
2. 内联函数在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销，并且进行参数类型检查，具有返回值，可以重载。
3. 具有类型检测，语法判断等功能

> 使用**宏定义的地方**都可以使用 inline 函数 ； 作为**类成员接口函数来读写类的私有成员或者保护成员**，会提高效率
>
> **类成员函数接口**：定义的公共成员函数(getter、setter)；**读写这些成员**的时候通过**类成员函数接口**进行，而不是用过友元、继承类直接访问或其他间接方式

## 15、访问与继承

类定义时不会占内存，只有声明后才会占内存，基类必须定义而非声明，因为派生类必须知道他们是什么

### 继承定义

1. 类与类之间的关系

- has-A 包含关系，用以描述一个类由多个部件类构成，实现 has-A 关系用类的成员属性表示，即一个类的成员属性是另一个已经定义好的类
- use-A，一个类使用另一个类，通过类之间的成员函数相互联系，定义友元或者通过传递参数的方式来实现
- is-A，继承关系，关系具有传递性

2. 所谓继承就是一个类继承了另一个类的属性和方法， 这个新的类包含了上一个类的属性和方法，被称为子类或怕派生类，基类或父类
3. 特点：子类具有父类的所有属性和方法，子类可以拥有父类没有的属性和方法，子类对象可以当作父类对象使用
4. 访问控制：public(类对外提供的可访问接口)，protected(派生类中相当于public可以访问)，private
5. 继承中的构造和析构函数
6. 继承中的兼容性原则

**派生类访问基类成员**

1. 内部访问：由派生类中新增的成员函数对从基类继承来的成员的访问
2. 外部访问：在派生类外部，通过派生类的对象从基类继承来的成员的访问

**保护继承时** 基类的公有和私有都变为保护成员，只能被它的派生类成员函数或者友元函数访问。

**私有继承时** 全成私有成员，不能被派生类的子类所访问，无法继续由派生类向下继承

### 对象之间转换

1. 向上类型转换

- 将派生类指针或引用转换为基类的指针或引用被称为向上类型转换，向上类型转换会自动进行，且是安全的

2. 向下类型转化

- 将基类指针或引用转换为派生类指针或引用称为向下类型转换，不会自动进行，因为一个基类可以对于几个派生类，向下类型转换必须加动态类型识别技术。RRTI技术，用dynamic_cast进行向下类型转换。

### 访问权限

| 访问权限  |  外部  | 派生类 | 内部 |
| :-------: | :----: | :----: | :--: |
|  public   |  可以  |  可以  | 可以 |
| protected | 不可以 |  可以  | 可以 |
|  private  | 不可以 | 不可以 | 可以 |

### 继承权限

1. 派生类继承自基类的成员权限：public、protected、private、不可见
2. 派生类对基类成员的访问权限取决于两点：继承方式 + 基类成员在基类中的访问权限
3. 基类成员在派生类中的访问权限不得高于继承方式中指定的权限，高于会下降为继承权限。**基类private成员在任何继承方式下都是不可见的**

## 16、大小端

大端：字数据的高字节存储在低地址中

小端：子数据的低字节存储在低地址中

强制类型转换或者使用`union`可以判断

`union` 占用的内存大小是其**所有成员中占用空间最大的那个成员的大小**。所有成员共享一块内存空间。

## 17、volatile、mutable、explicit

### volatile

类型修饰符，**声明的类型变量表示可以被某些编译器未知的因素更改**，编译器不对访问该变量的代码优化，**总是重新从它所在的内存读取数据**。

定义变量的值是易变的，每次用到这个变量的值都要去重新读取这个变量的值，而不是读寄存器中的备份，多线程中被几个任务共享的变量需要定义为 volatile 类型

```cpp
const char*cpch;volatile char* vpch;
char* const pchc;char* volatile pchv;
```

1. 可以将一个非volatile int赋给volatile int，但是不能把非volatile对象赋给volatile对象
2. 除了基本类型外，对用户定义类型也能用volatile
3. c++中一个有volatile标识符的类只能访问他接口的子集，一个由类的实现者控制的子集。用户只能用const_cast来获得对类型接口的完全访问。此外volatile像const一样会从类传递到他的成员。

#### 使用场景

1. 中断服务程序中修改的供其他程序检测的变量需要加 volatile
2. 多任务环境下各任务间共享的标志应该加 volatile
3. 存储器映射的硬件寄存器通常也要加 volatile 说明，因为每次对他的读写都可能有不同意义

### mutable

可变的，在const函数里修改一些跟状态无关的数据成员，那么这个函数就应该被mutable来修饰，并且放在函数后面关键字位置

```cpp
class person {
  int a;
  mutable int b;
  public:
  void add() const { // 加上const 后表示在函数里不可以修改 this 指针指向的值 常量指针
    a = 10; //error const 不可修改
    b = 20; // 可以修改
  }
}
```

### explicit

用来修饰类的构造函数，此时不能发生相应的隐式类型转换，**只能以显式的方式进行类型转化**

> explicit 只能用于类内部的构造函数声明上
>
> 被 explicit 修饰的构造函数的类，不能发生相应的隐式类型转换

## 18、malloc + calloc + realloc

```cpp
// malloc
void* malloc(unsigned int num_size);
int *p = malloc(20*sizeof(int));//申请20个int类型的空间，初始值随机
//calloc
void* calloc(size_t n,size_t size);
int *p = calloc(20,sizeof(int));//省去人为空间计算，初始值为0
//realloc
void realloc(void *p,size_t new_size);//给动态分配的空间分配额外的空间，用于扩充容量
```

## 19、形参+实参 ！ ！ 

1. 形参变量只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。
2. 实参可以是常量、变量、表达式、函数等，无论实参是何种类型，在进行函数调用时，必须具有确定的值，以便将值传给形参
3. 实参和形参在数量上，类型上，顺序上必须严格一致
4. 函数调用中发生的数据传输是单向的，只能把实参的值传送给形参，不能反向传输
5. 当形参和实参不是指针时，是不同的变量，存在于不同的位置，copy，且形参会被释放

### 指针参数 & 引用参数！ ！

1. 指针参数传递本质上是值传递，传递是一个地址值

> 值传递：被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，形成实参的一个副本
>
> 值传递的特点：被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值(形参指针改变，实参指针不会变)

2. 引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间， 但这时存放的是由主调函数放进来的实参变量的地址

> 被调函数对形参(本体)的任何操作都被处理成**间接寻址**，因此，被调函数对形参的任何操作都会影响主调函数中的实参变量

3. 引用传递和指针传递是不同的，虽然都是在被调函数栈空间上的一个局部变量，但是**任何对于引用参数**的处理都会通过一个**间接寻址**的方式操作到主调函数中的相关变量；而对于指针传递的参数，如果改变被调函数中的指针地址，将应用不到主调函数的相关变量。如果需要进行修改，需要传递指向指针的指针或指针引用
4. 引用传参的好处 ： 在函数内部可以对此参数进行修改  +  提高函数的调用和运行的效率(没有了传值和生成副本的时间和空间消耗，指针传递需要给形参分配存储单元)
5. 用引用作为返回值：内存中不会产生被返回值的副本

> 不能返回局部变量的引用 + 不能返回函数内部 new 分配内存的引用 + 可以返回类成员的引用，但最好是 const

#### 使用的情况  ！ ！ 

1. 使用引用的主要原因

> 程序员能修改调用函数中的数据对象
>
> 通过传递引用而不是整个数据-对象，可以提高程序的运行速度

2. 一般的原则：对于使用引用的值而不做修改的函数：

> 如果数据对象很小，如内置数据类型或者小型结构，按照值传递
>
> 如果数据对象是**数组**，则使用**指针**(唯一的选择)，并且指针声明为指向const的指针
>
> 如果数据对象是较大的结构，则使用const指针或引用。节省析构所需的时间和空间
>
> 如果对象是类对象，则使用const引用 (传递类对象参数的标准方式是按照引用传递)、

3. 对于修改函数中数据的函数：

> 如果数据是内置数据类型，使用指针
>
> 如果数据对象是结构，则使用引用或指针
>
> 如果数据是类对象，使用引用

## 20、string + char *

string 继承自 basic_string，其实是对 char *进行了封装，包含了 char *数组， 容量，长度等属性

string 可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间(2*n)，然后将原字符串拷贝过去，并加上新增的内容

## 21、内存泄露

### 定义

一般是指 **堆内存的泄露**，堆内存是从堆中分配的，申请的堆内存没有被释放之后这块内存不能在使用，这块内存泄露了

### 避免方式

1. 计数法：new/malloc +1，delete/free -1，最后不为0表示泄露了
2. 一定要将基类的析构函数声明为**虚函数**，如果基类的析构函数不是析构函数，通过基类指针删除派生类对象时，只会调用基类的析构函数，而不会调用派生类的析构函数，派生类无法释放
3. 对象数组的释放一定要用 delete[]，new[] 分配的只能使用delete[]，delete只会释放数组的第一个元素的内存，其余仍会被占用
4. new/delete、malloc/free 成对使用

### 检测工具

1. Linux 下可以使用Valgrind工具
2. Windows下可以使用CRT库

## 22、对象复用 + 零拷贝 ！ ！ 

### 对象复用 ！ ！ 

本质是一种设计模式：Flyweight享元模式 ！ ！ 

通过将对象存储到 “对象池”中实现对象的重复利用，可以避免多次创建重复对象的开销，节约系统资源

### 零拷贝

一种**避免** CPU 将数据从一块存储拷贝到另外一块存储的技术 ；可以减少数据拷贝和共享总线操作的次数

push_back 调用拷贝构造函数和转移构造函数  emplace_back 插入的元素原地构造，不需要触发拷贝构造和转移构造

## 23、面向对象的三大特性

### 继承

**让某种类型对象获得另一个类型对象的属性和方法**，可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展

#### 继承方式

1. 实现继承：指使用基类的属性和方法而无需额外编码的能力
2. 接口继承：指仅使用属性和方法的名称，但是子类必须提供实现的能力
3. 可视继承：指子窗体(类)使用基窗体(类)的外观和实现代码的能力

### 封装

数据和代码捆绑在一起，避免外界干扰和不确定性访问，**把客观事物封装成抽象的类**，并且类可以把自己的数据和方法只让可信的类或对象操作，对不可信的进行信息隐藏。

### 多态

同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为(重载实现编译时多态，虚函数实现运行时多态)

多态性是指允许将父对象设置成为一个或更多的他的子对象相等的技术，赋值之后，根据当前赋值给他的子对象的特性以不同的方式运作。**允许将子类类型的指针赋值给父类类型的指针**

1. 覆盖(override) ：指子类重新定义父类的虚函数的做法
2. 重载(overload：指允许存在多个同名函数，参数表不同

## 24、四种强制转换 ！ ！ 

## 25、结构体内存对齐

```cpp
class S {
  int x; //0 - 3
  char y;// 4 - 4  ---> 4 - 7
  int z; //8 - 11
  double a; //12 - 19  ---> 16 - 23
};
cout << offsetof(S,x/y/z/a) << endl;
```

1. 分配的顺序是声明顺序，每个成员变量的起始地址必须满足其自身的对齐要求。
2. 结构体的总大小必须是最大对齐要求的倍数。
3. #pragma pack(x)

> 偏移量是 x 和当前变量大小中较小值的整数倍
>
> 整体大小要是 x 和最大变量大小中较小值的整数倍
>
> x = 1、2、4、8 ... 为其他值无效，按照默认

## 26、静态类型+动态类型 静态绑定+动态绑定

- 静态类型：对象在声明时采用的类型，在编译器既已确定
- 动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的
- 静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，**发生在编译期** ，
- 动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，**发生在运行期**

> 非虚函数一般是静态绑定，虚函数一般是动态绑定(如此才可实现多态)
>
> 动态类型可以更改，静态类型不能修改；实现多态必须是动态绑定；继承体系中只有虚函数使用的是动态绑定，其他都是静态绑定
>
> 注意：**绝对不要重新定义继承而来的非虚函数**；当缺省参数和virtual函数一起使用时一定要谨慎！ ！ ！

```cpp
class A{
  public:
  /*virtual*/ void fun(){cout << "A" << endl;}
};
class B : public A {
  public:
  void fun() {cout << "B" << endl;}
};
class C : public A {
  public:
  void fun() {cout << "C" << endl;}
};
int main() {
  C *pc = new C();//pc的静态类型是它声明的类型 C*，动态类型也是 C*
  B *pb = new B();//pb的静态类型是它声明的类型 B*，动态类型也是 B*
  A *pa = pc;//pa的静态类型是它声明的类型 A*，动态类型是pa指向的对象pc的类型 C*
  pa = pb;//动态类型改变
  C *pnull = NULL;//没有动态类型
  //不是 virtual 的时候
  pa->fun();// A::fun()，pa的静态类型是A*，不管其指向哪个子类，都是直接调用A::fun()
  pc->fun();//C::fun()
  pnull->fun();//C::fun()，空指针也可以调用函数，在编译期就确定了，和指针空不空没关系
  
  //如果是 virtual 时
  pa->fun(); //B::fun(),pa的动态类型指向 B*,现在 B 中查找，找到后直接调用
  pc->fun();//C::fun()
  pnull->fun();//空指针异常，对 func 的调用只能等到运行期才确定，然后发现pnull时空指针
  //如果所有的fun 是 virtual void fun(int i = x) {cout << i << endl;},且 Ai=0 Bi=1
  F *pf = new B();
  E *pe = pf;
  pf->fun(); // 1
  pe->fun(); // 0 调用了子类的函数，却使用了基类中参数的默认值
}
```

### 引用+动态绑定

引用在创建的时候必须初始化，在访问虚函数时，编译器会根据其所绑定的对象类型决定要调用哪个函数。**只能调用虚函数**。

```cpp
class base {
  public:
  virtual void fun() {
    cout << "base" << endl;
  }
};
class son : public base {
  public :
  virtual void fun() {
    cout << "son" << endl;
  }
  void tp() {
    
  }
}
int main() {
  son s;
  base &b = s;
  s.fun();//son::fun()
  b.fun();//son::fun()
}
```

**虚函数才具有动态绑定**，子类的非虚函数，基类是无法调用的， 使用基类指针指向子类也是一样

## 27、只能静态分配 & 只能动态分配

1. 前者是把 new、delete运算符重载为private属性；后者是把构造、析构函数设为protected属性，再用子类来动态创建
2. 建立类的对象的两种方式

- 静态建立：静态建立一个类对象，就是由编译器为对象在栈空间中分配内存
- 动态建立：A*p=new A()；动态建立一个类对象，就是使用new运算符为对象在堆空间中分配内存，第一步执行operatoe new()函数，在堆中搜索一块内存并进行分配，第二部调用类构造函数构造对象

3. 只有使用new运算符，对象才会被建立在堆上，因此只要限制 new 运算符就可以实现类对象只能建立在栈上，可以将new设为私有

## 28、组合 & 继承

### 继承 

继承是 is a 的关系，子类一定是父类的一种，优点是子类可以重写父类的方法来方便的实现对父类的扩展

缺点：

1. 父类的内部细节对子类是可见的
2. 子类从父类继承的方法在编译时就确定了，运行期间无法修改继承的方法的行为
3. 高耦合，父类方法修改(加参数)，子类必须做出相应的修改

### 组合

设计类的时候把要组合的类的对象加入到该类中作为自己的成员变量

优点：

1. 当前对象只能通过所包含的那个对象去调用其方法，所以所包含的对象的内部细节对当前对象是不可见的
2. 当前对象与包含的对象是一个低耦合关系，修改包含对象的类中的代码不需要修改当前对象类的代码
3. 当前对象可以在运行时动态的绑定所包含的对象，可以通过set方法给所包含对象赋值

缺点：1. 容易产生过多的对象 2. 为了组合多个对象，必须仔细对接口进行定义

## 29、函数指针

what ？ 函数指针指向的是特殊的数据类型，函数的类型是由其返回的数据类型和其参数列表共同决定的，而函数的名称则不是其类型的一部分，一个具体函数的名字，如果后面不跟调用符号(即括号)，则该名字就是该函数的指针

```cpp
int (*pf)(const int&,const int&);//pf就是一个函数指针，指向所有返回int，并两个参数，括号是必须的
```

why ？ 函数与数据项相似，函数也有地址，希望在同一个函数中通过使用相同的形参在不同的时间产生不同的效果

**一个函数名就是一个指针，指向函数的代码**，一个函数地址是该函数的进入点，也就是调用函数的地址。可以通过**函数名**或者**指向函数的指针**调用，函数指针还运行将**函数作为变元**传递给其他函数

how ？ 指针名 = 函数名   指针名 = &函数名

## 30、define & const & typedef & inline

1. const & #define

- const定义的类型是常量带类型，#define 定义的是常量不带类型
- define是在预处理阶段起作用，简单的文本替换，const是在编译、链接过程中起作用
- define只是简单的字符串替换没有类型检查，const是有数据类型的，要进行判断的，可以避免一些低级错误
- define 预处理之后，占用代码段空间，const占用数据段空间
- #define 可以通过#undef取消定义，实现重定义
- define独特功能，防止文件重复引用

2. #define & typedef

- typedef在编译阶段有效，具有类型检查的功能
- typedef用来定义类型的别名，定义与平台无关的数据类型，与struct结合使用；define取别名+定义常量、变量、编译开关
- #define 没有作用域，只要是之前预定义过的宏，在以后的程序都可以使用，typedef 有自己的作用域

3. define & inline

- define 是关键字， inline 是函数
- inline 在编译阶段进行替换
- inline具有类型检查，较安全

## 31、模板类

### 为什么一般在一个h文件

1. 由template<...>处理的任何东西都意味着编译器在当时不为它分配存储空间，一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义
2. 在分离式编译的环境下，编译器编译某一个 .cpp 文件时并不知另一个 .cpp 文件的存在，也不会去查找(当遭遇了未决符号时会寄希望于连接器)。**模板仅在需要的时候才会实例化出来**

> 当编译器只看到模板的声明时，不能实例化该模板，只能创建一个具有外部连接的符号并期待连接器能将符号的地址决议出来，然后当实现该模板的 cpp 文件中没有模板的实例时，编译器懒得去实例化，此时，整个工程的 obj 中就找不到一行模板实例的二进制代码，连接器没办法。
>
> 对于复杂的模板错误，多数情况下发生错误的位置是靠后的引用位置，否则需要分析所有引用位置 (使用生成输出窗口)

## 32、cout & printf

cout 是类 std::ostream 的全局对象，存在针对各种类型数据的**重载**，输出过程会首先将输出字符放在缓冲区中，然后输出到屏幕、

printf 是行缓冲输出，不是无缓冲输出

```cpp
cout << "abd" << endl; == cout << "abc\n";cout << flush;  //flush 立即强迫缓冲输出（endl换行，并且会刷新缓冲区)
```

## 33、ifdef & endif

```cpp
#ifdef 标识符 // 中间的代码只有在满足条件的时候才会进行编译，指定编译的条件  --> 条件编译
code1   //当标识符被定义过(一般使用#define定义)，才会判断为真
#else   // 多个文件包含同一个头文件时可能会出现重定义问题，在头文件中使用 可以避免头文件重定义
code2
#endif
```

## 34、隐式转换

1. 隐式转换是指不需要用户干预，编译器私下进行的类型转换。

2. 多态，就是通过父类的类型实现对子类的封装，通过隐式转换，可以直接将一个子类的对象使用父类的类型进行返回。C++是强类型语言
3. 基本数据类型的转换以取值范围的作为转换基础(保证精度不丢失)。隐式转换发生在小 -> 大的转换中，子类可以隐式转换为父类
4. explicit 可以禁止隐式转换，explicit 只对一个实参的构造函数有效，需要多个实参的构造函数不能用于执行隐式转换。
5. 如果构造函数只接受一个参数，则它实际上定义了转换为此类类型的隐式转换机制。

## 35、strcpy & memcpy & sprintf & strncpy

1. 复制的内容不同，前者只能复制字符串，memcpy可以任意复制，sprintf 操作的源对象可以是多种数据结构，但是目的操作对象是字符串
2. 复制的方法不同，前者不需要指定长度，遇到 '\0'结束，memcpy第三个参数指定复制的长度
3. 用途不同，字符串一般使用前者，其余使用memcpy
4. 执行效率：memcpy > strcpy > sprintf
5. strcpy 主要实现字符串变量间的拷贝 、 sprintf 主要实现其他数据类型格式到字符串的转化 、memcpy主要是内存块间的拷贝

### strcpy & strncpy

```cpp
char *strcpy(char *strdest,const char* strsrc);
char *strncpy(char *dest,const char *src,size_t n);
```

> strcpy 函数：如果dest 所指的内存空间不够大，可能会造成缓冲溢出。
>
> strncpy函数：用来复制源字符串的前 n 个字符，src 和 dest 所指的内存区域不能重叠，且 dest 必须有足够的空间放置 n 个字符
>
> 如果目标长 > 指定长 > 源长，则将源长全部拷贝到目标长，自动加上 '\0'
>
> 如果指定长 < 源长，则将源长中按照指定长度拷贝到目标字符串，不包括 '\0'
>
> 如果指定长 > 目标长，运行时错误

## 35、空类 & 函数

默认添加的函数

```cpp
empty() //缺省构造函数
empty(const empty&) //拷贝构造函数
~empty() 析构函数
empty & operator=(const empty&) 赋值运算符
```

## 36、C++ 标准库

1. 分为 **标准函数库** (这个库是由通用的、独立的、不属于任何类的函数组成的。基础自C)  + **面向对象类库** (这个库是类及其相关函数的集合)
2. 输入/输出IO、字符串和字符处理、数字、时间、日期和本地化、动态分配、其他、宽字符函数
3. 标准的C++IO类， string类、数值类、STL容器类、STL算法、STL函数对象、STL迭代器、STL分配器、本地化库、异常处理、杂项支持库

## 37、string & char *

实际操作可以使用 char * 给string 类初始化

```cpp
//string ->const char *
string s = "abc";
const char* cs = s.c_str();

//const -> string 
string s(cs);

//stirng -> char *
string s = "abc";
char *c;
const int len = s.length();
c = new char(len + 1);
strcpy(c,s.c_str);
// char * -> string 
char *c = "abc";
string s(c);

//const char* -> char *
const char* cpc = "abc";
char *pc = new char[strlen(cpc) + 1];
strcpy(pc,cpc);
//char * -> cosnt char *
char *pc = "abc";
const char *cpc = pc;
```

## 38、计算仅单个子类的对象个数 ！ ！ 

1. 为类设计一个 static 静态变量 count 作为计数器
2. 类定义结束后初始化 count
3. 在构造函数中对count进行 + 1
4. 设计拷贝构造函数，在进行拷贝构造函数中进行 count + 1 操作
5. 设计赋值构造函数，在进行赋值函数中对 count + 1 操作
6. 在析构函数中对count - 1 

## 39、阻止类实例化

1. 将类定义为抽象基类或将构造函数声明为 private
2. 不允许类外部创建类对象，只能在类内部创建对象

> 抽象基类 ： 包含至少一个**纯虚函数**的类。纯虚函数是一种**没有具体实现的虚函数**，他在基类中被声明为纯虚函数，目的是要求派生类必须实现这个函数，否则派生类也成为抽象类
>
> ```cpp
> class A {
>   public:
>   vtirual void fun() = 0;//纯虚函数
>   virtual ~A() {} //虚析构函数
> };
> ```
>
> 1. 不能被实例化：不能直接实例化
> 2. 必须被继承：抽象基类的目的是被继承。
> 3. 提供接口规范：抽象基类通常用于定义接口规范，规定了派生类必须实现哪些函数，从而确保派生类具有一定的行为
>
> 作用
>
> 1. 接口定义：抽象基类可以定义一组接口规范，要求所有派生类都实现这些接口，有助于确保代码的一致性和可维护性
> 2. 多态性：抽象基类和虚函数结合使用，可以实现多态性。通过基类指针或引用来调用派生类的函数，可以实现运行时的多态性
> 3. 代码结构化：抽象基类有助于将代码组织成层次结构，提高代码的模块化和复用性

## 40、Debug & Release

1. 调试版本：包含调试信息，容量比 Release 大得多，不进行任何优化(优化会是调试复杂化，因为源码和生成的指令间关系会更复杂)，便于程序员调试。有 .exe或 .dll 之外，还有一个 .pdb 文件，记录代码中断点等调试信息
2. 发布版本：不对源代码进行调试，编译时对应用程序的速度进行优化，使得程序在代码大小和运行速度上都是最优的。(调试信息可在单独的PDB文件中)，生成一个 exe 或 dll 文件
3. 没有本质的界限，知识一组编译选项的集合，编译器知识按照预定的选项行动。(自己可以修改这些选项)

## 41、模板

```cpp
template<typename type1,typename type2>
type1 Max(type1 a,type2 b) {
  return a > b ? a : b;
} //a b 能进行转型的时候才能比较，否则可能需要重载运算符
```

## 42、static_cast

与C语言中的转换相比

1. 更加安全
2. 更直接明显，能够一眼看出是什么类型转换为什么类型，容易找出程序中的错误；可清晰地辨别代码中每个显式的强制转；可读性更好，能体现程序员的意图

## 43、memset(this,0,sizeof(this))

1. int、char、struct等直接初始化为0
2. 类中含有虚函数：会破坏虚函数表，后续对虚函数的调用都会出现异常
3. 类中含有C++类型的对象：例如，类中定义了一个list对象，由于在构造函数体的代码执行之前就对list对象完成了初始化，假设list在他的构造函数里分配了内存，此时会破坏list的内存。

## 44、回调函数

1. 当发生某事件时，系统或其他函数将会自动调用你定义的一段函数
2. 回调函数就相当于一个中断处理函数，由系统在符合你设定的条件时自动调用。为此，你需要做三件事：1. 声明  2. 定义 3. 设置触发条件，就是在你的函数中把你的回调函数名称转换为地址作为一个参数，以便系统调用
3. 回调函数就是一个通过函数指针调用的函数。如果把函数的指针(地址)作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，这就是回调函数。
4. 因为可以把调用者和被调用者分开。调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值是int）的被调用函数。

## 45、C++执行过程

1. 预编译

> 主要处理源代码中以 # 开头的预编译指令
>
> 1. 删除所有 #define ，展开所有的宏定义
> 2. 处理所有的条件预编译指令，如 #if  #ifdef  #elif  #else 
> 3. 处理 #include 预编译指针，将文件内容替换到它的位置，递归进行的，文件中包含其他文件
> 4. 删除所有的注释
> 5. 保留所有的 #pargma 指令，编译器需要用到他们，如：#pragma once 是为了防止由文件被重复引用
> 6. 添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告时能够显示行号

2. 编译

> 把预编译之后生成的 xxx.i 或 xxx.ii 文件，进行一系列词法分析，语法分析，语义分析及优化后，生成相应的汇编代码文件
>
> 1. 词法分析：利用类似于“有限状态机”的算法， 将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号
> 2. 语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树
> 3. 语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语法是静态语义--在编译器能分期的语义，相对应的动态语义是在运行期才确定的语义
> 4. 优化：源代码级别的一个优化过程
> 5. 目标代码生成：有代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列--汇编语言表示。
> 6. 目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式，使用位移来替代乘法运算，删除多余的指令等

3. 汇编

> 将汇编代码转变为机器可以执行的指令（机器码文件）。汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成，经汇编之后，产生目标文件（与可执行文件格式几乎一样）   xxx.o - Linux    xxx.obj -Window

4. 链接

> 将不同的源文件产生的目标文件进行链接，从而形成一个可执行的程序。链接分为**静态链接**和**动态链接**
>
> 静态链接：
>
> 函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其他模块组合起来创建最终的可执行文件
>
> 空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都要依赖，会出现同一个目标文件都在内存存在多个副本。
>
> 更新困难：每当库函数的代码修改了，这个时候就需要重写进行编译链接形成可执行程序
>
> 运行速度快：到那时静态链接的有点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。
>
> 动态链接：
>
> 基本思想时把程序按照模块拆分成各个相对独立部分，在程序运行时才将他们链接在一起形成一个完整的程序，而不是像静态链接一样把所有模块都链接成一个单独的可执行文件。
>
> 共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本
>
> 更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序在重写链接一遍，当程序下一次运行时，新版本的目标文件会被自动加载到内存中并链接起来，程序就完成了升级
>
> 性能损耗：因为把链接推迟到了程序运行时，每次执行程序都需要进行链接，所以性能会有一定的损失

## 46、友元

> 友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。通过友元，一个不同函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致可维护性变差

### 友元函数必须在类内声明




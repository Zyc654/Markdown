****

## 算法基础

##### 迭代器

~~~C++
vector<type>::iterator iter;//type 类型
map<type,type>::iterator iter;//迭代器类型可以使用auto
set<type>::iterator iter;
等等.....
迭代器可以像指针一样，遍历STL时可以直接对迭代器 ++ --  ；
访问迭代器的值的形式：
*iter
iter->first    iter->second   
~~~

##### bitset

~~~C++
bitset, 圧位（存放一个十进制数的二进制，可以像数组一样来使用）
    bitset<10000> s;
    ~, &, |, ^
    >>, <<
    ==, !=
    []
 
    count()  返回有多少个1
 
    any()  判断是否至少有一个1
    none()  判断是否全为0
 
    set()  把所有位置成1
    set(k, v)  将第k位变成v
    reset()  把所有位变成0
    flip()  等价于~
    flip(k) 把第k位取反
~~~

**attention : ** `bitset`的第 `x`位数据表示数据位 x 的状态是否可行，就是当为 x 的时候是否可以分割，所以`bitset`的大小是数据和，这样才能表示出所有状态，同时，比较的时候即是当前状态异或状态右移`x`，返回值也是`bitset`即是将对应的位置的值改变 01 值，例：`f[0] = 1，f |= (f << 2) ,即是 f[2] = 1，2 可做分割点，这里的 2 表示的是当前价值为 2 `



###  __int128

~~~C++
inline __int128 read(){
    __int128 x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
inline void print(__int128 x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9)
        print(x/10);
    putchar(x%10+'0');
}
~~~

### STL 集合小函数

- ```c++ 
  accumulate(begin,end,init);//对一个元素序列求和,初始值是 init 即是将和再加上init
  ```

- ```c++
  is_sorted(begin,end);//判断是否有序(升序),返回bool值,升序返回yes
  ```

- ```c++
  iota(begin,end,num);//让序列递增赋值,num是给定的begin的值,后面的值依次大一
  ```

- ```c++
  next_permutation(begin,end);//求序列的下一个排列,下一个排列是字典序大一号的排列.如果是最后一个排列返回false,否则求出下一个排列后返回true
  ```

- ```c++ 
  prev_permutation(begin,end);//求出前一个排列,如果是最小的排列,将其重排为最大的排列,返回false
  ```

- ```c++
  unique(begin,end);//消除重复元素,返回消除完重复元素的下一个位置的地址.(这个函数消除的必须是连续重复的不是不连续的出现过多次的).
  ```

- __builtin(用位运算函数)

- ```c++
  用法 : 返回括号内的二进制表示形式中末尾 0 的个数.
  __builtin_ctz()  /  __builtin_ctzll() //(有ll表示按longlong计算) 、
      
  用法 : 返回括号内数的二进制表示形式中的前导 0 的个数.
  __builtin_clz()  /  __builtin_clzll() // ll 同上
      
  用法 : 返回括号内的二进制表示形式中 1 的个数
  __builtin_popcount() ;
  
  用法 : 返回括号内数的二进制表示形式中 1  的个数的奇偶性(偶 : 0 ,,奇 : 1)
  __builtin_parity() ;
  
  用法 : 返回括号内数的二进制形式中最后一个 1 在第几位数(从后往前).
  __builtin_ffs() ;
  
  用法 : 快速开平方 
  __builtin_sqrt() / __builtin_sqrtf() ; //同上,sqrt八位,sqrtf四位,比sqrt快 10 倍
  ```

### 排序   -- $快排加归并$

```cpp
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;
 
    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}

//归并
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;
 
    int mid = l + r >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);
 
    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];
 
    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];
 
    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```

### 二分

```cpp
// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
//板子中的check 返回的是 1, 即是 mid 一定要满足当前情况 
int bsearch_1(int l, int r)//求满足要求的最小值,求左端点
{
	while (l < r)
	{
		int mid = l + r >> 1;
		if (check(mid)) r = mid;    // check()判断mid是否满足性质
		else l = mid + 1;
	}
	return r;
}
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bsearch_2(int l, int r)//求满足要求的最大值,求右端点
{
	while (l < r)
	{
		int mid = l + r + 1 >> 1;
		if (check(mid)) l = mid;
		else r = mid - 1;
	}
	return r;
}//浮点数二分注意精度即可,比要求多2位小数即可
```

### 三分

```cpp
//以凸函数位例子 
int check(x){.....} 	//返回判断当前点对应的函数值 
int bsearch_1(int l, int r)
{
    while (l < r-1)
    {
    	//三分的两个中点有两种写法
		// m1 = l+(r-l)/3;
		// m2 = r-(r-l)/3;
        m1 = l+r>>1;
        m2 = m1+r>>1;
        if(check(m1) > check(m2)) r=m2;
        else l=m1;
    }
    return l;
}
//对于极大值的求法我觉得有个技巧吧，就是while里面的范围，l和 r 差的 范围可以扩大一点点 
//这样最后求极大值时可以遍历l到r，避免的精度不到位出现问题； 
//以凸函数位例子 
double check(x){.....} 	//返回判断当前点对应的函数值 
double bsearch_1(double l, double r)
{
    while (r-l>eps)
    {
    	//三分的两个中点有两种写法
		// m1 = l+(r-l)/3;
		// m2 = r-(r-l)/3;
        m1 = (l+r)/2;
        m2 = (m1+r)/2;
        if(check(m1) > check(m2)) r=m2;
        else l=m1;
    }
    return l;
}
```

### 高精度

```cpp
//高精度计算时,存数据的时候都是逆序的,从后往前存,对于vector数组从后往前遍历是原数据
for(int i = a.size()-1;i>=0;i--) A.push_back(a[i] - '0');//A = [6,5,4,3,2,1]
for(int i = b.size()-1;i>=0;i--) B.push_back(b[i] - '0');
//输出的时候也要注意从后往前输出
for(int i = C.size()-1;i>=0;i--) cout << C[i];
//加法
vector<int> add(vector<int> &A,vector<int> &B)//添加引用可以节省时间
{
	
	vector<int> C;
	int t = 0;//进度
	for(int i=0;i<A.size() || i < B.size();i++){
		if(i < A.size()) t += A[i];
		if(i < B.size()) t += B[i];
		C.push_back(t % 10);
		t /= 10;
	}
	if(t) C.push_back(t);
	return C;
}
//减法
//判断AB之间的大小关系
bool cmp(vector<int> &A,vector<int> &B)
{
	if(A.size() != B.size()) return A.size() > B.size();//0 或 1
	for(int i = A.size() - 1;i>=0;i--)
		if(A[i] != B[i]) return A[i] > B[i]; // 0 或 1
	return true;//两者相等
}
vector<int> sub(vector<int> &A,vector<int> &B)//添加引用可以节省时间
{
	vector<int> C;
	for(int i =0,t=0; i<A.size();i++)
	{
		t = A[i] - t;
		if(i < B.size()) t -= B[i];
		C.push_back((t + 10)%10);//中和了借1和单纯减
		if(t < 0) t = 1;
		else t = 0;
	}
	while(C.size() > 1 && C.back() == 0 ) C.pop_back();//删除前导0
	return C;
}
//乘法
vector<int> mul(vector<int> &A,int b)
{
	vector<int> C;
	int t=0;  //进位
	for(int i=0;i<A.size() || t;i++) //加上t是因为最后一位乘法时可能出现进位
	{
		if(i < A.size()) t += A[i] * b;
		C.push_back(t%10);
		t /= 10;  //进位
	}
	return C;	
}
//除法
vector<int> div(vector<int> &A,int b,int &r)//r必须传引用或指针因为需要其改变
{
	vector<int> C;//商
	r = 0;
	for(int i = A.size() - 1;i>=0;i--)
	{
		r = r * 10 + A[i];  //余数放在下一位相当于下一位变成10*r + A[i]
		C.push_back(r / b);
		r %= b;
	}
	reverse(C.begin(),C.end()); //因为i从大到小所以结果是倒序的反转回来
	while(C.size() > 1 && C.back() ==0) C.pop_back();
	
	return C;
}
//高 * 高
int a[10000],b[10000],c[10000];
int main()
{
	string a1,b1;
	cin>>a1>>b1;
	int lena=a1.size();
	int lenb=b1.size();
	for(int i=lena-1,j=0; i>=0; i--,j++) a[j]=a1[i]-'0';
	for(int i=lenb-1,j=0; i>=0; i--,j++) b[j]=b1[i]-'0';
	for(int i=0; i<lena; i++)
	  for(int j=0; j<lenb; j++)
	  {
	  	c[i+j]+=a[i]*b[j]; 
	  	c[i+j+1]+=c[i+j]/10; // 进位 
	  	c[i+j]%=10;          //实际保留的值 
	  }
	int lenc=lena+lenb-1; // 两位数相乘最大位数是lena+lenb ，-1是因为下标从0开始
	while(c[lenc]==0 && lenc>0) lenc--; // 去前导0
	for(int i=lenc; i>=0; i--)
	{
		cout<<c[i];
	}
}
```

### 离散化

```cpp
//保序
vector<int> alls; // 存储所有待离散化的值
sort(alls.begin(), alls.end()); // 将所有值排序
alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素
 
// 二分求出x对应的离散化的值
int find(int x) // 找到第一个大于等于x的位置
{
    int l = 0, r = alls.size() - 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1; // 映射到1, 2, ...n
}
unordered_map<int,int> mp;//增删改查的时间复杂度是 O(1)
int res;
int find(int x)
{
	if(mp.count(x)==0) return mp[x]=++res;
	return mp[x];
}
```

### RMQ

```cpp
//以查询最大值为例
状态表示： 集合：f(i,j)表示从位置i开始长度为2^j的区间的最大值；
           属性：MAX
状态转移： f(i,j)=max(f(i,j-1),f(i+(1<<(j-1)),j-1));
           含义：把区间[i,i+2^j],分成两半，[i,i+2^(j-1)]和[i+(1<<(j-1)),2^j],整个区间最大值就是这两段区间最大值的最大值
const int N=2e5+7,M=20;
int dp[N][M]; //存储区间最大值
int a[N];//存放每个点的值
//dp求从位置i开始长度为2^j的区间的最大值
for(int j=0;j<M;j++)
{
    for(int i=1;i+(1<<j)-1<=n;i++)
    {
        if(!j) dp[i][j]=a[i];
        else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
    }
}
//求任意区间的最大值；（可以预处理log）
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
}
```

### 二维差分  

```cpp
for(int i=1;i<=n;i++)//求前缀和
    for(int j=1;j<=m;j++)
        s[j][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j];
while(q--)//算子矩阵的和
{
    int x1,y1,x2,y2;
    cin >> x1 >> y1 >> x2 >> y2;
    cout << s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1];
}
// 差分
void insert(int x1,int y1,int x2,int y2,int c)
{
	b[x1][y1] += c;
	b[x2+1][y1] -= c;
	b[x1][y2+1] -=c;
	b[x2+1][y2+1] +=c;
}//差分数组求前缀和得到当前元素
```

**attention : ** 异或具有前缀和的性质！！！

### $bitset$

#### 学习 `bitset` 数组

简介 ： bitset 是标准库中的一个存储 0/1 的大小不可变容器.    bitset 就是通过固定的优化,使得一个字节的八个比特能分别储存 8 位的 0/1.int的 1/32 倍.
  允许的运算 ： `==、!=、&、|、^、~，>>、<<；注意  bitset 只能与 bitset 进行位运算，不同类需要强制类型转换`
  **attention** :  `bitset`的第 `x`位数据表示数据位 x 的状态是否可行，就是当为 x 的时候是否可以分割，所以`bitset`的大小是数据和，这样才能表示出所有状态，同时，比较的时候即是当前状态异或状态右移`x`，返回值也是`bitset`即是将对应的位置的值改变 01 值，例：`f[0] = 1，f |= (f << 2) ,即是 f[2] = 1，2 可做分割点，这里的 2 表示的是当前价值为 2 `

  ```cpp
  count() ;// 返回 true 的数量
size() ; // 返回 bitset 的大小
test(pos) ;//他和vector中的  at() 的作用是一样的,和 [] 运算符的区别是越界检查 
any() ;//若存在某一位是 true 则返回 true,否则返回 false
none() ;//若所有的位都是 false ,则返回 true,否则返回 false .
all() ;// C++11 .若所有的位都是 true则返回 true,否则返回false. 
[]操作符    s[k] 表示 s 的第 k 位，即可取值也可赋值，编号从 0 开始
输出bitset 变量名时，是直接输出全部内容的，且是倒着输出的，即是第 0 位对应最右边
  ```

- bitset 优化 01 背包分割点问题 [P1537弹珠](https://www.luogu.com.cn/problem/P1537)

```cpp
//bitset 优化问题   --- 一般用于优化 01 背包分割问题
f[i][j] |= f[i - 1][j - a[i]];//表示前 i-1 维能否达到 j - a[i] 的状态，判断是否可以将 j 作为分割点
//将 二维总体积倒序循环 即可优化掉第一维
for(int i=1;i<=n;i++)//表示组
{
    for(int j=s;j>=a[i];j--)//总体积倒序
        f[j] |= f[j - a[i]];
}
//考虑优化第一维之后实质上就是将原数组的 01 串左移了 w[i] 位与原串取或，则转移可以写为
f[j] |= f[j] << w[i];
for(int i=1;i<=n;i++)//表示体积
{
    for(int j=1;j<=a[i];j++)//个数
        f |= (f << i);
}
```


#### [bitset 扩展](https://atcoder.jp/contests/abc348/tasks/abc348_f)

```cpp
bitset<N> bt[N][M],t;//bt[j][x] 表示第 j 列出现数字 x 的情况(表示在第几行出现)，bt[j][x][k]
//为 1 表示第 k 行第 j 列存在数字 x 
//枚举每一行，到 i 的时候，将 bt[j][a[i][j]](0 <= j < m)做异或和，因为
// 是存在奇数次相同就相似，所以在异或和中，相似的行编号对应位将为 1，异或和中
// 1 的数量即为序列[1,i - 1]中与序列 i 相似的序列数量。
// 然后将第 i 行中第 j 列数字 a[i][j] 的情况更新，即 bt[j][a[i][j]]置为 1
// 复杂度优化为 O(n * n * m / 64)
int n,m;
int g[N][N];
void solve() 
{
    cin >> n >> m;
    int ans = 0;
    pre(i,1,n)
    {
        pre(j,1,m)
        {
            cin >> g[i][j];
            g[i][j] --;
        }
        t.reset();//将 t 置为 0，初始化
        pre(j,1,m)
        {// bt 表示的是第 j 列 x 出现的情况，出现过的行对应的位置是 1，bitset输出时是倒序输出的
            t ^= bt[j][g[i][j]];//bt 表示第 j 列 x 出现的情况是数组
            //后面在加索引表示每一行出现的情况
            // cout << " w " << bt[j][g[i][j]] << endl;
            bt[j][g[i][j]][i] = 1;//更新状态，第 i 行第 j 列 x 出现过了
        }
        // cout << t << endl;
        ans += t.count();//表示枚举到第 i 行的时候得到的数量，t 中 1 的个数
    }
    //相当于将每一列中 x 出现的情况都预处理出来，bitset对应的三维数组，第二维表示的 x，第一维是 列
    //第三维是 行，每次 异或 bt[j][g[i][j]]表示进入第 j 列 x 的情况，然后和之前的异或可以得到这个数在不同行的情况
    cout << ans << endl;
} 
```

## 搜索

### DFS - 八皇后问题

```cpp
int n;
char g[N][N];//路径
bool col[N],dg[N],udg[N];
//col表示该列是否有皇后 dg表示对角线 udg表示反对角线
/*第一种搜索顺序*/
void dfs(int u)
{
	if(u == n)//行
	{
		for(int i=0;i<n;i++)
			puts(g[i]);
		puts("");
		return;
	}	
	for(int i=0;i<n;i++)
		if(!col[i] && !dg[u+i] && !udg[n - u + i])
		{
			g[u][i] = 'Q';
			col[i] = dg[u + i] = udg[n - u + i] = true;
			dfs(u + 1);
			col[i] = dg[u + i] = udg[n - u + i] = false;
			g[u][i] = '.';
		}
}
int main01()
{
	cin >> n;
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
			g[i][j] = '.';
	dfs(0);
	return 0;	
}
```

### BFS

```cpp
int g[N][N];//g数组用来存储输入的图
int d[N][N];//d数组用来每一个点到起点的距离
PII q[N*N],Prev[N][N];//手写队列，可以直接用queue,prev记录这个路是从哪一点过来的
int bfs()
{
	int hh=0,tt=0;//头 尾 - 用来表示 点的移动
	q[0] = {0,0};
	memset(d,-1,sizeof(d));//距离初始化，表示没有走过
	d[0][0] = 0;
	int dx[4] = {-1,0,1,0},dy[4]={0,1,0,-1}; // 表示一个点向四个方向找下一层是，坐标的变化
	while(hh <= tt)//队列不空
	{
		auto t = q[hh++];//每一次取出队头元素
		for(int i=0;i<4;i++)//上下左右四个方向判断
		{//用向量表示移动情况
			int x = t.first + dx[i],y=t.second + dy[i];//x y表示沿着这个方向走可以走到的点
			if(x>=0 && x<n && y>=0 && y<m && g[x][y] == 0 && d[x][y]==-1)
			{ // 在图的范围内                 是通路 - 0      没有走过
				d[x][y] = d[t.first][t.second] + 1; //更新这个点的距离
				Prev[x][y] = t;//这个队列从t点过来的，即队列的头，终点未存进队列中
				q[++tt] = {x,y};//把这个点存进队列中              当hh = n时跳出循环了
			}//Prev队列中存储的最后一个点是终点的前一个点，终点距离更新了，但终点未存进队列
		}
	}
	int x = n-1,y = m-1;//表示路径，看题目是否要求 - 此处逆序的
	while(x || y)
	{
		cout << x <<' ' << y << endl;
		auto t = Prev[x][y];//最后一点未存进队列中
		x = t.first,y= t.second;//死记-先存y再存x
	}	
	return d[n-1][m-1];//输出右下交的点代表的距离 - 看出口在哪里	
}
```

### 双端BFS (01 BFS)

又称 0-1 BFS,即是边权为 0 或 1的最短路,**实现 : **一般情况下把没有边权的边扩展到的点放到队首,有权值的边扩展到的点放到队尾,.这样即可 保证像普通 BFS一样整个队列队首到队尾权值单调不下降     [cf 173B](https://codeforces.com/problemset/problem/173/B)

```cpp
//有权值的边1放队尾，少用；无权值0放队首，尽量用；
//这样先出队的队头元素永远是距离较小的点，完美替代优先队列。
void bfs()
{
	memset(dist,0x3f,sizeof dist);
	memset(f,0,sizeof f); 
	dist[stx][sty]=0;
	deque<PII> que;
	que.push_front({stx,sty});
	while(que.size())
	{
		int x=que.front().first,y=que.front().second;
		que.pop_front(); 
		if(f[x][y]) continue; //该点之前出队过，最短路径已确定，跳过。
		f[x][y] = true;
		for(int i=0;i<4;i++)
		{
			int tx=x+dir[i][0],ty=y+dir[i][1],flag=0;
			if(tx<1||tx>n||ty<1||ty>m) continue;
			if(a[x][y]!=a[tx][ty]) flag=1;
			if(dist[tx][ty]>dist[x][y]+flag){
				dist[tx][ty]=dist[x][y]+flag;
				if(flag) que.push_back({tx,ty}); //有权值的边放队尾，少用 
				else que.push_front({tx,ty}); //无权值放队首，尽量用 
			}
		}
	}
}
```

## DP

### 背包

#### 01 背包

- 主要是倒序计算体积

```c++
for(int i=1;i<=n;i++) cin >> v[i] >> w[i];//  n 是物品个数,m 是体积
for(int i=1;i<=n;i++)
    for(int j=m;j>=v[i];j--)//倒序，保证此时已经是选了i-1个物体，防止误更新问题出现
        f1[j] = max(f1[j],f1[j-v[i]] + w[i]);
cout << f1[m] << endl;
```

##### 01背包的回溯

选取恰好凑成目标体积的序列的**最小字典序**

```cpp
 {
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    sort(a + 1, a + 1 + n);
    dp[n + 1][0] = 1;
    for (int i = n; i >= 1; i--)
    {
        for (int j = 0; j <= m; j++)
        {
            dp[i][j] = dp[i + 1][j];
            if (j >= a[i])
                dp[i][j] |= dp[i + 1][j - a[i]];
        }
    }
    if (dp[1][m])
    {
        int j = m;
        vector<int> ve;
        for (int i = 1; i <= n; i++)
        {
            if (j - a[i] >= 0 && dp[i + 1][j - a[i]] == dp[i][j] && dp[i][j])
                j -= a[i], ve.push_back(a[i]);
        }
        for (int i = 0; i < ve.size(); i++)
            cout << ve[i] << " \n"[i == ve.size() - 1];
    }
    else
        cout << "No Solution" << endl;
}
```



#### 完全背包 

-  每个物品有无数个,这个时候需要正序循环

```c++
for(int i=1;i<=n;i++) cin >> v[i] >> w[i]; // n,m 的意义同上
for(int i=1;i<=n;i++)
    for(int j=v[i];j<=m;j++)//正序，保证物品无限个，后面的数据及时更新
        f2[j] = max(f2[j],f2[j-v[i]] + w[i]);
cout << f2[m] << endl;
```

-   体积为 `a[i]` 价值为 `1` `dp` 表示选取体积为 `j` 价值为 `k` 的方案数

```cpp
pre(i, 1, n)
{
    pre(j, a[i], v) // 体积正序
    {
        rep(k, m, 1) //价值还是倒序
            dp[j][k] = (dp[j][k] + dp[j - a[i]][k - 1]) % mod;
    }
}
```

#### 多重背包

- 每个物品有 x 个,如何选择使得总价值最大--- 二进制优化后由于二进制可以组成任意数,转换为 01 背包,一次选一二进制组.

```c++
cin >> n >> m;
int cnt =0;
for(int i=1;i<=n;i++)
{
    int a,b,s;
    cin >> a >> b >> s;
    int k = 1;
    while(k<=s)
    {
        cnt ++,v[cnt] = a * k,w[cnt] = b * k,s -= k,k *= 2; 
    }
    if(s>0)//C
    {
        cnt ++,v[cnt] = a * s,w[cnt] = b * s;
    }
}
n = cnt;//打包转换为01背包
for(int i=1;i<=n;i++)
    for(int j = m;j>=v[i];j--)
        f3[j] = max(f3[j],f3[j-v[i]]+w[i]);
cout << f3[m] << endl;
```

#### 分组背包问题

- 每个组内的物品最多选一个或者不选,求最大价值.

```c++
cin >> n >> m;
for(int i=1;i<=n;i++)
{
    cin >> s[i];
    for(int j=0;j<s[i];j++)
        cin >> v[i][j] >> w[i][j];//具体输入根据题目要求,价值和体积可能分开输入可能一起输入
}
for(int i=1;i<=n;i++)
    for(int j=m;j>=0;j--)//倒序,代表每组只有选或不选,保证当前数据是 i-1 的时候的数据
        for(int k=0;k<s[i];k++)//遍历组内的物品,每次都是在 i-1 的基础上选或不选
            if(v[i][k] <= j)//只有这个物品能放进去才有更新的意义
                f[j] = max(f[j],f[j - v[i][k]] + w[i][k]);
cout << f[m] << endl;
```

#### 树上背包(依赖背包)

只有根节点选取才能继续选取后面的物品

```cpp
void dfs(int u)
{
    for(int i = v[u]; i <= m; i ++) f[u][i] = w[u];
    for(auto son : g[u])
    {
        dfs(son);
        for(int j = m; j >= v[u]; j --)
            for(int k = 0; k <= j - v[u]; k ++)
                f[u][j] = max(f[u][j], f[u][j - k] + f[son][k]);
    }
}
```

### 滑动窗口优化DP

```cpp
pre(i,1,n)
{
    deque<array<int,2>> q;//第一维是值 ,第二维是下标
    dp[i][1] = 1;
    q.push_back({1,1});
    pre(j,2,m)
    {
        dp[i][j] = min(dp[i][j],q.front()[0] + g[i][j] + 1);//根据题目修改,此题求解的是区间内选取两点最大为d的总价值最小
        //deque 对头的结果一直都是满足要求的最优解,  只需要对对头进行操作即可
        while(!q.empty() && j - q.front()[1] > d) q.pop_front();//区间长度是 d
        while(!q.empty() && dp[i][j] <= q.back()[0]) q.pop_back(); // 最大最小值 需要对应修改 大于小于号 , 此时最小值
        q.push_back({dp[i][j],j});
        // cout << dp[i][j] << " ";
    }
    // cout << endl;
    ans[i] = ans[i - 1] + dp[i][m];
}
```

### 最长上升子序列模型

前言 - 一个序列的最长上升子序列的长度==非上升子序列覆盖整个序列的个数

#### `O(NlogN)`

~~~c++
int len=0;
for(int i=1;i<n;i++)
{
    int pos=lower_bound(f, f+len, a[i]) - f;
    len=max(len,pos+1);
    f[pos]=a[i];
}
cout <<len<<endl;
//求最长下降子序列也可以用相同的优化
int len=0;
for(int i=1;i<n;i++)
{
    int pos=upper_bound(f, f+len, a[i], greater<int>()) - f;//更新序列结尾第一个小于a[i]的序列
    len=max(len,pos+1);
    f[pos]=a[i];
}
cout <<len<<endl;
~~~

#### 最长公共序列模型

##### 非排列型

~~~c++
int main()
{
    int n,m;
    cin >>n>>m;
    for(int i=1;i<=n;i++) cin >>a[i];
    for(int i=1;i<=m;i++) cin >>b[i];
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            f[i][j]=max(f[i-1][j],f[i][j-1]);
            if(a[i]==b[j]) f[i][j]=max(f[i][j],f[i-1][j-1]+1);
        }
    }
    cout <<f[n][m]<<endl;
}
~~~

##### 排列型

```cpp
vector<int> a(n + 1),b(n + 1);map<int,int> mp;
for(int i=1;i<=n;i++) cin>>a[i], mp[a[i]]=i;
for(int i=1;i<=n;i++) cin>>b[i];
int len=0;
for(int i=1;i<=n;i++)
{
    if(mp[b[i]]>d[len]) d[++len]=mp[b[i]];
    else 
    {
        int p=lower_bound(d+1,d+1+len,mp[b[i]])-d;
        d[p]=mp[b[i]];
    }
}
cout<<len<<endl;
```

##### 求LCS

```cpp
void lcs()
{
    for(int i=1; i<=len1; i++)
    {
        for(int j=1; j<=len2; j++)
        {
            if(a[i-1] == b[j-1])
                dp[i][j] = dp[i-1][j-1] + 1;
            else if(dp[i-1][j] > dp[i][j-1])
                dp[i][j] = dp[i-1][j];
            else
                dp[i][j] = dp[i][j-1];
        }
    }
}
void llcs()
{
    int i, j, z = 0;
    char c[1001];
    memset(c, 0, sizeof(c));
    i = len1, j = len2;
    while(i!=0 && j!=0)
    {
        if(a[i-1] == b[j-1])
        {
            c[z++] = a[--i];
            j--;
        }
        else if(dp[i-1][j] < dp[i][j-1])
            j--;
        else if(dp[i][j-1] <= dp[i-1][j])
            i--;
    }
    for(i=z-1; i>=0; i--)
        printf("%c", c[i]);
    printf("\n");
}
```

### 最长公共上升序列模型

~~~c++
//f[i][j]表示所有在a[0...i],b[0....j]中出现过，以b[j]结尾的序列的集合
 
int ans=0;
for(int i=1;i<=n;i++)
{
    int temp=1;
    for(int j=1;j<=n;j++)
    {
        f[i][j]=max(f[i-1][j],f[i][j]);
        if(a[i]==b[j]) f[i][j]=max(temp,f[i][j]);
        if(a[i]>b[j]) temp=max(temp,f[i-1][j]+1);
    }
}
for(int i=1;i<=n;i++) ans=max(ans,f[n][i]);
~~~

### 编辑距离

~~~C++
//f(i,j)表示a[1...i]和b[1....j]编辑成相同的需要的操作次数集合  
cin >>n>>a+1;
cin >>m>>b+1;
for(int i=1;i<=n;i++) f[i][0]=i;
for(int i=1;i<=m;i++) f[0][i]=i;
for(int i=1;i<=n;i++)
{
    for(int j=1;j<=m;j++)
    {
        f[i][j]=min(f[i-1][j]+1,f[i][j-1]+1);//添加或者删除
        if(a[i]==b[j]) f[i][j]=min(f[i][j],f[i-1][j-1]);
        else f[i][j]=min(f[i][j],f[i-1][j-1]+1);//修改
    }
}
cout <<f[n][m]<<endl;
~~~

### 换根DP

- 换根DP是一种用来求树上各点道其他点的距离之和的算法,通常不会指定根节点,并且根节点的变化会对一些值,例如子节点深度和,点权和等产生影响,通常需要两遍DFS,第一次DFS预处理诸如深度,点权和之类的信息,第二次DFS开始进行换根DFS

  > 用于求出树上所有点为根节点时到其他点的距离之和.
  >
  > 假设 a为根节点，b为直系子节点，那么对于 b 所在子树对 a 的贡献为 dis[b] + size[b] ,其中 dis[b] 为 **b** 到以 **b** 为根节点的子树中所有点的距离之和。size[b]为以 **b** 为根节点的子树中的点的个数，其实很好理解，就相当于以 b为根节点中的所有路径长度全部 +1，然后就到达了 a 节点。
  >
  > 换根dp,换根DP的思想就是**把所有与根相连的节点通过一定的操作将其变为根**,依然利用上述节点 a,b,将根节点从  a 换到 b ,dp[b] = dp[a] - size[b] + (n - size[b]),−size[b] 表示从 b 引申出来的 size[b] 条路径长度全部 −1,n−size[b] 表示从 a 引申出来的不包含 b 的其他路径长度全部 +1

  ```c++
  int dis[N];//第一次dfs每个节点到其子节点距离之和 
  int size[N];//每个节点下子节点个数（包括这个节点本身） 
  int dp[N];//最终结果  
  bool vis[N];
  vector<int> vec[N];
  void dfs(int x)
  {
  	vis[x] = true;
  	int sum = 0;
  	for(int i=0;i<vec[x].size();i++)
      {
  		int y = vec[x][i];
  		if(!vis[y])
          {
  			dfs(y);
  			sum += size[y];
  			dis[x] += dis[y]+size[y];
  		}
  	}
  	size[x] = sum+1;
  	return ;
  }
  memset(vis,0,sizeof(vis));//dfs时使用过一次，因此需要清空
  dp[a]=dis[a];//此处a指代上面自己找的dfs起点，一般情况下a=1
  void Dp(int x)
  {
  	vis[x] = true;
  	for(int i=0;i<vec[x].size();i++)
      {
  		int y = vec[x][i];
  		if(!vis[y])
          {
  			dp[y] = dp[x] - size[y] + n - size[y];
  			Dp(y);
  		}
  	}
  }
  ```

### [状态压缩DP](https://www.cnblogs.com/mxrmxr/p/9799832.html)

[press](https://www.cnblogs.com/Tony-Double-Sky/p/9283254.html)
`状态压缩DP`一般是基于二进制进行的，结合位运算

- **基于连通性** DP（棋盘式）
- 集合式（表示每一个元素是否存在集合中）

DP 的过程是随着阶段增长，在每个状态维度上的分界点组成了 `DP`拓展的轮廓，对于某些问题，我们需要在 `DP`的状态中记录一个集合，保存这个轮廓的详细信息，以便于进行状态转移。若集合大小不超过 N ，集合中每个元素都是小于`k`的自然数，，**则我们可以把这个集合看做一个 N 位 k 进制数。以一个[0,k^N-1]之间的十进制整数的形式作为 DP 状态的一维，这种把集合转换为整数记录在 DP 状态中的一类算法被称之为 状态压缩 DP**
[互不侵犯](https://www.luogu.com.cn/problem/P1896)
每个国王会攻击附近的 8 格，求方案数使得 m 个王国互不攻击，`n`较小，一般不是搜索就是 DP，对于 `DP`的状态递推，一个是过往使用个数，另一个是行或列的状态(**对于矩阵状压DP常用行作为状态)**，且由于行 n 较小可以直接使用二进制数来表示当前每一行状态 -- 第几行 （i），此行的状态（j），这一行已经使用的国王数（s）

```cpp
f[i][j][s] = sum(f[i - 1][k][s - gs[j]];// gs 表示预处理数据这一行放的国王数目
//f[i][j][s]表示在只考虑前 i 行时，在前 i 行(包括i)有且仅有 s 个国王，且第 i 行的情况是 j 状态时情况的总数，而 k 代表第 i - 1行国王情况的状态编号。（j，k <= n）
//核心在于需要预处理每个状态所需国王数，并且判断没一行此状态满不满足左右无相邻，直接右移一维 & 即可。
i - 1 行状态需要的判断核心代码
 if(!st[s]) continue;
if(j & s) continue;上下关系
if((s << 1) & j) continue;//右上角
if((s >> 1) & j) continue;//左上角
for(int l=k;l>=need[j];l--)
	dp[i][j][l] += dp[i - 1][s][l - need[j]];
```

[玉米田](https://www.luogu.com.cn/problem/P1879)

```cpp
dp[i][j]//表示前 i 行，且第 i 行状态为 j 的方案数
//状态压缩 DP 判断状态是否合法非常重要 上一题是判断大小这一题是判断 & 后是否和给定的数据一致
for(int i=0;i<=tot;i++)
{
    if(can[i] && (i & mp[1]) == i)// mp 表示将输入的数据转换为对应的二进制
        dp[1][i] = 1;
}
for(int i=2;i<=n;i++)
{
    for(int j=0;j<=tot;j++)
    {
        if(can[j] && (j & mp[i]) == j)
        {
            for(int s=0;s<=tot;s++)
            {
                if(!(s & j))//两个状态没有上下相邻的
                    dp[i][j] = (dp[i][j] + dp[i - 1][s]) % mod;
            }
        }
    }
}
```

[炮兵阵地](https://www.luogu.com.cn/problem/P2704)

```cpp
//本题主要在于需要减少无用状态计算量，循环层数较多，需要简化，并且需要记录每行合理的状态，dp 时先枚举 i 在 i-2 判断状态合法，在 i-1 判断状态合法
// need 数组的计算和 第一行数据的预处理省略，记住更新操作之前一定要验证状态是否合理 ！！！！！！先遍历本行状态在 i - 2 判断状态，在 i-1 判断状态，在更新！！！！！
for(int i=1;i<=cnt;i++)
{
    if((state[i] & mp[2]) == state[i])
    {
        st[2][i] = 1;
        for(int j=1;j<=cnt;j++)
        {
            if(st[1][j] && ((state[i] & state[j]) == 0))
            {
                dp[2][i][j] = max(dp[2][i][j],dp[1][j][0] + need[i]);
            }
        }
    }
}
for(int i=3;i<=n;i++)
{
    for(int j=1;j<=cnt;j++)
    {
        if((state[j] & mp[i]) == state[j])
        {
            st[i][j] = 1;
            for(int k=1;k<=cnt;k++)
            {
                if(st[i - 2][k] && ((state[j] & state[k]) == 0))
                {
                    for(int l=1;l<=cnt;l++)
                    {
                        if(st[i - 1][l] && ((state[j] & state[l]) == 0) && ((state[k] & state[l]) == 0))
                        {
                            dp[i][j][l] = max(dp[i][j][l],dp[i - 1][l][k] + need[j]);
                        }
                    }
                }
            }
        }
    }
}
```

1. [牛客周赛32F](https://ac.nowcoder.com/acm/contest/75174/F)
   此题不是二进制表示了，有三个状态所以不能直接右移判断是否有合法的操作，需要模拟一个三进制，其余的大题一致，先预处理每一列的合法状态，然后在更新答案前需要判断四个方位是否合理，因为是顺序遍历所以只要和前面的比较即可

```cpp
int g(int i,int st)//状态 st 第 i 位是什么
{
    for(int j=0;j<i;j++) st /= 3;
    return st % 3;
}
int ask(int col,int st)//将 col 转变为 st 需要代价
{
    int cnt = 0;
    for(int i=0;i<n;i++)
    {
        if(g(i,st) != mp[s[i][col - 1]])
            cnt ++;
    }
    return cnt;
}
bool check(int st)//检查 st 是否有左右相同
{
    for(int i=1;i<n;i++)
    {
        if(g(i,st) == g(i - 1,st))
            return 0;
    }
    return  1;
}
bool check(int st1,int st2)
{
    for(int i=0;i<n;i++)
    {
        if(g(i,st1) == g(i,st2))
            return 0;
    }
    return 1;
}
for(int i=0;i<=tot;i++)
{
    if(check(i)) dp[1][i] = ask(1,i);
    else dp[1][i] = 1e9;
}
for(int i=2;i<=m;i++)
{
    for(int j=0;j<=tot;j++)
    {
        dp[i][j] = 1e9;
        if(check(j))
        {
            int cnt = ask(i,j);
            for(int k=0;k<=tot;k++)
            {
                if(check(j,k) && check(k))
                    dp[i][j] = min(dp[i][j],dp[i - 1][k] + cnt);
            }
        }
    }
}
```

### [区间DP](https://www.cnblogs.com/ljy-endl/p/11610549.html)    [习题](https://blog.csdn.net/qq_43472263/article/details/98337401)

区间DP 做法比较固定，`即枚举区间长度，在枚举左端点，之后枚举区间的断点进行转移。 `区间DP在分阶段划分问题时，与阶段中元素出现的顺序和由前一阶段的哪些元素合并而来有很大的关系(例：`f[i][j] = f[i][k] + f[k + 1][j]`
区间类 DP 的特点

- 合并 ：即将两个或多个部分进行整合
- 特征 ： 能将问题分解为两两合并的形式
- 求解 ：对整个问题设最优解，枚举合并点，将问题分解为左右两个部分，最后将左右两个部分的最优值进行合并得到原问题的最优值。
- 环的处理 **破环成链**，长度扩大 2 倍。枚举**每一个起点**表示一个环

```cpp
memset(dp,0,sizeof(dp))//初始dp数组
for(int len=2;len<=n;len++){//枚举区间长度
    for(int i=1;i<n;++i){//枚举区间的起点
        int j=i+len-1;//根据起点和长度得出终点
        if(j>n) break;//符合条件的终点
        for(int k=i;k<=j;++k)//枚举最优分割点
            dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+w[i][j]);//状态转移方程
    }
} 
```

[1：石子合并](https://www.luogu.com.cn/problem/P1880)
无环正解 ： 两个长度较小的区间上的信息向一个更长的区间发生**转移**，划分点 `k` 就是转移的**决策**，区间长度`len`就是 DP 的**阶段**，根据动态规划“选择最小的能覆盖状态空间的维度集合”的思想，可以只用左、右端点表示 DP 的状态。

```cpp
sum[i]//从第 1 堆到第 i 堆石子数总和
fmax[i][j],fmin[i][j]//将从第 i 堆石子合并到第 j 堆石子的最大得分，最小得分
fmax[i][j] = max{famx[i][k]+ fmax[k + 1][j] + sum[j] - sum[i - 1]}
```

**破环成链   从每一个点开始长度为 n 表示一个完整的环，求结果**

```cpp
void solve()
{
    cin >> n;
    pre(i,1,n)
        cin >> a[i],a[i + n] = a[i];//环到链
    pre(i,1,2*n)
        s[i] = s[i - 1] + a[i];
    vector<vector<int>> fi(2 * n + 1,vector<int>(2 * n + 1,inf)),fa(2 * n + 1,vector<int>(2 * n + 1,0));
    pre(i,1,2 * n) fi[i][i] = fa[i][i] = 0;
    for(int l = 2;l <= n;l++)//区间长度
    {
        for(int i=1;i + l - 1 <= 2 * n;i++)//左端点
        {
            int j = i + l - 1;//右端点
            for(int k=i;k<j;k++)
            {
                fi[i][j] = min(fi[i][j],fi[i][k] + fi[k + 1][j]);
                fa[i][j] = max(fa[i][j],fa[i][k] + fa[k + 1][j]);
            }
            fi[i][j] += s[j] - s[i - 1];
            fa[i][j] += s[j] - s[i - 1];
        }
    }
    int mi = inf,mx = 0;
    pre(i,1,n)
        mi = min(mi,fi[i][i + n - 1]),mx = max(mx,fa[i][i + n - 1]);
    cout << mi << endl << mx << endl;
}
```

[2.圆](https://ac.nowcoder.com/acm/contest/75768/D)
循环长度，循环左端点，遍历线段左端点对应的右端点，判断是否在区间内还是不相交区间

```cpp
void solve()
{
    cin >> n >> m;
    vector<vector<array<int,2>>> g(2 * n + 1);
    int s = 0;
    pre(i,1,m)
    {
        int x,y,z;
        cin >> x >> y >> z;
        if(x > y) swap(x,y);
        g[x].push_back({y,z});
        g[y].push_back({x + n,z});
        s += z;
    }
    vector<vector<int>> dp(n * 2 + 2,vector<int> (2 * n + 2,0));
    for(int i=2;i<=n * 2;i++)//区间长度
    {
        for(int l = 1;l + i - 1 <= 2 * n;l++)//区间左端点
        {
            int r = l + i - 1;//右端点
            dp[l][r] = max(dp[l + 1][r],dp[l][r - 1]);
            for(auto L : g[l])
            {
                int u = L[0],w = L[1];
                if(u > r) continue;
                if(u + 1 < r) w += dp[u + 1][r];
                if(u - 1 > l + 1)
                    w += dp[l + 1][u - 1];
                dp[l][r] = max(dp[l][r],w);
            }
        }
    }
    int ans = 0;
    pre(i,1,n)
        ans = max(dp[i][i + n - 1],ans);
    cout << s - ans << endl;
}
```

**在第二层循环内最好加一个自然状态转移**`dp[i][j] = ___(dp[i + 1][j],dp[i][j - 1]`某些情况下不加会导致错误，加上肯定无错误！！！！！！！！！！！


### 换根 DP

换根 DP 的转移在于相邻两个顶点之间，以“树上的做优节点到根节点的距离为例” `dfs`一遍可以求出一点为根的答案，关键在于**转移**，注意到：如果将根节点转移到当前根节点的相邻节点，`dp[b] = dp[a] - size[b] +  n - size[b]`，代表着将  b 节点的子儿子到 a 节点之间的距离减去，属于 a 节点但不属于 b 节点的儿子距离加一，表示到 b 节点

```cpp
void dfs(int u,int fa,int deep)
{
    for(auto L : g[u])
    {
        if(L != fa)
        {
            dfs(L,u,deep + 1);
            s[u] += s[L];
        }
    }
    sum += w[u] * deep;
    s[u] += w[u];
}
int ans ,pp;
void fun(int u,int fa)
{
    ans = min(ans,sum);
    for(auto L : g[u])
    {
        if(L != fa)
        {
            sum -= s[L];
            sum += pp - s[L];
            fun(L,u);
            sum -= pp - s[L];
            sum += s[L];
        }
    }
}
```

[Atc 348 E](https://atcoder.jp/contests/abc348/tasks/abc348_e)

## 字符串

### 子序列与子串

子序列可以不连续，连续子序列、子串是连续的。

### KMP

```c++
//求next过程,这个板子中将字符串下标转换为 从 1 开始,注意
for(int i=2,j=0;i<=n;i++)
{      //需要特别注意i是从1开始计数的，j是从0开始
    while(j && p[i] != p[j+1]) j = ne[j];//未到起始，且匹配失败，回答前缀的结尾，快速匹配
    if(p[i] == p[j+1]) j++;//匹配成功，前缀结尾终点后移
    ne[i] = j;//更新后缀对应的前缀结尾
}
//KMP匹配过程
for(int i=1,j=0;i<=m;i++)// i 遍历s所有数组
{
    while(j && s[i] != p[j+1]) j = ne[j];// j没有退回起点且匹配失败， 下标从 1 开始，0相当于在空着，起来一个判断作业
    if(s[i] == p[j+1]) j++;
    if(j == n)
    {
        //匹配成功
        cout << i-j << " ";//i从1开始i-n即是开始位置
        j = ne[j];//匹配结束，更新最大后缀对应的前缀结尾，快速匹配前一部分字符
    }
}
//KMP 判断字符串是否是由子字符串重复循环构成
if(len%(len-next[len])==0)//len表示字符串 s 的长度,就是字符串第一位到next[len]位与len-next[len]位到第len位是匹配的
	printf("%d\n",len/(len-next[len]));//判断,len-next[len] 即是重复子字符串的长度
```

### Tire树

#### 字符个数

```cpp
int son[N][26],cnt[N],idx=0;//下标是0的点，既是根节点，又是空节点 idx存的是当前用到的节点
char str[N]; //son数组模拟的指针-下标是x的点，x节点的儿子存在son里面，cnt存的是以x结尾的单词数量    
void insert(char str[])
{
	int p = 0;
	for(int i=0;str[i];i++)
	{
		int u = str[i] - 'a';//将字母映射到0~26的数字表示
		if(!son[p][u]) son[p][u] = ++idx;//p节点不存在u这个字母-新建一个节点
		p = son[p][u];//走到下一个节点
	}//次数的!son[p][u]决定了是++idx不是idx++，因为son不应该等于0
	cnt[p]++;//表示以对应的u结尾的单词个数加 1
}
int query(char str[])//查询操作是返回单词出现多少次
{
	int p=0;
	for(int i=0;str[i];i++)
	{
		int u = str[i] - 'a';//将字母转化为对应的子节点的编号
		if(!son[p][u]) return 0; //不存在，表示没有这个单词
		p = son[p][u];
	}
	return cnt[p];//返回单词个数
}
```

#### 最大异或对

```cpp
void insert(int x) {
    int u = 0;
    for (int i = 31; ~i; i--) {
        bool p = x >> i & 1;
        if (!tr[u][p]) tr[u][p] = ++h;
        u = tr[u][p];
    }
}

int query(int x) {
    int u = 0, ret = 0;
    for (int i = 31; ~i; i--) {
        bool p = x >> i & 1;
        if (tr[u][!p]) // 存在取反后的节点
            u = tr[u][!p], (ret <<= 1)++;
        else
            u = tr[u][p], ret <<= 1;
    }
    return ret;
}
```

### 字符串哈希 Hash

> - 自动溢出 ull

```c++
p[0] = 1; // 不要将某个字符串映射为0,所以p[0]初始化为 1,映射的最小值为 1
cin >> n >> m >> str + 1;//n 是字符长度,m 是询问个数,str 是输入字符串,char str[N];
for(int i=1;i<=n;i++)//n 为字符长度
{
    p[i] = p[i-1]*P;// P = 131 或 13331,p,h 数组都是 ull 的数据类型
    h[i] = h[i-1]*P+str[i] - 'A' + 1;//str 是读入的字符串,下标从 1 开始,将字符转换为 1 - 26,减小范围
}
//获取哈希结果
ull get(int l,int r)
{   //公式，相当于将1到l-1这串字符，前移到长度与r对齐，不足补-，这样相减就是l到r的区间哈希
	return h[r] - h[l-1]*p[r-l+1];
}
```

> - 二维哈希 : 取两个 base,
> - 主要用于统计 b矩阵在 a矩阵中的出现次数

```c++
const ULL base1 = 13331;
const ULL base2 = 23333;
ULL p1[N],p2[N];
void pre()
{
    p1[0] = p2[0] = 1;//与一维hash一样,不要将字符串映射为 0,p1,p2[0] = 1;
    for(int i=1;i<N;i++)
        p1[i] = p1[i-1] * base1,//记录乘了多少次base
        p2[i] = p2[i-1] * base2;
}
int T,n1,m1,n2,m2;
char a[N][N],b[N][N];
ULL h[N][N];//h[i][j]表示(1,1,i,j)子矩阵的哈希值,类似与前缀和求子矩阵的和
void init()
{//二维哈希的初始化类似与二维前缀和s[i][j] = s[i][j-1] + s[i-1][j] - s[i-1][j-1] + a[i][j],二维哈希乘于base
    for(int i=1;i<=n1;i++)
        for(int j=1;j<=m1;j++)
            h[i][j] = h[i][j-1] * base2 + h[i-1][j] * base1
                - h[i-1][j-1] * base1 * base2 + (a[i][j] - 'A' + 1);
}//减去的值乘两个base是因为加的时候重叠了,两个base都乘了,所以减去的时候要都乘
ULL get_hash(int x,int y,int lx,int ly)
{//计算子矩阵和,联系一维哈希和二维前缀和的计算,
    return  +h[x+lx-1][y+ly-1]//右下角
            -h[x+lx-1][y-1]*p2[ly]
            -h[x-1][y+ly-1]*p1[lx]//p数组存的是计算前缀和时,乘了多少次base
            +h[x-1][y-1]*p1[lx]*p2[ly];//左上角
}
int main()
{
    pre();
    cin >> T;
    while(T--)
    {
        cin >> n1 >> m1;
        for(int i=1;i<=n1;i++) cin >> a[i] + 1;
        cin >> n2 >> m2;
        for(int i=1;i<=n2;i++) cin >> b[i] + 1;
        init();
        ULL t = 0;
        for(int i=1;i<=n2;i++)
            for(int j=1;j<=m2;j++)
                t += (b[i][j]-'A'+1) * p1[n2-i] * p2[m2-j];//注意下标
        int ans=0;
        for(int i=1;i<=n1-n2+1;i++)
            for(int j=1;j<=m1-m2+1;j++)
                if(get_hash(i,j,n2,m2)==t)//i,j表示起点,求的是大小为n,m的子矩阵,判断是否出现过,所以get里面右下角
                    ans++;       //是[x+la-1][y+ly-1],后面的过程类似于二维矩阵求子矩阵和
        cout << ans << endl;
    }
    return 0;
 
 //如果是一个大的子矩阵求的是若干个小矩阵在这个大矩阵里面有没有出现过,可以  使用二分优化(前提是所有子矩阵的大小一致)
    init();//大矩阵
    for (int i = 1; i <= n - a + 1; i++)
         for (int j = 1; j <= m - b + 1; j++)
              ans[++ct] = get_hash(i, j, a, b);//预处理出来所有的大小为 a * b 的矩阵
     while(q --)
     {
         cin >> str + 1;//处理询问小矩阵
         for(int i=1;i<=a;i++)
         {
             for(int j=1;j<=b;j++)
             {
                 h[i][j] = (ll) h[i][j-1] * base2 + h[i-1][j] * base1
                - h[i-1][j-1] * base1 * base2 + (str[i][j] - 'A' + 1);
             }
         }//binary_search  STL二分,返回值只有0 或 1,不能返回下标,返回类型是bool的
         puts(std::binary_search(ans + 1, ans + ct + 1, h[a][b]) ? "1" : "0");
     }
}
```

- 第二种方法 : 二维哈希先求出每一行的子串,在将行看做点求矩阵哈希

```c++
for (int i = 1; i <= n; ++i)
    for (int j = 1; j <= m; ++j)
    {
        scanf("%d", &x);
        h[i][j] = ((ull)h[i][j - 1] * 131 + x);
    }
//第一步获得每行子串的哈希表
for (int i = 1; i <= n; ++i)
    for (int j = 1; j <= m; ++j)
        h[i][j] = (h[i][j] + (ull)h[i - 1][j] * 233);
//第二步获得子矩阵的哈希值
```

> - 双哈希,一般不使用自动溢出即是 ull 类型,会被卡,手动取模,双哈希本质上就是两遍一维哈希,不再使用自动溢出

```c++
const ULL MOD1 = 402653189;
const ULL MOD2 = 805306457;
const ULL BASE1 = 13331;
const ULL BASE2 = 23333;
//备用 模数&base
//const ULL MOD1 = 1610612741;
//const ULL MOD2 = 1222827239;
//const ULL BASE1 = 1331;
//const ULL BASE2 = 131;
ULL p[N][2];
void init()
{
    p[0][0] = p[0][1] = 1;//字符串不映射到 0 
    for(int i=1;i<N;i++) p[i][0] = p[i-1][0] * BASE1 % MOD1;
    for(int i=1;i<N;i++) p[i][1] = p[i-1][1] * BASE2 % MOD2;
}//如果字符串长度确定,for 循环不必循环到N,循环到字符串的长度即可
struct myHash
{
    ULL h[N][2];
    void init(char s[],int n = 0)
    {555
        n = strlen(s),h[n][0] = h[n][1] = 0;
        for(int i=1;i<=n;i++)//两遍hash
            h[i][0] = (h[i-1][0] * BASE1 % MOD1 + s[i] - 'A' + 1) % MOD1;
        for(int i=1;i<=n;i++) 
            h[i][1] = (h[i-1][1] * BASE2 % MOD2 + s[i] - 'A' + 1) % MOD2;
    }
    upr get_hash(int pos,int length)//r=pos,l = l + length +1,
    {//返回哈希的结果,和一维哈希计算结果一样,只是两种哈希模数和基数
        return {
            ((h[pos][0] - h[pos-length][0] * p[length][0] % MOD1) + MOD1) % MOD1,
            ((h[pos][1] - h[pos-length][1] * p[lengt h][1] % MOD2) + MOD2) % MOD2
        };
    }
};
upr make_hash(char s[])
{
    int n = strlen(s);
    upr ans;
    for(int i=n-1;i>=0;i--)
    {
        ans.fi = (ans.fi * BASE1 % MOD1 + s[i] - 'A' + 1) % MOD1;
        ans.se = (ans.se * BASE2 % MOD2 + s[i] - 'A' + 1) % MOD2;
    }
    return ans;
}
```

### manacher算法求最大回文串

- 直接暴力复杂度较高,从中间向两边扩展不能确定对称中心是在字符上还是字符中间,所以采用每两个字符加入一个字符例如' #',将所有的字符对称中心转换到符号 '#' 上,结尾 0 和开头使用不同的字符防止匹配上越界

```c++
string str,s;
int dp[N];
void solve()
{
    cin >> str;
    int n = str.size();
    s += ' ';//防止越界
    for(int i=0;i<n;i++)
    {
        s += '#';//没两个字符中间加上一个辅助字符,强制将对称中心转到字符上,而不是字符中间
        s += str[i];
    }
    s += '#';
    s += '!';//最后再加一个!,防止和开头匹配上导致越界
    int pos = 0,r = 0;//pos是中点,r是回文字符串的最右端点,pos是r对应的中点 
    n = s.size();
    for(int i=1;i<n;i++)//pos < i
    {
        if(i < r)//求最右端点,与左端点对称的点和,这段区间已经匹配上了
            dp[i] = min(dp[(pos<<1)-i],r - i);
        else dp[i] = 1;
        while(s[i-dp[i]] == s[i + dp[i]])//因为终点的字符是独特的,所以不用担心越界问题,结尾一定匹配不上
            dp[i] ++;//如果两边的字符能匹配上,dp数组可以匹配的长度加 1 
        if(i + dp[i] > r)//匹配的长度大于最大右端点了,更新右端点
            r = i + dp[i],pos = i;//更新右端点和中点
    }
    int ans = 0;
    for(int i=1;i<=n;i++)
        ans = max(ans,dp[i] - 1);//找最长回文
    cout << ans << endl;
}//每个答案减一是因为dp代表的含义是一边但是算上的有#,所以是最大回文,但是结束的时候一定是#,多计算了一个#
```

### Z 函数(扩展KMP)

对于一个字符串 S 我们规定一个函数 Z[i] 表示 S 与 S[i...n−1] 的 LCP（最长公共前缀）的长度。即 S[0.....Z[i]−1] 与 S[i...i+Z[i]−1] 相等

```cpp
vector<int> z_function()
{
    vector<int> z(n);
    z[0] = n;
    for (int i = 1, l = 0, r = 0; i < n; ++i)
    {
        if (i <= r && z[i - l] < r - i + 1)
            z[i] = z[i - l];
        else
        {
            z[i] = std::max(0, r - i + 1);
            while (i + z[i] < n && s[z[i]] == s[i + z[i]])
                ++z[i];
        }
        if (i + z[i] - 1 > r)
            l = i, r = i + z[i] - 1;
    }
    return z;
}
```

```cpp
 for (int i = 2, l, r = 0; i <= n; i++)// t 函数的 lcp  --- 自匹过程
 {
     if (i <= r)
         z[i] = min(r - i + 1, z[i - l + 1]);
     while (t[1 + z[i]] == t[i + z[i]])
         z[i]++;
     if (i + z[i] - 1 > r)
         l = i, r = i + z[i] - 1;
 }
for (int i = 1, l, r = 0; i <= n; i++)// 两者相匹过程,t 和 s 的 lcp p数组
{
    if (i <= r)
        p[i] = min(r - i + 1, z[i - l + 1]);
    while (1 + p[i] <= n && i + p[i] <= n && t[1 + p[i]] == s[i + p[i]])
        p[i]++;
    if (i + p[i] - 1 > r)
        l = i, r = i + p[i] - 1;
}
//两个过程的起始位置是不一样的,两个数组应处的位置不要混淆
```

[牛客周赛 56 F](./solution/newcodeweek56.md)

#### 求 A 在 B 中出现的次数

将  "A#" 加到 B 前面，判断有多少位置 `Z[i] = len(A)`

#### 判断循环节

对于字符串 S 和 0 < p <= |S|，若 S[i] = S[i + p]，对于所有的 [0,|S| - p - 1]中的所有 i 都成立，则称 p 为 S 的周期

对字符串 S 和 0≤ r<|S|，若 S 长度为 r 的前缀 和 长度为 r 的后缀相等，则称长度为r 的前缀为 S 的 border。

如果转化为 Z 函数的话，就是 `i+Z[i]==len` 就是 i 的后缀为 S 的一个``Border`，有一个长度为 Z[i] 的 border  等价于有一个长度为 `len−Z[i]`的周期。（证明略过）

那么我们可以 O(n) 的扫，如果当前`i+Z[i]==len` 那么判断 `len%(len−Z[i])` 是否等于 0 。因为满足` i+Z[i]=len `的` len−Z[i]` 是递减的（因为 i 枚举时递增。）所以第一个满足上述条件的 `len−Z[i]`就是最大的循环节，要找最小的可以直接倒叙枚举，然后第一个直接退出。

#### 求将一个字符串分为 k 段的最长 LCP(公共前缀)

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 10;
int ans[N],res[N],n;
string s;
vector<int> v[N];
vector<int> z_function()
{
    vector<int> z(n);
    z[0] = n;
    for (int i = 1, l = 0, r = 0; i < n; ++i)
    {
        if (i <= r && z[i - l] < r - i + 1)
            z[i] = z[i - l];
        else
        {
            z[i] = max(0, r - i + 1);
            while (i + z[i] < n && s[z[i]] == s[i + z[i]])
                ++z[i];
        }
        if (i + z[i] - 1 > r)
            l = i, r = i + z[i] - 1;
    }
    return z;
}
void solve()
{
    int l, r;
    cin >> n >> l >> r >> s;
    auto z = z_function(); // Z 函数表示 S[i] 与 [i ... n - 1]之间的最大 LCP(公共前缀)
    for (int i = 0; i <= n; i++)
        v[i].clear(), ans[i] = 0, res[i] = 0;
    for (int i = 0; i < n; i++)
        v[z[i]].push_back(i);
    ans[0] = n;
    set<int> st;
    for (int i = n; i >= 1; i--)
    {
        for (auto it : v[i]) // LCP 为 i 的位置
            st.insert(it);
        int cnt = 1, now = 0;
        while (1)
        {
            auto it = st.lower_bound(now + i); // 跳过当前匹配的部分，且跳过的最小，找剩下的满足 LCP 的分割点
            if (it == st.end())
                break;
            cnt++;
            now = *it;
        }
        ans[i] = cnt; // LCP长度为i的有cnt段
    }
    int len = n;
    for (int i = l; i <= r; i++)
    {
        while (ans[len] < i) // LCP 是满足单调性的，较长的能满足，段的部分一定也能满足，反之当前不能满足，长的部分也一定不能满足
            len --;//所以区间从小到大枚举，长度从大到小枚举。
        cout << len << ' ';
    }
    cout << '\n';
}
```

### AC 自动机

判断询问字符串是否在给定字符串中出现过

判断匹配串是否出现在被匹配中，即是给定一个字符串，给定询问字符串判断是否在该字符串中出现过，如果是判断该字符串是否在给定字符串中出现过使用`hash`暴力匹配   `s 是被匹配串  ，s1 是询问串` **被匹配串不需要插入到AC自动中，将询问串依次插入到AC自动机中**, `sa[now].ans[i]` 即是在当前此次 T 中询问的每个字符串是否在被匹配串中出现过。`先 build()，在solve()`

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e5 + 10, mod = 998244353, INF = 1e18;
const int base = 1331, hashmod = 1610612741;
int n;
struct sam
{
    typedef struct node
    {
        int son[26], fail;
        int &operator[](int x) { return son[x]; }
    } node;
    node t[N];
    int tot, q[N], head, tail, d[N], ans[N], hd[N], nxt[N]; // hd存储的是当前插入的字符串映射到字典树中的tot
    char s[N];
    char s1[N];
    void insert(char *s, int id) // 初始化字典树
    {
        int cur = 0, len = strlen(s);
        for (int i = 0; i < len; i++)
        {
            if (!t[cur][s[i] - 'a'])
                t[cur][s[i] - 'a'] = ++tot;
            cur = t[cur][s[i] - 'a'];
        }
        nxt[id] = hd[cur]; // id 从后向前匹配的，后一个字符串的前一个的信息
        hd[cur] = id;      // 将询问的顺序映射到 hd 里面
    }
    void build() // 创建当前点匹配失败 转移 到的 fail 指针指向的位置
    {
        head = 1;
        tail = 0;
        for (int i = 0; i < 26; i++)
            if (t[0][i])
                q[++tail] = t[0][i];
        while (head <= tail)
        {
            int x = q[head++];
            for (int i = 0; i < 26; i++)
            {
                if (t[x][i])
                    t[t[x][i]].fail = t[t[x].fail][i], q[++tail] = t[x][i];
                else
                    t[x][i] = t[t[x].fail][i];
            }
        }
    }
    void solve() // 判断字符串出现多少次
    {
        int cur = 0, len = strlen(s);
        for (int i = 0; i < len; i++)
        {
            cur = t[cur][s[i] - 'a'];
            d[cur]++;
        }
        for (int i = tot; i >= 1; i--)
        {
            for (int j = hd[q[i]]; j; j = nxt[j])
                ans[j] = d[q[i]]; // 当前字母出现多少次
            d[t[q[i]].fail] += d[q[i]];
        }
    }
} sa[12]; // 多少个AC自动机，通常是和 T 相关的
char b[N];
bool f1[N];
int ha[N];
int p[N];
int get(int l, int r)
{
    return ((ha[r] - ha[l - 1] * p[r - l + 1] % hashmod) % hashmod + hashmod) % hashmod;
}
int now = 0; // AC自动机的序号，T
void solve()
{
    cin >> n;
    now++;
    cin >> sa[now].s;
    string c;
    cin >> c;
    int m = c.length();
    c = " " + c;
    int h = 0;
    for (int i = 1; i <= m; i++)
    {
        h = h * base % hashmod + c[i];
        h %= hashmod;
    }
    for (int i = 1; i <= n; i++)
    {
        cin >> sa[now].s1;
        sa[now].insert(sa[now].s1, i); // 将 A 放进 AC自动机中判断出现个数
        string st;
        cin >> st; // B 字符串先通过hash筛除一部分通常情况下是模式串是给定的，需要判断该串是否在询问中出现
        int len = st.length();
        st = " " + st;
        bool flag = 0;
        ha[0] = 0; // hash 先判断 B 的情况，筛除一部分字符串
        for (int j = 1; j <= len; j++)
        {
            ha[j] = ha[j - 1] * base % hashmod + st[j];
            ha[j] %= hashmod;
            if (j >= m)
            {
                if (get(j - m + 1, j) == h)
                {
                    flag = 1;
                    break;
                }
            }
        }
        f1[i] = flag;
    }
    sa[now].build();
    sa[now].solve();
    for (int i = 1; i <= n; i++)
    {
        if (sa[now].ans[i] && f1[i]) // 在AC自动机中出现的次数不止一个，且hash通过
            cout << i << " ";
    }
    cout << '\n';
}
signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t = 1;
    cin >> t;
    p[0] = 1;
    for (int i = 1; i < N; i++)
        p[i] = p[i - 1] * base % hashmod;
    while (t--)
    {
        solve();
    }
}
```

### 后缀数组

- 学习掌握 SA
- 解决 LCP 问题（最长公共前缀）

约定 ： 字符串下标从 `1`开始，长度为`n`，“`后缀 i`”代指以第 `i`个字符开头的后缀，存储时用`i`代表字符串 s 的后缀 `s[i...n]`。

- 需要的数组介绍

```cpp
sa[i]//表示将所有后缀排序后第 i 小的后缀的编号，也就是后缀数组，编号数组
rk[i]//表示后缀 i 的排名，是重要的辅助数组，后文也称排名数组 rk   按照 LCP 的长度排序的
```

- 性质 ：

`sa[rk[i]] = rk[sa[i]] = i`
![后缀数组解释](./../Images/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E8%A7%A3%E9%87%8A.png)

#### 求后缀数组

##### 暴力做法    $O(n^2logn)$

直接暴力`sort`的做法，枚举每一种后缀数组。

##### 倍增做法     $O(nlog^2n)$

首先对字符串`s`的所有长度为 1 的子串进行排序，得到排序后的编号数组$sa_1 和排名数组 rk_1$。

倍增过程

​	1.用两个长度为 1 的子串的排名，即 $rk_1[i] 和 rk_1[i + 1] $ ，作为排序的第一第二关键字，就可以对字符串 ![s](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 的每个长度为 2 的子串：{s[i...min(i + 1,n)] | $i\in[1,n] $}![\{s[i\dots \min(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)]\ |\ i \in [1,\ n]\}](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 进行排序，得到 $sa_2 和 rk_2$；

​	2.用两个长度为 `w` 的子串的排名，即 $rk_1[i] 和 rk_1[i + w / 2] $ ，作为排序的第一第二关键字，就可以对字符串 ![s](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 的每个长度为`w`的子串：{s[i...min(i + w - 1,n)] | $i\in[1,n] $}![\{s[i\dots \min(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)]\ |\ i \in [1,\ n]\}](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 进行排序，得到 $sa_w 和 rk_w$；其中当`i + w > n时`,$kr_w[i + w]视为无穷小$；

   $rk_w[i]即是子串s[i...i+w-1]的排名，这样当 w\geqslant n时，得到的编号数组sa_w，就是需要的后缀数组$

![后缀数组倍增算法](./../Images/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%80%8D%E5%A2%9E%E7%AE%97%E6%B3%95.png)

```cpp
int n,w,sa[N],rk[N << 1],oldrk[N << 1];//为了防止rk[i + w]越界，开两倍数组
string s;
inline bool cmp(int x,int y,int w)//第x，y个后缀数组，w表示拼接长度
{
    return (rk[x] != rk[y] ? (rk[x + w] < rk[y + w]) : (rk[x] < rk[y]));
}
void solve()
{
    cin >> s;
    n = s.size();s = " " + s;
    for(int i=1;i<=n;i++)
        sa[i] = i,rk[i] = s[i];
    for(w = 1,w < n;w <<= 1)
    {
        sort(sa + 1, sa + n + 1, [](int x, int y) {
      return rk[x] == rk[y] ? rk[x + w] < rk[y + w] : rk[x] < rk[y];
    });  // 这里用到了 lambda,因为cmp中有额外的参数 w，不会传入直接使用lambda
        memcpy(oldrk,rk,sizeof(rk));//由于计算 rk 时原来的 rk 会被覆盖，先复制
        for(int p=0,i=1;i<=n;i++)
        {
            if(oldrk[sa[i]] == oldrk[sa[i - 1]] && oldrk[sa[i] + w] == oldrk[sa[i - 1] + w])
                	rk[sa[i]] = p;
           else rk[sa[i]] = ++p;//若两个子串相同，对应的 rk 也应相同，去重
        }
    }
    for(int i=1;i<=n;i++)
        	cout << sa[i] << " \n"[i == n];
}
```

## 数学

E(x + y) = E(x) + E(y) ，无论`x`和`y`是否存在一些互斥或者其他关系影响，这个公式都是满足的，**和的期望等于期望的和！！！！**

### 素数筛法

#### 欧拉筛  $O(n*\sqrt{n})$

```cpp
bool a[100001]={1,1};//i=0,i=1的时候都不是质数 ，所以直接标记
int b[100001];//存质数
int k;
void init(){
    for(int i=2;i<=100001;i++)//这个意思是在100001里面找到质数并且标记 ，质数最小是2，所以i=2 
	{
		if (a[i]==0)	b[++k]=i;	//如果没有被标记为1，就是质数。我接下来会讲解为什么是质数。 
		for(int j=1;j<=k;j++)// //j小于当前所有的质数的个数
		{
			if(i*b[j]>100001)break;// 如果超出给出的范围，那么就退出循环 
			a[i*b[j]]=1;//用质数数依次×i，结果标记为合数（也就是标记为1）。 
			if(i%b[j]==0)break;//最关键的只标记一次 
		}	
	}
}//如果没有被标记为1，就是质数，直接输出。 
```

#### 埃氏筛  `O(nlgn)`

```cpp
int sieve(int n)
{
 	p = 0;
	for(int i=0;i<=n;i++)
		is_prime[i]=true;       // 所有数先标记为true
    is_prime[0] = is_prime[1] = false;   // 把数字0，1标记为质数
    for(int i=2;i<=n;i++)
    {
       	if(is_prime[i])         // 如果这个数没有被标记为false
    	{
             prime[p++]=i;       // 用prime数组存起来这个数，既存起了质数，又用p表示了质数个数
             for(int j=i*i;j<=n;j+=i)   // 这里没有优化时的写法是for(int j=2*i; j<=n; j++)。
	    	//因为小于j(即i^2)内的合数都因为(根号j)(即i)内有更小的j的的因数而被排除
    							// 比如3^2 = 9，为什么不算2*3 = 6呢， 因为6<9,所以6因为3以内有更小的因数而直接被排除
    				is_prime[j]=false;
        }
    }
    return p;          // 返回质数个数
}
```

#### 大数因数分解 $O(n^{1/4})$ 

将一个大数分解为若干质因子次幂的积的形式 . 

```cpp
int mul(int a, int b, int m)
{
	return static_cast<__int128>(a) * b % m;
}
int power(int a, int b, int m)
{
	int res = 1 % m;
	for (; b; b >>= 1, a = mul(a, a, m))
		if (b & 1)
			res = mul(res, a, m);
	return res;
}
bool isprime(int n)
{
	if (n < 2)
		return false;
	static constexpr int A[] = {2, 3, 5, 7, 11, 13, 17, 19, 23};
	int s = __builtin_ctzll(n - 1);
	int d = (n - 1) >> s;
	for (auto a : A)
	{
		if (a == n)
			return true;
		int x = power(a, d, n);
		if (x == 1 || x == n - 1)
			continue;
		bool ok = false;
		for (int i = 0; i < s - 1; ++i)
		{
			x = mul(x, x, n);
			if (x == n - 1)
			{
				ok = true;
				break;
			}
		}
		if (!ok)
			return false;
	}
	return true;
}
vector<int> factorize(int n)
{
	vector<int> p;
	function<void(int)> f = [&](int n)
	{
		if (n <= 10000)
		{
			for (int i = 2; i * i <= n; ++i)
				for (; n % i == 0; n /= i)
					p.push_back(i);
			if (n > 1)
				p.push_back(n);
			return;
		}
		if (isprime(n))
		{
			p.push_back(n);
			return;
		}
		auto g = [&](int x)
		{
			return (mul(x, x, n) + 1) % n;
		};
		int x0 = 2;
		while (true)
		{
			int x = x0;
			int y = x0;
			int d = 1;
			int power = 1, lam = 0;
			int v = 1;
			while (d == 1)
			{
				y = g(y);
				++lam;
				v = mul(v, abs(x - y), n);
				if (lam % 127 == 0)
				{
					d = gcd(v, n);
					v = 1;
				}
				if (power == lam)
				{
					x = y;
					power *= 2;
					lam = 0;
					d = gcd(v, n);
					v = 1;
				}
			}
			if (d != n)
			{
				f(d);
				f(n / d);
				return;
			}
			++x0;
		}
	};
	f(n);
	sort(p.begin(), p.end());
	return p;
}
//使用时 
vector<int> ve = factorize();//填入分解数据
```

### 给定 n 个数,求任意数据积

```cpp
set<int> s;//将所有可能的积存到 set 里面
s.insert(1);//通过这个 1 实现任意个组合相乘的结果
for(auto L : ve)//存储原来的 n 个数据,选定任意个组合相乘
{
    set<int> tmp;
    for(auto x : s)
        tmp.insert(L * x);			
    for(auto x : tmp)	s.insert(x);
}
```

### 约数个数

- $对于一个大于1的正整数n可以分解质因数\mathbf{n}=\prod_{\mathrm{i=1}}^{\mathrm{k}}\mathbf{p}_{\mathrm{i}}^{\alpha_{\mathrm{i}}}\ =\mathbf{p}_{\mathrm{I}}^{\mathrm{a_{1}}}\ *\mathbf{p}_{\mathrm{2}}^{\mathrm{a_{2}}}\cdots\mathbf{p}_{\mathrm{k}}^{\mathrm{a_{k}}},则约数的个数为{\mathfrak{f}}({\mathfrak{n}})=\prod_{i=1}^{{\mathfrak{k}}}{\big(}a_{i}+1{\big)}=(a_{1}+1){\big(}a_{2}+1{\big)}\cdot\cdot\cdot{\big(}a_{\mathbf{k}}+1{\big)},$

$其中\alpha_{1},\alpha_{2}\cdots是P_{1},P_{2}\cdots P_{k}的指数   $

```cpp
unordered_map<int,int> primes;//哈希表,存素数,将大值映射为小值
while(n--)
{
    int x;
    cin >> x;
    for(int i=2;i<=x/i;i++)//试除法判断这个数的质因子有什么,存入primes里面
        while(x % i ==  0)
        {
            x /= i;
            primes[i] ++;//存质因子个数2
        }
    if(x > 1) primes[x] ++;//这个约数较大超过了sqrt(x) 
}
ll res = 1;
for(auto prime : primes) res = res * (prime.second + 1) % mod;//计算约数个数
```

### 约束求和

- $对于一个大于1的正整数n可以分解质因数\mathbf{n}=\prod_{\mathrm{i=1}}^{\mathrm{k}}\mathbf{p}_{\mathrm{i}}^{\alpha_{\mathrm{i}}}\ =\mathbf{p}_{\mathrm{I}}^{\mathrm{a_{1}}}\ *\mathbf{p}_{\mathrm{2}}^{\mathrm{a_{2}}}\cdots\mathbf{p}_{\mathrm{k}}^{\mathrm{a_{k}}},则约数之和sum等于$
- $sum = ((P_{1}^0+P_{1}^1+P_{1}^2\cdots+P_{1}^{a_{1}}) * (P_{2}^0+P_{2}^1+P_{2}^2\cdots+P_{2}^{a_{2}}) * \cdots * (P_{k}^0+P_{k}^1+P_{k}^2\cdots+P_{k}^{a_{k}}))$

```cpp
unordered_map<int,int> primes;//哈希表
while(n--)
{
    int x;
    cin >> x;
    for(int i=2;i<=x/i;i++)
        while(x%i==0)
        {
            x /= i;
            primes[i]++;//存质因子个数
        }
    if(x > 1) primes[x]++;//这个约数较大超过了sqrt(x) 
}
ll res = 1;
for(auto prime : primes)
{	
    int p = prime.first,a = prime.second;
    ll t = 1;
    while(a--)
        t = (t * p + 1) % mod;//求得是对于每一个质因子的部分和
    res = res * t % mod;//结果是所有部分和 t 的乘积.
}	
```

### 组合数

#### 杨辉三角(迭代法) -- 小数据

```cpp
void init()
{
    for(int i = 0; i < N; i ++ )
        for(int j = 0; j <= i; j ++ )
            if(!j) c[i][j] = 1;
            else c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod;
}
```

#### 阶乘逆元法 -- 大数据

```cpp
auto qmi = [=](int a,int b) -> int
{
    int res = 1;
    while(b)
    {
        if(b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
};
//预处理阶乘和阶乘的逆元
fact[0] = infact[0] = 1;
for(int i = 1; i < N; i ++)
{
    fact[i] = (LL)fact[i - 1] * i % mod;
    infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod; //这里是关键，把组合数的公式转化为乘法形式
}
int C(int a,int b)
{
    if(a < b || b < 0) return 0;
    return fact[a] * infact[a - b] % mod * infact[b] % mod;
}
```

#### 卢卡斯定理 -- 超大数据，不开数组

```cpp
LL qmi(LL a,int k, int p)
{
    LL res = 1;
    while(k)
    {
        if(k & 1) res = res * a % p;
        k >>= 1;
        a = a * a % p;
    }
    return res;
}
int C(int a,int b,int p)
{
    if(a < b || b < 0) return 0;
    LL res = 1;
    for(int i = 1, j = a; i <= b; i ++ , j -- )
    {
        res = res * j % p;
        res = res * qmi(i, p - 2, p) % p;
    }
    return res;
}
LL lucas(LL a, LL b, int p)
{
    if(a < p && b < p) return C(a, b, p);
    return C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;
}
cout << lusas(a,b,p) << endl;
```

##### 组合数为奇数

由卢卡斯定理可知 `C(a,b)` 为奇数 当且仅当 `b` 的二进制表示的 1 只能出现在 `a` 的二进制表示中出现 1 的位置上（换句话说，`b` 必须是 `a` 的二进制子集）。

```cpp
// 求出 满足 b[i] <= c[i] 并且 C(a[i],b[i]) 是奇数的所有组合
int n, a[N], c[N];
int pre[40];
void solve()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    for (int i = 1; i <= n; i++)
        cin >> c[i], c[i] = min(c[i], a[i]); // 最大的有意义的数才到a[i]
    int ans = 1;
    for (int i = 1; i <= n; i++)
    {
        int tp = 0;
        pre[0] = 1 << (a[i] & 1);
        for (int j = 1; j <= 32; j++)
            pre[j] = (pre[j - 1] << ((a[i] >> j) & 1)) % mod;
        for (int j = 32; j >= 0; j--)
        {
            if ((c[i] >> j) & 1)
            {
                if ((a[i] >> j & 1)) // c[i]  a[i] 在当前位 均为 1
                {
                    if (j == 0) // 如果当前是最后一位此时满足 <= c[i]
                        tp = (tp + pre[0]) % mod;
                    else
                        tp = (tp + pre[j - 1]) % mod; // 当前不是最后一位 注意需要满足 <= c[i] 所以本位取0 此时一定可以满足 继续判断后续
                }
                else // 如果 a[i] 当前位为 0 此时一定满足小于 c[i] 直接计算剩下的 j 位的总和即可
                {
                    tp = (tp + pre[j]) % mod;
                    break;
                }
            }
            else if (j == 0) // c[i] 此位是 0 但是是最后一位 需要加 1
                tp = (tp + 1) % mod;
        }
        ans = ans * tp % mod;
    }
    cout << ans << endl;
}
```

### 欧几里得

```cpp
int gcd(int a,int b)
{
    return b>0 ? gcd(b,a%b):a;
}
int lcm(int a,int b)
{
   return a/gcd(a,b)*b;
}
```

### 扩展欧几里得

```cpp
int exgcd(int a,int b,int &x,int &y)//扩展欧几里得算法
{
    if(b==0)
    {
        x=1;y=0;
        return a;  //到达递归边界开始向上一层返回
    }
    int r=exgcd(b,a%b,x,y);
    int temp=y;    //把x y变成上一层的
    y=x-(a/b)*y;
    x=temp;
    return r;     //得到a b的最大公因数
}
inline int inv (int a) //求逆元:a*inv_a≡1(mod p)
{
	int inv_a, y;
	ex_gcd (a, p, inv_a, y); //公式推导：令p=b,inv_a(a的逆元)=x
	return (inv_a % p + p) % p;
}

```

部分题可能有负数,模数和结果都可能是负数,如果要求的是最小正整数解,模数一定要取绝对值  ( x % abs(mod) + abs(mod) ) % abs(mod)

### 逆元

#### 扩展欧几里得法 `O(lgn)`

```cpp
LL exgcd(LL a,LL b,LL &x,LL &y)//扩展欧几里得算法 
{
	if(b==0)
	{
		x=1,y=0;
		return a;
	}
	LL ret=exgcd(b,a%b,y,x);
	y-=a/b*x;
	return ret;
}
LL getInv(int a,int mod)//求a在mod下的逆元，不存在逆元返回-1 
{
	LL x,y;
	LL d=exgcd(a,mod,x,y);
	return d==1?(x%mod+mod)%mod:-1;
}

```

#### 费马小定理 -  `P为质数 lgmod`

```cpp
ll qmi(int a,int b)
{
    ll res = 1;
    while(b)
    {
        if(b & 1) res = (ll)res * a % mod;
        a = (ll)a * a % mod;
        b >>= 1;
    }
    return res;
}
LL getInv(LL a,LL mod)
{
	return qmi(a,mod-2);
}
```

#### 递推法求逆元

```cpp
LL inv[mod+5];
void getInv(LL mod)
{
	inv[1] = 1;//初始化
	for(int i=2;i<mod;i++)
		inv[i] = (mod - mod / i) * inv[mod % i] % mod;//加上的mod保证求出来的逆元都是最小正整数.
}
LL inv(LL i)
{
	if(i == 1) return 1;
	return (mod - mod / i) * inv(mod % i) % mod;
}

```

### 扩展中国剩余定义

```cpp
//差距在于大范围，会爆 long long ,所以使用__int128接受一下结果计算后再转换为long long,__int128没有输入和输出的函数
#include <bits/stdc++.h>
using namespace std;
typedef __int128 ll;
const int N = 1e5 + 10;
ll x, y, d; int n;

void exgcd(ll &x, ll &y, ll a, ll b) 
{
    if(!b) d = a, x = 1, y = 0;
    else exgcd(y, x, b, a % b), y -= a / b * x;
}

ll lcm(ll a, ll b) 
{
    return a / __gcd(a, b) * b;
}
__int128 A1, b, A2, B;

void merge() 
{
    exgcd(x, y, A1, A2);
    ll c = B - b;
    if(c % d) puts("-1"), exit(0);
    x = x * c / d % (A2 / d);//x * c / d是代表当前值的解，通解是x = x0 + a2 / d,所以最小解就是 % 
    if(x < 0) x += A2 / d;
    ll mod = lcm(A1, A2);//下一步需要将A1变为A1和A2的最小公倍数
    b = (A1 * x + b) % mod; // x = a1*x+b + k*[a1,a2]，[]是最小公倍数 -> x = x0 + ka
    if(b < 0) b += mod;
    A1 = mod;//a1 a2的最小公倍数      //上式 x0即是更新后的m ，a即是更新后的a1
    
}
int main() {
    cin >> n;
    for(int i = 1 ; i <= n ; ++ i) 
    {
        long long _A, _B;
        cin>>_A>>_B, A2 = _A, B = _B;
        if(i > 1) merge();
        else A1 = A2, b = B;
    }
    printf("%lld\n", (long long)(b % A1));
	return 0;
}
//// x mod ai = mi, x = k1 * a1 + m1 , 通解 : k1 = k1 + k * a2 / d ,
/*表达整数的奇怪方式 X 同余与 mi (mod ai) 求最小X*/  
//  x = k1*a1+m1        k = k1 + k * a2 / d 通解，代入  
#include <iostream>  
using namespace std;  
#define ll long long  
  
ll exgcd(ll a,ll b,ll &x,ll&y)//x y加引用是因为后续要传回主函数中  
{  
    if(!b)  
    {  
        x = 1,y = 0;  
        return a;  
    }  
    ll d = exgcd(b,a % b,y,x);  
    y -= a / b * x;  
    return d;  
}  
  
int main()  
{  
    int n;  
    cin >> n;  
    bool has_answer = true;//判断是否有解  
    ll a1,m1;  
    cin >> a1 >> m1;  
    for(int i=0;i<n-1;i++)  
    {//不断求解 k1a1 - kiai = mi - m1的系数k1  ki  
        ll a2,m2;  
        cin >> a2 >> m2;  
        ll k1,k2;  
        ll d = exgcd(a1,a2,k1,k2);//exgcd求系数  
        if((m2 - m1) % d)//判断是否有解，斐蜀定理-有解一定是最大公约数的倍数  
        {//取余结果不是0证明不是倍数，无解             
            has_answer = false;  
            break;  
        }  
        k1 *= (m2 - m1) / d;//此时求得解是为d是对应的解  
        ll t = a2 / d;    //保证k变得足够小，最小正整数解 k = k1 + a2 / d  通解  
        k1 =  (k1 % t + t) % t;//将k1变为最小的正整数解，防止溢出，所以变成最小的就是 % 一下  
        m1 = a1 * k1 + m1;   // x = a1*k1+m1 + k*[a1,a2]，[]是最小公倍数 -> x = x0 + ka  
        a1 = abs(a1 / d * a2);//a1 a2的最小公倍数      //上式 x0即是更新后的m ，a即是更新后的a1  
      }//防止负数的干扰，输出符合条件的最小的正整数解  
    //最终化为一个式子 x = ka1 + m1 解即是 m1 % a1 + a1 ) % a1     
    if(has_answer) cout << (m1 % a1 + a1) % a1 << endl;  
    else puts("-1"); 
}
```

### 矩阵乘法操作类

```cpp
const int MAX_MAT = 2, mod = 1e9 + 7;;
i64 ksm(i64 a, i64 b) {
    i64 res = 1;
    while(b) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }

    return res;
}
struct Mat{
	int n,m;
	i64 a[MAX_MAT][MAX_MAT];//当前矩阵
	i64 A[MAX_MAT][MAX_MAT << 1];//求逆矩阵需要用到的东西
	Mat()
    {
        for (int i = 0; i < MAX_MAT; ++i)
        {
            for (int j = 0; j < MAX_MAT; ++j)
            {
                a[i][j] = 0;
            }
        }
        for (int i = 0; i < MAX_MAT; ++i)
        {
            a[i][i] = 1;
        }
    }//初始化为单位矩阵
    Mat(i64 a1, i64 a2, i64 a3, i64 a4)
    {
        a[0][0] = a1;
        a[0][1] = a2;
        a[1][0] = a3;
        a[1][1] = a4;
    }//这个应题目要求这样写比较简便
    Mat operator *(const Mat &y) const
    {
        Mat c;
        for (int i = 0; i < MAX_MAT; ++i) {
            for (int j = 0; j < MAX_MAT; ++j) {
                c.a[i][j] = 0;
            }
        }
        for (int i = 0; i < MAX_MAT; ++i) {
            for (int j = 0; j < MAX_MAT; ++j) {
                for (int k = 0; k < MAX_MAT; ++k) {
                    c.a[i][j] = (c.a[i][j] + a[i][k] * y.a[k][j] % mod) % mod;
                }
            }
        }
        return c;
    }//矩阵乘法
    Mat add (Mat a, Mat b) {
        for (int i = 0; i < a.n; i++) {
            for (int j = 0; j < a.m; j++) {
                a.a[i][j] += b.a[i][j];
            }
        }
        return a;
    }//矩阵加法
    Mat mul_num (Mat a, int b){
        for(int i = 0; i < a.n; i++) {
            for (int j = 0; j < a.m; j++) {
                a.a[i][j] *= b;
            }
        }
        return a;
    }//矩阵数乘运算
    Mat mpow (Mat a, int n){
        Mat res;
        for(int i = 0; i < res.n; i++) res.a[i][i] = 1;
        while (n) {
            if(n & 1) res = res * a;
            a = a * a;
            n >>= 1;
        }
        return res;
    }//矩阵快速幂
    //以下均为求逆矩阵需要用到的东西，直接调用getinv()即可得到当前矩阵的逆矩阵
    void row_minus(int a, int b, i64 k)
    {
        for (int i = 0; i < 2 * MAX_MAT; ++i)
        {
            A[a][i] = (A[a][i] - A[b][i] * k % mod) % mod;
            if (A[a][i] < 0)A[a][i] += mod;
        }
        return;
    }
    i64 get_inv(i64 x)
    {
        return ksm(x, mod - 2);
    }
    void row_multiplies(int a, i64 k)
    {
        for (int i = 0; i < 2 * MAX_MAT; ++i)
        {
            A[a][i] = (A[a][i] * k) % mod;
        }
        return;
    }
    void row_swap(int a, int b)
    {
        for (int i = 0; i < 2 * MAX_MAT; ++i)
        {
            std::swap(A[a][i], A[b][i]);
        }
    }
    Mat getinv()
    {
        memset(A, 0, sizeof(A));
        for (int i = 0; i < MAX_MAT; ++i)
        {
            for (int j = 0; j < MAX_MAT; ++j)
            {
                A[i][j] = a[i][j];
                A[i][MAX_MAT + j] = i == j;
            }
        }
        for (int i = 0; i < MAX_MAT; ++i)
        {
            if (!A[i][i])
            {
                for (int j = i + 1; j < MAX_MAT; ++j)
                {
                    if (A[j][i])
                    {
                        row_swap(i, j);
                        break;
                    }
                }
            }
            row_multiplies(i, get_inv(A[i][i]));
            for (int j = i + 1; j < MAX_MAT; ++j)
            {
                row_minus(j, i, A[j][i]);
            }
        }
        for (int i = MAX_MAT - 1; i >= 0; --i)
        {
            for (int j = i - 1; j >= 0; --j)
            {
                row_minus(j, i, A[j][i]);
            }
        }
        Mat ret;
        for (int i = 0; i < MAX_MAT; ++i)
        {
            for (int j = 0; j < MAX_MAT; ++j)
            {
                ret.a[i][j] = A[i][MAX_MAT + j];
            }
        }
        return ret;
    }
};
```

### 矩阵快速幂

#### 求斐波那契数列的前 n 列和(大数据 n)

$ A = \begin{bmatrix}
 0 & 1 & 0\\
 1 & 1 & 1\\
 0 & 0 & 1
\end{bmatrix} ,\begin{pmatrix}
 f[n+1] & f[n+2] & s[n+1]
\end{pmatrix}=\begin{pmatrix}
 f[n] & f[n+1] & s[n]
\end{pmatrix}*\begin{bmatrix}
 0 & 1 & 0\\
 1 & 1 & 1\\
 0 & 0 & 1
\end{bmatrix},结合递推可知可以通过第 n 项矩阵来求解$$第 n + 1项矩阵,且由于矩阵没有交换律但是有结合律,所以直接先计算出A^{n},然后和初始矩阵相乘即可快速得到结果,矩阵乘法加快速幂.$$直接初始化f1即可求得fn$

```cpp
const int N = 3;
int n,m;
void mul(int c[],int a[],int b[][N])
{
	int temp[N] = {0};
	for(int i=0;i<N;i++)
	{
		for(int j=0;j<N;j++)
		{
			temp[i] = (temp[i] + (ll)a[j] * b[j][i]) % m;
		}
	}
	memcpy(c,temp,sizeof temp);//尺寸只能用全局变量或者矩阵变量，传 c 的话是指针长度不是数组长度
}
void mul(int c[][N],int a[][N],int b[][N])//矩阵乘法  二维乘二维
{
	int temp[N][N] = {0};
	for(int i=0;i<N;i++)
	{
		for(int j=0;j<N;j++)
		{
			for(int k=0;k<N;k++)
			{
				temp[i][j] = (temp[i][j] + (ll)a[i][k] * b[k][j]) % m;
			}
		}
	}
	memcpy(c,temp,sizeof temp);
}
int main()
{
	_;
	cin >> n >> m;
	int f1[3] = {1,1,1};//f1 = 1,f2 = 1 斐波那契,第 n 项数据,第 n + 1 项数组,前 n 项和.
	int a[N][N] = 
	{
		{0,1,0},
		{1,1,1},
		{0,0,1}
	};// A ,即是快速幂的二维数组.
	n --;//求得是 n - 1 次方,因为第一项便是初始值,只需要 n-1 幂指数即可
	while(n)
	{
		if(n & 1) mul(f1,f1,a);// res = res * a (a 是矩阵),理解是从后面乘的,不满足交换律,但满足结合律所以能直接结合后面两个
		mul(a,a,a);// a = a * a;两个函数的第一维参数都是为了将改变的值复制过来,因为是局部变量,全局变量不必考虑
		n >>= 1;
	}
	cout << f1[2] << endl; //注意区分,初始化的时候f[2]是前 n 项和,f[1]是第 n+1 斐波那契数列,f[0]是第 n 项斐波那契.
}// 5  1000   --->  12
```

### 欧拉函数

1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；

![欧拉函数](./../Images/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0.png)

- 性质 1 : 如果 n 是质数,那么 $\Phi(n) = n - 1,$因为只有 n 本身与它不互质.
- 性质 2 : 如果 p 和 q 是质数,那么 $\Phi(p * q) =  \Phi(p) *  \Phi(q) = (p - 1) * (q - 1).$
- 性质 3 : 如果 p 是质数,那么$\Phi({\bf p}^{\bf k})={\bf p}^{\bf k}-{\bf p}^{\bf k-1}(p,2p,3p\cdots p^{k-1}p一共p^{k-1}个能够整除p^k的,所以答案为p^k-p^{k-1})$
- 性质 4 :$对于任意正整数 n ,\Phi({\bf n})={\bf n}({\bf1}-\textstyle{\frac{1}{{\bf p}_{1}}})({\bf1}-\textstyle{\frac{1}{{\bf p}_{2}}})({\bf1}-\textstyle{\frac{1}{{\bf p}_{3}}}).....({\bf1}-\textstyle{\frac{1}{{\bf p}_{n}}})$
- 其余性质 : 若\ a 为质数,b mod a = 0,则$\Phi(a * b) = \Phi(b) * a,若\ a\ 和\ b\ 互质,\Phi(a * b) = \Phi(a) * \Phi(b),若\ n\ 为一个正整数,那么\Sigma_{\mathrm{d|n}}=\mathbf{n},其中\ d\ |\ n\ 表示\ d\ 整除\ n$

```cpp
int phi(int x)
{
    int res = x;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res = res / i * (i - 1);
            while (x % i == 0) x /= i;
        }
    if (x > 1) res = res / x * (x - 1);
 
    return res;
}

//筛法求欧拉函数
int primes[N], cnt;     // primes[]存储所有素数
int euler[N];           // 存储每个数的欧拉函数
bool st[N];         // st[x]存储x是否被筛掉
void get_eulers(int n)
{
    euler[1] = 1;
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i])
        {
            primes[cnt ++ ] = i;
            euler[i] = i - 1;
        }
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            int t = primes[j] * i;
            st[t] = true;
            if (i % primes[j] == 0)
            {
                euler[t] = euler[i] * primes[j];
                break;
            }
            euler[t] = euler[i] * (primes[j] - 1);
        }
    }
}
```

### 高斯消元

```cpp
// a[N][N]是增广矩阵
int gauss()
{
    int c, r;
    for (c = 0, r = 0; c < n; c ++ )
    {
        int t = r;
        for (int i = r; i < n; i ++ )   // 找到绝对值最大的行
            if (fabs(a[i][c]) > fabs(a[t][c]))
                t = i;
 
        if (fabs(a[t][c]) < eps) continue;
 
        for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);      // 将绝对值最大的行换到最顶端
        for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];      // 将当前上的首位变成1
        for (int i = r + 1; i < n; i ++ )       // 用当前行将下面所有的列消成0
            if (fabs(a[i][c]) > eps)
                for (int j = n; j >= c; j -- )
                    a[i][j] -= a[r][j] * a[i][c];
 
        r ++ ;
    }
 
    if (r < n)
    {
        for (int i = r; i < n; i ++ )
            if (fabs(a[i][n]) > eps)
                return 2; // 无解
        return 1; // 有无穷多组解
    }
 
    for (int i = n - 1; i >= 0; i -- )
        for (int j = i + 1; j < n; j ++ )
            a[i][n] -= a[i][j] * a[j][n];
 
    return 0; // 有唯一解
}
```

### 线性基

线性基的个数为 n，则最多可以异或出 $2^n - 1$个数据，算上 0 的话共 $2^n$

1.原序列里面任意一个数都可一通过线性基中的一些数异或得到

2.线性基里面的任意一些数异或起来不能的到 0

3.线性基里面的数的个数唯一，并且在保持性质一的前提下，数的个数最少

联系线代 ： **极大无关组**！！！，也即是 E ，每一行矩阵元素只有一个 1，且每一列至多有一个 1

判断一个数中是否可以被当前线性基中的元素得到，如果当前数可以插入到线性基中则不可以得到，反之可以得到

```cpp
void add(ll x)
{
    for(int i=60;i>=0;i--)
    {
        if(x&(1ll<<i))//注意，如果i大于31，前面的1的后面一定要加ll
        {
            if(d[i])x^=d[i];
            else
            {
                d[i]=x;
                break;//插入成功就退出
            }
        }
    }
}
```

- 我们可以得到一个关于d数组的性质：若 d [ i ]  不为0，则 d [ i ] 的第 i + 1位一定为 1 ，并且 d [ i ] 的最高位就是第 i + 1 位。

#### 求序列中若干数异或和最大值

```cpp
ll ans()
{
    ll anss=0;
    for(int i=60;i>=0;i--)//记得从线性基的最高位开始
    if((anss^d[i])>anss)anss^=d[i];
    return anss;
 }   
```

#### 求异或第 k 大值

```cpp
void work()//处理线性基  将线性基转换为标准的极大无关组 
{
	for(int i=1;i<=60;i++)
	for(int j=1;j<=i;j++)
	if(d[i]&(1ll<<(j-1)))d[i]^=d[j-1];
    for(int i = 0;i <= 63;i++) if(p[i]) d[cnt++]=p[i];
}
int kth(int k)//第k大 
{
	if(k >= (1LL<<cnt)) return -1;
	int ans=0;
	for(int i = 62;i>=0;i--)
	{
		if((k>>i)&1) ans^=d[i];
	}
	return ans;
}
```

#### 求序列异或最小值

如果有不能插入到线性基中的数据，答案就是 0，否则就是最小的 `d[i]`

#### 求异或第 k 小值

将 `k`先转成二进制，假如 `k` 的第 `i` 位为 `1`，`ans`就异或上线性基中第 `i` 个元素（注意不是直接异或 `d[i-1]` ）。

```cpp
void work()//处理线性基  将线性基转换为标准的极大无关组 
{
	for(int i=1;i<=60;i++)
	for(int j=1;j<=i;j++)
	if(d[i]&(1ll<<(j-1)))d[i]^=d[j-1];
    for(int i = 0;i <= 63;i++) if(p[i]) d[cnt++]=p[i];
}
ll k_th(ll k)
{
	if(k==1&&tot<n)return 0;//特判一下，假如k=1，并且原来的序列可以异或出0，就要返回0，tot表示线性基中的元素个数，n表示序列长度
	if(tot<n)k--;//类似上面，去掉0的情况，因为线性基中只能异或出不为0的解
	work();
	ll ans=0;
	for(int i=0;i<=60;i++)
	if(d[i]!=0)
	{
		if(k%2==1)ans^=d[i];
		k/=2;
	}
}
```

#### 合并两个线性基

```cpp
void merge(Linear_Basis &a,Linear_Basis &b){//a和b都变成a+b
    for(int i=31;i>=1;i--){
        if(b.b[i]==0)continue;
        a.Ins(b.b[i]);
    }
    b=a;
}
```

### 曼哈顿距离 和 切比雪夫距离

切比雪夫距离定义如下：

设 $A(x_1,y_1),B(x_2,y_2)$

$d(A,B)=\max\{|x_1-x_2|,|y_1-y_2|\}$

曼哈顿距离与切比雪夫距离可以相互转化：

$\begin{aligned}D_{man}(A,B)&=|x_1-x_2|+|y_1-y_2|\\&=\max\{x_1-x_2+y_1-y_2,x_1-x_2+y_2-y_1,x_2-x_1+y_1-y_2,x_2-x_1+y_2-y_1\}\\&=\max\{|(x_1+y_1)-(x_2+y_2)|,|(x_1-y_1)-(x_2-y_2)|\}\\&=d((x_1+y_1,x_1-y_1),(x_2+y_2,x_2-y_2))\end{aligned}$

令 $A'(x_1+y_1,x_1-y_1),B'(x_2+y_2,x_2-y_2)$

将曼哈顿距离转为切比雪夫距离后，$A',B'$ 的 x，y 坐标就相互独立了。

```cpp
//求给定的 m 个点中到给定的 n 个点中, 在 m 中选中一个点使得到这 n 个点的最大距离最小
//求出转化后客户最小和最大的 x 坐标和 y 坐标。
//对于每个配送站算一下他们距离最小和最大的 x / y 的距离，取个max就是这个配送站距离最远的客户的距离。
//对于所有配送站取个最小值就可以了。
void solve()
{
    cin >> n >> m;
    int x, y;
    cin >> x >> y;
    for (int i = 0; i < 4; i++)
        a[i][0] = x, a[i][1] = y;
    for (int i = 1; i < n; i++)
    {
        int x, y;
        cin >> x >> y;
        if (x + y < a[0][0] + a[0][1])
        {
            a[0][0] = x;
            a[0][1] = y;
        }
        if (x + y > a[1][0] + a[1][1])
        {
            a[1][0] = x;
            a[1][1] = y;
        }
        if (x - y < a[2][0] - a[2][1])
        {
            a[2][0] = x;
            a[2][1] = y;
        }
        if (x - y > a[3][0] - a[3][1])
        {
            a[3][0] = x;
            a[3][1] = y;
        }
    }
    int ans = inf;
    for (int i = 1; i <= m; i++)
    {
        int x, y;
        cin >> x >> y;
        int res = 0;
        for (int j = 0; j < 4; j++)
            res = max(res, abs(a[j][0] - x) + abs(a[j][1] - y));
        if (res < ans)
            ans = res;
    }
    cout << ans << endl;
}
```

### set 动态维护中位数

求区间最长连续段个数 最多只能操作 `k` 次 每次操作可以使元素加一或者减一 .

由于目的是使区间连续 , `a[i] - i` 即是相同 ,  转化为区间内中位数和减去目前区间和 , 判断需要几步 .

```cpp
class Medium_Solver
{
private:
	multiset<int> A, B;//A中维护的是小于等于中位数的数据,B中是大于等于中位数的数据
	int SA, SB; // SA,SB是当前set里面的元素和
public:
	inline void init(void)
	{
		A.clear();
		B.clear();
		SA = SB = 0;
	}
	inline void insert(int &x)//加入数据
	{
		if (B.empty())
		{
			B.insert(x);
			SB += x;
			return;
		}
		int mid = *B.begin();
		if (x >= mid)
		{
			B.insert(x);
			SB += x;
			if (A.size() < B.size() - 1)
			{
				auto it = B.begin();
				SB -= *it;
				SA += *it;
				A.insert(*it);
				B.erase(it);
			}
		}
		else
		{
			A.insert(x);
			SA += x;
			if (A.size() > B.size())
			{
				auto it = (--A.end());
				SA -= *it;
				SB += *it;
				B.insert(*it);
				A.erase(it);
			}
		}
	}
	inline void remove(int &x) // 删除数据
	{
		int mid = *B.begin();
		if (x >= mid)
		{
			B.erase(B.find(x));
			SB -= x;
			if (A.size() > B.size())
			{
				auto it = (--A.end());
				SA -= *it;
				SB += *it;
				B.insert(*it);
				A.erase(it);
			}
		}
		else
		{
			A.erase(A.find(x));
			SA -= x;
			if (A.size() < B.size() - 1)
			{
				auto it = B.begin();
				SB -= *it;
				SA += *it;
				A.insert(*it);
				B.erase(it);
			}
		}
	}
	inline int calc(void)//计算全部变为当前中位数需要的操作数
	{
		int mid = *B.begin();
		return (mid * A.size() - SA) + (SB - mid * B.size());
	}
	// inline void DEBUG(void)
	// {
	// 	for (auto x : A)
	// 		printf("%lld ", x);
	// 	printf("SA= %lld\n", SA);
	// 	for (auto x : B)
	// 		printf("%lld ", x);
	// 	printf("SB= %lld\n", SB);
	// }
} S;
void solve()
{
	cin >> n >> k;
	pre(i,1,n) cin >> a[i],a[i] -= i;// 区间是连续的
	S.init();
	int l = 1,ans = 1;
	pre(i,1,n)
	{
		while(l <= n)
		{
			S.insert(a[l ++]);
			if(S.calc() > k)//此时不符合条件了,break计算区间长度,注意需要先删除
			{
				S.remove(a[-- l]);
				break;
			}
		}
		ans = max(ans,l - i + 1);
		S.remove(a[i]);//左指针右移
	}
	cout << ans - 1 << endl;
}
```

### 对顶堆维护中位数

```cpp
void solve()
{
    cin >> n;
    priority_queue<int> d; // 默认大根堆
    priority_queue<int, vector<int>, greater<int>> s;
    //	让大根堆的元素<=mid
    //	让小根堆的元素>mid
    int mid = INT_MIN;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];

        if (i == 1)
            mid = a[1];
        if (a[i] <= mid)
            d.push(a[i]);
        else
            s.push(a[i]);
        if (i % 2)
        {
            while ((int)d.size() - (int)s.size() < 1)
            {
                d.push(s.top());
                s.pop();
            }
            while ((int)d.size() - (int)s.size() > 1)
            {
                s.push(d.top());
                d.pop();
            }
            mid = d.top();
            cout << mid << '\n';
        }
    }
}
```

#### 随机数

```cpp
static mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());
/// 返回在 [l, r] 间（包括 l、r）的一个均匀分布随机整数
long long rand_ll(long long l, long long r) {
    uniform_int_distribution<long long> dist(l, r);
    return dist(rng);
}
int d = rand_ll(l,r);
```



## 数据结构

### 并查集

```cpp
struct DSU {
    vector<int> f, siz;
    DSU() {}
    DSU(int n) {
        init(n);
    }
    void init(int n) {
        f.resize(n);
        iota(f.begin(), f.end(), 0);
        siz.assign(n, 1);
    }
    int find(int x) {
        while (x != f[x]) {
            x = f[x] = f[f[x]];
        }
        return x;
    }
    bool same(int x, int y) {
        return find(x) == find(y);
    }
    bool merge(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) {
            return false;
        }
        if (siz[x] < siz[y]) swap(x, y);
        siz[x] += siz[y];
        f[y] = x;
        return true;
    }
    int size(int x) {
        return siz[find(x)];
    }
};
DSU p(n + 1);//初始化
```

#### 带权并查集

```cpp
int dis[100001];//记录该集合的总大小
int tot[100001];//前面的节点数
int fa[100001];//记录元素祖先
void clean(int n)//初始化 
{
	for (int i=0;i<=n;i++) 
		fa[i]=i,tot[i]=1;
}
int find(int k)//查找该元素的祖先
{
	if(fa[k] == k)
		return k;
	int f = find(fa[k]);
	dis[k] += dis[fa[k]];
	return fa[k];
}
void add(int x,int y)//合并两个集合
{
	x = find(x);
	y = find(y);
	dis[x] = tot[y];//a 树作为 b 树的子树
	tot[y] += tot[x];
	fa[x] = y;
}
```

#### 扩展域并查集

`拓展域并查集解决了一种多个有相互关系的并查集，放在一起考虑的问题,拓展域并查集讲的是多个集合，之间有相互关系一般为相互排斥关系，判断是否在一个集合等。`

```cpp
典型例题 ---- 食物链
//判断到根节点的距离即可 距离%3==0 与根节点是同一类 %3==1 可以吃根节点 %3==2,被根节点吃 ，路径压缩的时候维护距离即可
int n,m;//动物数与说话个数
int p[N],d[N];//并查集和维护的距离
int find(int x)
{
	if(p[x] != x)//x不是根
	{
		int t = find(p[x]);//不能直接写p[x] = find(p[x])
		d[x] += d[p[x]];//直接写的话，p[x]会改变，不是初始x的p
		p[x] = t;
	}
	return p[x];
}
int main()
{
	cin >> n >> m;
	for(int i=1;i<=n;i++) p[i] = i;//距离不必初始化全局变量为0，表示其实都是与自己同一类
	int res = 0;
	while(m --)
	{
		int t,x,y;
		cin >> t >> x >> y;
		if(x > n || y > n)
			res ++;
		else 
		{
			int px = find(x),py = find(y);
			if(t==1)
			{    //父节点相同是前提 然后不是都%3=0，不是同一类
				if(px == py && (d[x] - d[y])%3 != 0) res ++;
				else if(px != py)
				{
					p[px] = y;
					d[px] = d[y] - d[x];
				}
			}
			else 
			{//X吃Y   X到根的距离应该比Y到根多 1 （mod 3）的情况下
				if(px == py && (d[x] - d[y] - 1	) %3 != 0) res ++;
				else if(px != py)
				{
					p[px] = py;//先合并
					d[px] = d[y] + 1 - d[x];
				}
			}
		}
	}
	cout << res << endl;
	return 0;	
}
```

#### 每个子图点对联通问题

将一个空图复制 d 次，给定 `u,v,w` 代表在第 w 个图中，在 `u,v`之间建边，判断每次操作之后有多少个点对在任意一个图中都联通

题目只考虑连通性，可以用`d`个并查集维护，两个点`u，v` 在图 `i` 上联通，当且仅当图 `i` 上 `u 和 v` 的并查集祖先相同

因此，两个点 `u` 和 `v` 在 d 张图上都联通，等价于在任意 `i`，`u 和 v `在第 `i` 张图的并查集祖先都相同。

**所以考虑维护每个点 u 维护一个长度为 d 的字符串 $s_u$，$s_u(i)$ 表示第 i 张图上 u 的并查集祖先。**

于是 u 和 v 在 d 张图上联通等价于 $s_u == s_v$  即是在每一张图中，u 和 v 的父节点都相同则是联通的

使用 hash 来判断字符串是否相同，对于哈希值相同的 k 个字符串，对答案的贡献是 $k^2$ (有序点对)

向第 k 张图中加边，会修改 $s_u$ 的第 k 个字符，u 是所有这次连边中在并查集上被更改祖先的点。

**注意：**不能使用路径压缩，使用路径压缩的话，每次加边需要更改的点的祖先是非常多的，只能通过`for`循环来修改每一个点

考虑 按秩合并(启发式合并) ,每次操作被更改祖先的次数不会超过`log n`次 (因为被更改一次祖先，他所在的并查集树的大小就会翻倍)，每次更改只会改变这一棵子树到达根节点之间的所有点，每个字符串被修改不超过 `dlog n`次，总次数为 `nd log n` 每一子树之间的合并仍然会路径压缩，但不会压缩到根节点

可能会卡 hash 常数，直接考虑对于长度为 d 的字符串随机化一个权值 `w[i]`，对于字符串 S 的`hash`值是 $\textstyle\sum w(i)\times S(i)$ 

```cpp
//此份代码维护的是无序点对，若想维护有序点对，维护的值是 k^2   有序维护的是 k * (k - 1) / 2
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define endl "\n"
#define ull unsigned long long
const int N = 5e4 + 10,M = 105;
#define pre(i, a, b) for (int i = a; i <= b; i++)
#define rep(i, a, b) for (int i = a; i >= b; i--)
int d,n,m,q;
unordered_map<ull,int> mp;//每个字符串的hash值
ull w[M];//长度为 d 的字符串随机化的权值
int rt[M][N];//第 i 个图中 j 节点的祖先，
vector<int> p[M][N];//第 i 个图中以 j 为根的并查集
int ans;
ull h[N];//对于每个点维护一个 hash 值，第 i 位值表示在第 i 个图中的并查集祖先，将整个字符串hash判断是否相同，不需要常规hash，直接给每一位一个权值
//判断每个点在第 i 张图中的祖先是否相同
void merge(int w_, int u_, int v_)
{
	int fu = rt[w_][u_],fv = rt[w_][v_];
	if (fu == fv)
		return;

	if (p[w_][fu].size() > p[w_][fv].size())
		std::swap(fu, fv);
	rt[w_][fu] = fv;
	for (auto x : p[w_][fu])
	{
		p[w_][fv].push_back(x);
		rt[w_][x] = fv;

		ans -= 2ll * mp[h[x]] - 2, mp[h[x]] = mp[h[x]] - 1;
		h[x] += (fv - fu) * w[w_];
		ans += 2ll * mp[h[x]], mp[h[x]] = mp[h[x]] + 1;
	}
	p[w_][fu].clear();
}
void solve()
{
	cin >> n >> m >> d >> q;
    mt19937_64 rng(std :: random_device{}());
    pre(i,1,d + 1)
        w[i] = rng();
    pre(j,1,n)
    {
        rt[1][j] = j;//初始化操作，初始无边，每个节点的祖先都是自己
        p[1][j].clear();
        p[1][j].push_back(j);//第 i 个图，点 j 为根的最初并查集，元素只有自己
    }
    pre(i,1,m) //此部分是如果原先复制的不是空图，将一个有边图复制的时候
    {
        int a,b;cin >> a >> b;
        int k = 1;
        merge(1,a,b);
    }
    pre(i,2,d + 1)//如果初始图是空图，上面两个循环都不必有，此处的rt[1][j] = j,即是rt[i][j] = j
    {
        pre(j,1,n)
        {
            rt[i][j] = rt[1][j];//初始化操作，初始无边，每个节点的祖先都是自己
            p[i][j].clear();
            for(auto L : p[1][j])
                p[i][j].push_back(L);
        }
    }
    ans = 0;
    mp.clear();
    pre(i,1,n)
    {
        h[i] = 0;
        pre(j,1,d + 1)//给定的图是空图的时候可以直接和上一步循环一起计算，多组数据时独自初始化后也可以和上一步一起算
        {
            h[i] += 1ll * w[j] * rt[1][i];
        }
        mp[h[i]] = mp[h[i]] + 1;
    }
    for(auto [x,y] : mp)
        ans += 1ll * y * (y - 1);
    pre(i,1,q)
    {
        int a,b,k;
        cin >> a >> b >> k;
        merge(k,a,b);
        cout << ans / 2 << endl;
    }
}
```

### ST 表

ST表是用于解决 **可重复贡献问题** 的数据结构.可贡献问题指的是对于运算 opt,满足 x opt x = x,则对应的区间查询就是一个可重复贡献问题.例如 RMQ(区间最值),和max,gcd 类,但是区间和这种区间一旦重复区间和就一定会改变的不是,同时**opt必须满足结合律才能使用ST表**.O(nlogn) 询问,O(1)查询,但不支持区间修改,**二维DP**表示从 i 长度为$\ 2^{j}\ 的区间内的最值,如此可以直接预处理所有长度为\ 2^{j}\ 的区间内的最值,询问的时候将长度分为两个前后区间查询$ 

```cpp
const int N = 1e5 + 10;//数据比较极限,需要加快读,否则超时.    可以证明 2 * pow(2,__lg(len)) >= len
int f[N][22];//长度为2^j次方,从i开始的最大值
int n, m;
int Log[N * 2];//因为log(a)表示小于等于a的2的最大几次方。即 2 ^ log <= a,即是log(a)下取整
int main() 
{
    n = read(),m = read();
    for (int i = 1; i <= n; i++) 
        cin >> f[i][0];//从i开始长度为 1 的最大值即为自己
    //更新f数组  转换为长度累加即可
    for (int i = 1; i < 22; i++) //求区间最大值,每次更新以二进制为基础
    {
        for (int j = 1; j + (1 << i) - 1 <= N; j++)
        {//拆分为左右两等段
            f[j][i] = max(f[j][i - 1], f[j + (1 << (i - 1))][i - 1]);
        }
    }
    int l ,r ;
    for (int i = 0; i < m; i++) 
    {
        l = read(),r = read();//求  l - r 内的最大值
        int s = __lg(r - l + 1);//__lg自带的log2的函数,返回的是log(n),下取整
        cout << max(f[l][s], f[r - (1 << s) + 1][s]) << endl;//为了防止越界或者不足,右边的区间起点用r-len
    }//所以l到r的最小值可以表示为min(从l往后2^t的最小值，从r往前2^t的最小值)
    return 0;
}
```

### 莫队

> **普通莫队**的分块大小为$\sqrt{n}$，**带修莫队**最佳大小为$\sqrt[4]{n^3}$。
> 奇偶排序是第二关键字是左端点所在块的奇偶排序右端点
> 注意 : 莫队初始化的时候 L= 1,R = 0,否则容易出现边界问题,先左右指针移动,在时间戳移动,指针压缩时注意先增和后增 !!!
> **回滚莫队的数组需要开大一点不然就会 WA ，**而且左右指针移动的数组一定要在重复下一次操作前清零（不在同一块了）。
> 卡常：尽量不要使用STL，氧气$O~3~$优化不能少，快读不加可能会被卡常

#### 优化

```cpp
bool cmp(kkk a,kkk b){
	if(blo[a.l] != blo[b.l])
        return a.l < b.l;
	if(blo[a.l] % 2 == 0)
        return a.r > b.r;//多加了行判断,是奇数块右端点按照升序排列
		return a.r < b.r;//偶数块,右端点按照降序排列
}
int cmp(query a, query b) {
	return (belong[a.l] ^ belong[b.l]) ? belong[a.l] < belong[b.l] : ((belong[a.l] & 1) ? a.r < b.r : a.r > b.r);
}//异或操作,只有在同一个块才会返回0,不同返回1,即是三目运算符前面,直接按照左端点排序,然后按照奇偶块排序右端点
//将add 和 del 函数以及判断l , r的大小直接压缩为
while(l < ql) now -= !-- cnt[aa[l ++]];
while(l > ql) now += !cnt[aa[-- l]] ++;
while(r < qr) now += !cnt[aa[++ r]] ++;
while(r > qr) now -= !-- cnt[aa[r --]];
//非常考验运算符优先级,不熟勿用
```

#### 分块

```cpp
//    pre(i,1,ceil(1.0 * n / size))//容易RE，这种写法会多开一个块，所以需要开大一点空间
//        pre(j,(i - 1) * size + 1;i * size)
//        	belong[j] = i;
int size = ;
pre(i,1,n) //使用这中进行分块 ble = (i - 1) / size + 1
    cin >> a[i],belong[i] = (i - 1) / size + 1;
```

### 区间相同数距离最大值

```cpp
#include<bits/stdc++.h>
using namespace std;
#define _ ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define endl '\n'
#define int long long 
#define pre(i,a,b) for(int i=a;i<=b;i++)
const int N = 1e6 + 10;
int n,m;
int a[N],iph[N],typ[N];
int ble[N],L[N],R[N],ans[N];
int cnt[N];
int f[N],la[N],cnt1[N],cnt2;
struct query
{
    int l,r,id;
    bool operator<(query w)
    {
        return (ble[l] ^ ble[w.l] ? ble[l] < ble[w.l] : r < w.r);
    }
}q[N];

void solve()
{
    cin >> n;
    pre(i,1,n)
    {
        cin >> a[i];
        iph[i] = a[i];
    }
    sort(iph + 1,iph + 1 + n);
    int tot = unique(iph + 1,iph + 1 + n) - iph - 1;
    pre(i,1,n)
        typ[i] = lower_bound(iph + 1,iph + 1 + tot,a[i]) - iph;
    cin >> m;
    pre(i,1,m)
    {
        cin >> q[i].l >> q[i].r;
        q[i].id = i;
    }
    int size = sqrt(n);
    int bnum = ceil(1.0 * n / size);
    pre(i,1,bnum)
    {
        L[i] = (i - 1) * size + 1,R[i] = i * size;
        pre(j,L[i],R[i])
            ble[j] = i;
    }
    R[bnum] = n;
    sort(q + 1,q + 1 + m);
    int i = 1;
    for(int k=1;k<=bnum;k++)
    {
        int l = R[k] + 1,r = R[k],now = 0;
        cnt2 = 0;
        for(;ble[q[i].l] == k;i++)
        {
            int ql = q[i].l,qr = q[i].r,id = q[i].id,tmp = 0;
            if(ble[ql] == ble[qr])
            {
                for(int j=ql;j<=qr;j++)
                    cnt[typ[j]] = 0;
                for(int j=ql;j<=qr;j++)
                {
                    if(!cnt[typ[j]])
                        cnt[typ[j]] = j;
                    else tmp = max(tmp,j - cnt[typ[j]]);
                }
                ans[id] = tmp;
                continue;
            }
            //右指针
            while(r < qr)
            {
                ++ r;
                la[typ[r]] = r;
                if(!f[typ[r]])
                    f[typ[r]] = r,cnt1[++ cnt2] = typ[r];
                now = max(now,r - f[typ[r]]);
            }
            tmp = now;
            while(l > ql)
            {
                l --;
                if(la[typ[l]])
                    now = max(now,la[typ[l]] - l);
                else la[typ[l]] = l;
            }
            ans[id] = now;
            while(l < R[k] + 1)
            {
                if(la[typ[l]] == l) la[typ[l]] = 0;
                l ++;
            }
            now = tmp;   
        }
        pre(j,1,cnt2)
                la[cnt1[j]] = f[cnt1[j]] = 0;
    }
    pre(i,1,m)
        cout << ans[i] << endl;
}

signed main()
{
    _;
    int t = 1;
    // cin >> t;
    while(t --)
        solve();
}
```

#### 扩展  -- 维护可任意位置删除的栈

[莫队+模拟可任意删除栈](https://www.luogu.com.cn/problem/CF1000F?contestId=152942)

> 本题非常卡常，奇偶排序，快读，氧气优化都要使用，不能使用STL
> 关键点在于模拟可以在任意位置删除的栈，代表存放莫队中只出现一次的元素，没有这类元素，输出0

```cpp
#pragma GCC optimize (3)
#pragma GCC optimize ("Ofast")
#include<bits/stdc++.h>
using namespace std;
#define pre(i,a,b) for(int i=a;i<=b;i++)
const int N = 2e6 + 10;
int n,m;
int a[N],ble[N],cnt[N],stk[N],pos[N],top;//主要是模拟可以删除栈任意位置的元素，做到O(1)删除和添加
int ans[N];//模拟栈的删除功能是直接将被删除的数替换为现在的栈顶元素即可，本身是栈顶是即是清零操作
char *p1,*p2,buf[100000];//快读和同步流二者只能选一个
#define nc() (p1==p2 && (p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)
int read()
{
    int x = 0,f = 1;char ch = nc();
    while(ch<48||ch>57)  {if(ch=='-')f=-1;ch=nc();}
    while(ch>=48&&ch<=57)  x=x*10+ch-48,ch=nc();
    return x*f;
}
void write(int x)
{
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
    return;
}
struct query
{
    int l,r,id;
    bool operator<(query w)
    {
        return (ble[l] ^ ble[w.l] ? ble[l] < ble[w.l] : (ble[l] & 1) ? r < w.r : r > w.r);
    }
}q[N];
void add(int x)
{
    ++ cnt[x];
    if(cnt[x] == 1)
    {
        stk[++ top] = x;//栈顶元素是 x
        pos[x] = top;//栈顶元素 x 的下标是 top
    }
    else if(cnt[x] == 2)
    {
        stk[pos[x]] = stk[top];//栈顶元素替换 x 元素所在的位置
        pos[stk[top]] = pos[x];//对应的下标也替换
        stk[top --] = pos[x] = 0;//将 x 元素从栈中删除,清零
    }
}
void del(int x)
{
    -- cnt[x];
    if(cnt[x] == 1)
    {
        stk[ ++ top] = x;
        pos[x] = top;
    }
    else if(cnt[x] == 0)//从栈中删除一个元素
    {
        stk[pos[x]] = stk[top];
        pos[stk[top]] = pos[x];
        stk[top --] = pos[x] = 0; 
    }
}
void solve()
{
    n = read();
    int size = sqrt(n);
    pre(i,1,n)
    {
        a[i] = read();
        ble[i] = (i - 1) / size + 1;
    }
    int bnum = ble[n];
    m = read();
    pre(i,1,m)
    {
        q[i].l = read();q[i].r = read();
        q[i].id = i;
    }
    sort(q + 1,q + 1 + m);
    int l = 1,r = 0;
    pre(i,1,m)
    {
        int ql = q[i].l,qr = q[i].r,id = q[i].id;
        while(l < ql)   del(a[l ++]);
        while(l > ql) add(a[-- l]);
        while(r < qr) add(a[++ r]);
        while(r > qr) del(a[r --]);
        ans[id] = stk[top];
    }
    pre(i,1,m)
        write(ans[i]),puts("");
}
```

#### 莫队算法的扩展 --- 带修改的莫队

[洛谷P1903](https://www.luogu.com.cn/problem/P1903)

- 基础莫队只能离线操作,对于需要修改的强制在线操作,某些允许离线的待修改区间查询来说,将莫队直接加上一维,变为待修莫队可以实现操作.(具体操作是将修改操作标号,记作"时间戳",**而查询操作的时间戳沿用之前最近的修改操作的时间戳**,跑主算法时定义当前时间戳为 t, 对于每个查询操作,如果当前时间戳相对大了,把之前的改回来,反之往后改,只有当前区间与查询区间左右端点,时间戳都重合时,才认定区间完全重合,求出答案.)
- 通俗的说就是在加上一个时间戳指针,在修改操作上跳,区间的移动方向由四个变为六个

```c++
([l - 1,r],[l + 1,r],[l,r - 1],[l,r + 1]);//原来的四个
([l - 1,r ,t],[l + 1,r ,t],[l,r - 1,t],[l,r + 1,t],[l,r,t - 1],[l,r,t + 1]);//加上时间戳六个
int cmp(query a, query b) {//排序的时候加上时间戳即可
	return (belong[a.l] ^ belong[b.l]) ? belong[a.l] < belong[b.l] : ((belong[a.r] ^ belong[b.r]) ? belong[a.r] < belong[b.r] : a.time < b.time);
}
```

- 移完 t 后做完一处修改后可能需要改回来所以可能需要将原值存下来备用.分块大小为 $\sqrt[4]{n^{3}t}$ 时复杂度最优,死记即可.

```c++
#include<bits/stdc++.h>
using namespace std;
#define maxn 50500
#define maxc 1001000
int a[maxc], cnt[maxc], ans[maxc], belong[maxn];
struct query {
	int l, r, time, id;
} q[maxc];
struct modify {
	int pos, color, last;
} c[maxc];
int cntq, cntc, n, m, size, bnum;
int cmp(query a, query b) {
	return (belong[a.l] ^ belong[b.l]) ? belong[a.l] < belong[b.l] : ((belong[a.l] ^ belong[b.l]) ? belong[a.r] < belong[b.r] : a.time < b.time);
}
#define isdigit(x) ((x) >= '0' && (x) <= '9')
inline int read() {
	int res = 0;
	char c = getchar();
	while(!isdigit(c)) c = getchar();
	while(isdigit(c)) res = (res << 1) + (res << 3) + (c ^ 48), c = getchar();
	return res;
}
int main() {
	n = read(), m = read();
	size = pow(n, 3.0 / 4.0);//块的大小,这里块的大小是 n^(3/4)
	bnum = ceil((double)n / size);//分块的个数
	for(int i = 1; i <= bnum; ++i) 
		for(int j = (i - 1) * size + 1; j <= i * size; ++j)
            belong[j] = i;
	for(int i = 1; i <= n; ++i) 
		a[i] = read();
	for(int i = 1; i <= m; ++i) {
		char opt[100];
		scanf("%s", opt);
		if(opt[0] == 'Q') {//区间,
			q[++cntq].l = read();
			q[cntq].r = read();
			q[cntq].time = cntc;//代表当前查询前面有多少次修改
			q[cntq].id = cntq;//第几次查询
		}
		else if(opt[0] == 'R') {//修改操作
			c[++cntc].pos = read();//cntc 代表修改操作的编号
			c[cntc].color = read();
		}
	}
	sort(q + 1, q + cntq + 1, cmp);
	int l = 1, r = 0, time = 0, now = 0;
	for(int i = 1; i <= cntq; ++i) {
		int ql = q[i].l, qr = q[i].r, qt = q[i].time;//当前询问区间左端点右端点,之前做多少修改操作.
		while(l < ql) now -= !--cnt[a[l++]];//先移动左右端点,压缩指针版  区间删除
		while(l > ql) now += !cnt[a[--l]]++;//区间添加
		while(r < qr) now += !cnt[a[++r]]++;//区间添加
		while(r > qr) now -= !--cnt[a[r--]];//区间删除
		while(time < qt) { //时间戳移动
			++time;//区间添加先改变指针,因为操作的指针不在区间内,先加到区间内,在考虑改变
			if(ql <= c[time].pos && c[time].pos <= qr) now -= !--cnt[a[c[time].pos]] - !cnt[c[time].color]++;
			swap(a[c[time].pos], c[time].color);//只有这个修改下标在询问区间里才有更改的必要,否则不会对答案产生影响
		}//交换操作,将 time 对应下标的颜色修改为执行修稿操作后的颜色,并存下来,方便后续移动时间戳回溯.
		while(time > qt) {//区间删除,先改变对答案的影响,因为指针在区间内.
			if(ql <= c[time].pos && c[time].pos <= qr) now -= !--cnt[a[c[time].pos]] - !cnt[c[time].color]++;
			swap(a[c[time].pos], c[time].color);
			--time;
		}
		ans[q[i].id] = now;
	}
	for(int i = 1; i <= cntq; ++i) 
		printf("%d\n", ans[i]);
	return 0;
}
```

#### 回滚莫队

> **回滚莫队的数组需要开大一点不然就会 WA ，**而且左右指针移动的数组一定要在重复下一次操作前清零（不在同一块了）。

使用背景 ：当普通莫队不可解的问题就是在转移区间过程中，可能是删点或加点操作**之一**，此时使用回滚莫队解决。

##### 只加不减的回滚莫队

加点操作可以实现，但是删点操作无法有效的实现：

> 1、对原序列进行分块，并对询问按照如下的方式排序，**以左端点所在的块升序为第一关键字，以右端点升序为第二关键字**。
> 2、对于处理所有左端点在块**T**内的询问，先将莫队区间左端点初始化为**R[T] + 1，右端点初始化为R[T]，这是一个空区间**
> 3、对于左右端点在同一个块中的询问，直接暴力扫描回答
> 4、对于左右端点不在同一块中的所有询问，由于其右端点升序，我们对右端点只做加法操作，总共最多加点`n`次
> 5、对于左右端点不在同一块中的所有询问，其左端点可能是乱序的，每一次从**R[T] + 1**的位置出发，只做加法操作，到达询问位置即可，每一次询问最多加$\sqrt{n}$次。回答完后，**撤销本次移动左端点的所有改动，使左端点回到R[T] + 1的位置。**
> 6、依次处理下一块

根据其操作的过程可知，回滚莫队的时间复杂度仍然是$O(n\sqrt{n})$,并且，在回答询问的过程中我们只进行了加点操作，没有涉及删点操作，这样就完成了我们需要的操作。

##### 只减不加的回滚莫队

和上一种典型的回滚莫队类似，还可以实现只有删点操作没有加点操作的回滚莫队，当然，前提是我们可以正确的先将整个序列加入莫队中：

> 1、对原序列进行分块，并对询问按照如下的方式排序：**以左端点所在的块升序作为第一关键字，以右端点降序作为第二关键字**。
> 2、对于处理所有左端点在块**T**内的询问，先将莫队区间左端点初始化为**L[T]**，右端点初始化为`n`，这是一个大区间。
> 3、对于左右端点在同一个块中的询问，直接暴力扫描即可。
> 4、对于左右端点不在同一个块中的所有询问，由于其右端点降序，从`n`的位置开始，我们对右端点只做删点操作，总共最多删点`n`次。
> 5、对于左右端点不在同一个块中的所有询问，其左端点是可能乱序的，我们每一次从`L[T]`的位置出发，只做删点操作，达到询问位置即可，每一个询问最多加$\sqrt{n}$次，回答完之后，**我们撤销本次移动左端点的所有改动，使左端点回到L[T]的位置**。
> 6、重复。

同样的，回滚莫队的时间复杂度还是$O(n\sqrt{n})$，并且我们只使用了删点操作，只有在一开始时将整个序列加入莫队中，这样就完成了我们需要的操作

##### [只加不删的回滚莫队](https://www.luogu.com.cn/problem/AT_joisc2014_c)

求元素权值 * 区间出现次数的最大值，加点容易实现，但是删点之后的次大值无法维护所以不能删点，因此我们需要只加不删的回滚莫队，**撤销操作**就是在桶中`(cnt数组，出现的次数)`减去出现次数，而不管答案是否改变，在下一次加点的过程中答案就得以统计了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define _ ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define endl '\n'
#define int long long 
#define pre(i,a,b) for(int i=a;i<=b;i++)
#define rep(i,a,b) for(int i=a;i>=b;i--)
const int N = 1e5 + 10;
int n,m;
int a[N],typ[N],cnt[N],cnt2[N],ble[N],lb[N],rb[N],inp[N];
int ans[N];//typ表示离散化后的数组，原数组数据范围太大，需要离散化
struct query
{
    int l,r,id;
    bool operator<(query w)
    {
        return (ble[l] ^ ble[w.l] ? ble[l] < ble[w.l] : r < w.r);//回滚莫队不能奇偶排序
    }//需要保证同一块的内的右端点单调递增。
}q[N];

void solve()
{
    cin >> n >> m;
    int size = pow(n,3.0 / 4.0);
    int bnum = ceil(1.0 * n / size);//这里不要忘记转换为double
    for(int i=1;i<=bnum;i++)
    {
        lb[i] = size * (i - 1) + 1;
        rb[i] = size * i;
        for(int j=(i - 1) * size + 1;j <= i * size;j ++)
            ble[j] = i;
    }
    rb[bnum] = n;
    for(int i=1;i<=n;i++)
    {
        cin >> a[i];
        inp[i] = a[i];
    }
    sort(inp + 1,inp + 1 + n);
    int tot = unique(inp + 1,inp + n + 1) - inp - 1;//去重数组，判断一共有多少不同的数
    for(int i=1;i<=n;i++)
        typ[i] = lower_bound(inp + 1,inp + tot + 1,a[i]) - (inp - 1) - 0 + 1;//离散化操作离散到以0开始
    for(int i=1;i<=m;i++)
    {
        int l,r;
        cin >> l >> r;
        q[i] = {l,r,i};
    }
    sort(q + 1,q  + 1 + m);//排序：按照左端点的块升序和右端点为两个键值排序。
    int i = 1;//枚举询问到的块
    for(int k=0;k<=bnum;k++)//枚举每一个块
    {
        int l = rb[k] + 1,r = rb[k];//初始化，将左端点初始化为块右端点加一，右端点为块右端点--空区间
        int now = 0;
        fill(cnt,cnt + 1 + n,0);//莫队本身的cnt数组，记录出现次数
        for(;ble[q[i].l] == k;i ++)//当前的询问区间在这个块内
        {
            int ql = q[i].l,qr = q[i].r,id = q[i].id,tmp;
            if(ble[ql] == ble[qr])//左右端点属于同一个块 k
            {
                tmp = 0;
                for(int j=ql;j<=qr;j++)
                    cnt2[typ[j]] = 0;//暴力扫描的 cnt，块内清零操作
                for(int j=ql;j<=qr;j++)
                {
                    ++ cnt2[typ[j]];//计算块内的数据
                    tmp = max(tmp,cnt2[typ[j]] * a[j]);
                }
                ans[id] = tmp;//在同一个块内的询问直接在块内暴力扫描
                continue;
            }
            //不在一个块内的询问  -- 只加不删的回滚莫队
            while(r < qr)//右端点不够，右端点右移
            {
                ++ r;
                ++ cnt[typ[r]];
                now = max(now,cnt[typ[r]] * a[r]); 
            }
            tmp = now;//暂时的最大值，记录撤销操作
            while(l > ql)//左端点不够，左端点左移
            {
                -- l;
                ++ cnt[typ[l]];
                now = max(now,cnt[typ[l]] * a[l]);
            }
            ans[id] = now;
            //撤销操作，对于不在同一个块内的询问，左端点可能是乱序的，需要使左端点左移在撤销
            while(l < rb[k] + 1)
            {
                -- cnt[typ[l]];
                l ++ ;
            }
            now = tmp;
        }
    }
    for(int i=1;i<=m;i++)
        cout << ans[i] << endl;
}
```

##### [只删不加的回滚莫队](https://www.cnblogs.com/Parsnip/p/10969989.html#3719129404)

长度为`n`的数组，`m`次询问，每次询问一个区间内最小没有出现过的自然数。
维护桶中出现过的数字，那么`mex`即是询问答案，删点操作容易实现，可以顺带更新答案，但是加点操作，原来的最小值在加点的过程中出现了，无从得知新的答案，显然，一开始将整个序列加入桶中并统计答案是可行的，只删不加的回滚莫队。
撤销操作还是在桶中更新，但不管答案的变化即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define _ ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define endl '\n'
#define int long long 
const int N = 2e5 + 10,M = 1020;
int n,m;
int a[N],cnt[N],mi,ans[N];
int cnt1[N],ans1,ble[N],L[N],R[N];
struct query
{
    int l,r,id;
    bool operator<(query w)
    {
        return (ble[l] ^ ble[w.l] ? ble[l] < ble[w.l] : r > w.r);
    }
}q[N];
// 删点
inline void remove(int p,int &Minval) 
{
    if ( a[p] > n+1 ) return;
    cnt[a[p]]--;
    if ( cnt[a[p]] == 0 ) Minval = min( Minval , a[p] );
}
// 撤销
inline void resume(int p)
{
    if ( a[p] > n+1 ) return;
    cnt[a[p]]++;
}
void solve()
{
    cin >> n >> m;
    for(int i=1;i<=n;i++)   
        cin >> a[i];
    for(int i=1;i<=m;i++)
    {
        cin >> q[i].l >> q[i].r;
        q[i].id = i;
    }
    //将整个序列加入莫队中，同时得到整体的答案
    for(int i=1;i<=n;i++)
        if(a[i] <= n + 1)
            cnt[a[i]] ++;
    while(cnt[ans1]) ans1 ++;
    //分块
    int size = sqrt(n);
    int bnum = n / size;
    for(int i=1;i<=bnum;i++)
    {
        if(i * size > n) break;
        L[i] = (i - 1) * size + 1;
        R[i] = i * size;
        for(int j=L[i];j<=R[i];j++)
            ble[j] = i;
    }
    R[bnum] = n;
    //比较
    sort(q + 1,q + 1 + m);
    int l = 1,r = n,last = 0;
    for(int i=1;i<=m;i++)
    {
        //处理同一区间的询问
        if(ble[q[i].l] == ble[q[i].r])
        {
            for(int j=q[i].l;j<=q[i].r;j++)
                if(a[j] <= n + 1) cnt1[a[j]] ++;
            int tmp = 0;
            while(cnt1[tmp]) tmp ++;
            ans[q[i].id] = tmp;
            for(int j=q[i].l;j<=q[i].r;j++)
                if(a[j] <= n + 1) cnt1[a[j]] --;
            continue;
        }
        //如果移动到了一个新的块
        if(ble[q[i].l] ^ last)
        {
            while(r < n) resume( ++ r);
            while(l < L[ble[q[i].l]]) remove(l ++,ans1);
            mi = ans1,last = ble[q[i].l];
        }
        //单调移动右端点
        while(r > q[i].r) remove(r -- ,mi);
        //移动左端点回答询问
        int tmp = mi,ll = l;
        while(ll < q[i].l) remove(ll ++ ,tmp);
        //回滚
        while(ll > l)   resume(--ll);
        ans[q[i].id] = tmp;
    }
    for(int i=1;i<=m;i++)
        cout << ans[i] << endl;

}
```

#### 莫队算法的扩展 --- 树上莫队

问题一 : 子树统计

- 在原树上跑一遍dfs序,发现一颗子树其实就是里面的一段固定区间,边跑dfs边弄子树对应的左右端点即可,这里序列的长度 = 结点的个数,实际上不必用莫队,只需要传个标记即可,复杂度O(nlogn)

![树上莫队](./../Images/%E6%A0%91%E4%B8%8A%E8%8E%AB%E9%98%9F.jpg)

问题二 : 路径上的统计   --- [洛谷COT2 - Count on a tree II](https://www.luogu.com.cn/problem/SP10707)

![树上莫队欧拉序](./../Images/%E6%A0%91%E4%B8%8A%E8%8E%AB%E9%98%9F%E6%AC%A7%E6%8B%89%E5%BA%8F.jpg)

- 求的是 u 到 v 上有多少不同的整数,由于区间没有对应关系,所以普通的dfs序不行,这里需要用到欧拉序(特殊的dfs序,可以解决很多dfs序不能解决的问题),详细见欧拉序总结讲解,这里用的是第一种欧拉序,求树上莫队,
- 子树 : 第一种欧拉序上两个相同编号(X),之间所有的编号都出现两次,且都位于 X 子树上,
- 两点之间的路径 : 设每个点第一次最后一次出现的位置为first[x],last[x],那么对于路径x -> y,设 f[x] <= f[y] (不满足swap,均是简写),这个操作的意义在于,**如果x,y在一条链上**,则 x 一定是 y 的祖先或者等于 y,如果lca(x,y)=x,**则直接把 ( f[x],f[y] ) 的区间**扯过来用,**反之使用 ( l[x],f[y] )区间,**(不用f[x]到l[x]的路径是因为中间的点一定不在路径上,里面的点都出现过两次,但是求路径的时候我们需要找的是出现奇数次的点),**但这个区间内不包括lca(x,y),故需要最后加上**(不在同一条链上)

```c++
//由于无需考虑的点会出现两次，我们可以弄一个标记数组（标记结点是否被访问），没访问就加，访问过就删，每次操作把标记·异或个1，完美解决所有添加、删除、去双问题。
#include<bits/stdc++.h>
using namespace std;
#define maxn 200200
#define isdigit(x) ((x) >= '0' && (x) <= '9')
inline int read() {
	int res = 0;
	char c = getchar();
	while(!isdigit(c)) c = getchar();
	while(isdigit(c)) res = (res << 1) + (res << 3) + (c ^ 48), c = getchar();
	return res;
}
int aa[maxn], cnt[maxn], first[maxn], last[maxn], ans[maxn], belong[maxn], inp[maxn], vis[maxn], ncnt, l = 1, r, now, size, bnum; //莫队相关
int ord[maxn], val[maxn], head[maxn], depth[maxn], fa[maxn][30], ecnt;
int n, m;
struct edge {
	int to, next;
} e[maxn];
void adde(int u, int v) {
	e[++ecnt] = (edge){v, head[u]};
	head[u] = ecnt;
	e[++ecnt] = (edge){u, head[v]};
	head[v] = ecnt;
}
void dfs(int x) {//欧拉序的第一种写法求子树和树上莫队常用,由于结合LCA,将父节点存了下来,所以不需要再传入父节点,调用即可.
	ord[++ ncnt] = x;
	first[x] = ncnt;
	for(int k = head[x]; k; k = e[k].next) {
		int to = e[k].to;
		if(to == fa[x][0]) continue;//f[x][0]表示当前的点的第一个父节点
		depth[to] = depth[x] + 1;
		fa[to][0] = x;
		for(int i = 1; (1 << i) <= depth[to]; ++i) fa[to][i] = fa[fa[to][i - 1]][i - 1];//LCA,倍增写法
		dfs(to);
	}
	ord[++ ncnt] = x;
	last[x] = ncnt;
}
int getlca(int u, int v) {//LCA倍增思路,依据二进制不断上跳求最近公共祖节点
	if(depth[u] < depth[v]) swap(u, v);
	for(int i = 20; i + 1; --i) //先跳深度,将深度尽量压缩到一个小范围,
		if(depth[u] - (1 << i) >= depth[v]) u = fa[u][i];
	if(u == v) return u;
	for(int i = 20; i + 1; --i)//在跳父节点,判断每个点对应的二进制下的父节点是否相同.
		if(fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i];
	return fa[u][0];
}
struct query {
	int l, r, lca, id;
} q[maxn];
int cmp(query a, query b) {
	return (belong[a.l] ^ belong[b.l]) ? (belong[a.l] < belong[b.l]) : ((belong[a.l] & 1) ? a.r < b.r : a.r > b.r);
}
void work(int pos) {//因为节点最多出现一次,第一次出现时记作加,先计算个数在对数量修改,此时为后件,此后被标记为1,再出现减去,注意两种++, -- 的顺序不一样,因为计算的时候改变导致,仔细理解
	vis[pos] ? now -= !--cnt[val[pos]] : now += !cnt[val[pos]]++;
	vis[pos] ^= 1;//标记数组(标记节点是否被访问过,没访问过就加,访问过就删,每次操作标记 ^ 1)
}
int main() {
	n = read(); m = read();
	for(int i = 1; i <= n; ++i) 
		val[i] = inp[i] = read();
	sort(inp + 1, inp + n + 1);
	int tot = unique(inp + 1, inp + n + 1) - inp - 1;
	for(int i = 1; i <= n; ++i)
		val[i] = lower_bound(inp + 1, inp + tot + 1, val[i]) - inp;
	for(int i = 1; i < n; ++i) adde(read(), read());
	depth[1] = 1;
	dfs(1);
	size = sqrt(ncnt), bnum = ceil((double) ncnt / size);
	for(int i = 1; i <= bnum; ++i)//分块操作
		for(int j = size * (i - 1) + 1; j <= i * size; ++j) belong[j] = i;
	for(int i = 1; i <= m; ++i) {
		int L = read(), R = read(), lca = getlca(L, R);
		if(first[L] > first[R]) swap(L, R);
		if(L == lca) {//在同一条链上
			q[i].l = first[L];
			q[i].r = first[R];
		}
		else {
			q[i].l = last[L];
			q[i].r = first[R];
			q[i].lca = lca;
		}//注意存进结构体的是位置不是节点值,遍历的是两个位置之间的节点值
		q[i].id = i;
	}
	sort(q + 1, q + m + 1, cmp);//排序优化莫队
	for(int i = 1; i <= m; ++i) {
		int ql = q[i].l, qr = q[i].r, lca = q[i].lca;
		while(l < ql) work(ord[l++]);//区间删除
		while(l > ql) work(ord[--l]);//区间添加
		while(r < qr) work(ord[++r]);//区间添加
		while(r > qr) work(ord[r--]);//区间删除
		if(lca) work(lca);//这里的区间添加删除只是对于区间长度来说,对于答案的贡献需要判断是第一次出现还是第二次出现,
		ans[q[i].id] = now;
		if(lca) work(lca);
	}
	for(int i = 1; i <= m; ++i) cout << ans[i] << endl;
	return 0;
}
```

### 树状数组

```cpp
struct node 
{
	int n;
	vector<int> tr;
	void reset(int m)
	{
		n = ; // 赋值需要按照情况给定
		tr.resize(n + 1);//常数加一是为了防止将数据映射到 0，树状数组需要从 1 开始
	}
	void add(int u,int c)//加一是将模树整体右移一位，不能见 0
	{
		for(int i=u ;i<=n;i+=lowbit(i))// u 节点根据给定判断是否需要偏移,树状数组下标必须 > 1
			tr[i] += c;
	}
	int query(int u)
	{
		int res = 0;
		for(int i=u ;i;i-=lowbit(i))
			res += tr[i];
		return res;
	}
	int ask(int l,int r) 
	{
		return query(r) - query(l - 1);
	} 
}tr[21];
tr[d].reset(d);
```

#### 单点修改区间求和

```cpp
const int N = 2e5 + 10;//树状数组维护的是值不是坐标
int a[N];//原数组
int tr[N];//表示树状数组,表示y=i的高度出现了几次,树状数组tr本身存的就是前缀和,基于二进制跳动前缀和,不是常规前缀和
int great[N],lower[N];
int n; 
int lowbit(int x)
{
	return x & -x;
}//返回最后一个1及后面的0
void add(int x,int c)//在x的位置加上c
{
	for(int i=x;i<=n;i+=lowbit(i))//基于二进制前缀和,除了第一个读入的数据,存到 10,100,110,1000这种整二进制类型
		tr[i] += c;
}
int sum(int x)//查询操作
{
	int res = 0;
	for(int i=x;i;i-=lowbit(i))//前缀和,tr的子节点的求法,计算常规前缀和.
		res += tr[i];
	return res;	
}
int main()//树状数组中存的是高度出现次数的前缀和,不是区间下标
{
	_;
	cin >> n;
	for(int i=1;i<=n;i++)//对应的y
		cin >> a[i];
	for(int i=1;i<=n;i++)//先从左向右算一遍
	{
		int y = a[i];//下为前缀和求区间和,因为是全排列,所以最大为 n, y - 1的差值,为区间和
		great[i] = sum(n) - sum(y);//高度大于等于y + 1里面有多少数
		lower[i] = sum(y - 1);//高度为 1 到 y - 1 (包含)里面有多少数
		add(y,1);
	}
	memset(tr,0,sizeof tr);
	ll res1 = 0,res2 = 0;
	for(int i=n;i;i--)//倒序求出来 V 型 和 ^ 型
	{
		int y = a[i];
		res1 += great[i] * (ll)(sum(n) - sum(y));
		res2 += lower[i] * (ll)sum(y - 1);
		add(y,1);
	}
	cout << res1 << " " << res2 << endl;
    return 0;
}
```

#### 区间修改单点求和

树状数组维护的是差分,树状数组 tr 记录的是差分的前缀和,即是当前元素(基于二进制,需要转换为前缀和)

```cpp
const int N = 1e5 + 10;
int n,m,a[N];//原数组
int tr[N];//差分数组,树状数组维护的前缀和是基于lowbit,二进制的最后一位 1 所代表的大小所跳动的,不是基于 1 
int lowbit(int x)
{
    return x & -x;
}
void add(int x,int c)
{
    for(int i=x;i<=n;i+=lowbit(i))
        tr[i] += c;
}
ll sum(int x)//求和
{
    ll res = 0;
    for(int i=x;i;i-=lowbit(x))
        res += tr[i];
    return res;
}
int main()
{
    _;
    cin >> n >> m ;
    for(int i=1;i<=n;i++)
       cin >> a[i];//先读入原数组
    for(int i=1;i<=n;i++)
        add(i,a[i] - a[i -1]);//转换为差分数组
    while(m --)
    {
        char op[2]  ;
        int l,r ,d;
        cin >> op >> l;
        if(op[0] == 'C')
        {//修改区间,利用差分的性质,修改 l 和 r+1 两个位置即可,tr 求的二进制下的前缀和
            cin >> r >> d;
            add(l,d),add(r+1,-d);   
        }
        else
            cout << sum(l) << endl;/需要将二进制转换为常规前缀和 
    }
    return 0;
}
```

#### 求逆序对

```cpp
//直接插入 a[i] 的写法 add(a[i],1)，正序遍历
pre(i,1,n)
{//m 是数组中的最大值
    ans = query(m) - query(a[i]);// x 表示当前枚举到的数，query(m) 表示总数,query(x) 表示小于等于 x 的数，得逆序数,如果数据较大可能需要离散化 a 数组，此时 传入的 a[]就是离散化后的数组，m是离散化后的数组大小 ！！！！
    add(a[i],1);   
}
for(int i=1;i<=n;i++)//不涉及离散化这种也可以，涉及离散化还是上面好
{
    scanf("%d",&temp);
    add(temp);
    result += i - query(temp);
}
```

删除部分数 , 使得区间逆序对个数大于 `k` 求方案数

```cpp
void solve()//首先明确一点这题 r 右移左端点也一定右移，左端点一定是递增的不会减少
{
    cin >> n >> k;
    int tot = 0,ans = 0,m = 1e6;//tot 是当前删除区间外的逆序对数
    pre(i,1,n)
    {
        cin >> a[i];
        add(a[i],1,tr1);
        tot += query(m,tr1) - query(a[i],tr1);
    }
    if(tot >= k) ans ++;
    int l = 1,r = 1;
    while(r <= n)//由于 r 是递增的所以 删除的时候一定删除的是逆序对，前面比这个点小的数一定在
    {//遍历前就删除完了
        add(a[r],-1,tr1);//将这个点删除
        tot -= query(a[r] - 1,tr1) + query(m,tr2) - query(a[r],tr2);//这个点产生的逆序对，删除的区间中的逆序对个数
        while(tot < k && l <= r)
        {
            add(a[l],1,tr2);//tot 小了，需要右移 l 指针来增加 tot，
            tot += query(m,tr2) - query(a[l],tr2);
            tot += query(a[l] - 1,tr1);//代表把 l 加入到数组中，前面比 a[l]小的所有数逆序对加一
            l ++;
        }
        ans += r - l + 1;
        r ++ ;
    }
    cout << ans << endl;
}
```

### 线段树

#### 二维树状数组 , 给定每维第二维的大小

```cpp
struct segment_tree
{
#define ls (p << 1)
#define rs (p << 1 | 1)
    int tr[maxn << 3], n;
    void push_up(int p)
    {
        tr[p] = min(tr[ls], tr[rs]);
    }
    void build(int p, int l, int r)
    {
        if (l == r)
        {
            tr[p] = *S[l].begin();
            return;
        }
        int mid = (l + r) >> 1;
        build(ls, l, mid);
        build(rs, mid + 1, r);
        push_up(p);
    }
    void build(int _n)
    {
        n = _n;
        build(1, 1, n);
    }
    void print(int p, int l, int r)
    {
        printf("%d[%d,%d] %d\n", p, l, r, tr[p]);
        if (l == r)
            return;
        int mid = (l + r) >> 1;
        print(ls, l, mid);
        print(rs, mid + 1, r);
    }
    void print() { print(1, 1, n); }
    void modify(int p, int l, int r, int id, int x)
    {
        if (l == r)
        {
            tr[p] = x;
            return;
        }
        int mid = (l + r) >> 1;
        if (id <= mid)
            modify(ls, l, mid, id, x);
        else
            modify(rs, mid + 1, r, id, x);
        push_up(p);
    }
    int query(int p, int l, int r, int L, int R)
    {
        if (L <= l && r <= R)
        {
            return tr[p];
        }
        int mid = (l + r) >> 1, ans = 1e9;
        if (mid >= L)
            ans = min(ans, query(ls, l, mid, L, R));
        if (mid + 1 <= R)
            ans = min(ans, query(rs, mid + 1, r, L, R));
        return ans;
    }
#undef ls
#undef rs
} tr;
```



#### 单点修改区间查询

```cpp
int search(int i,int l,int r){ //求区间和
    if(tree[i].l >= l && tree[i].r <= r)//如果这个区间被完全包括在目标区间里面，直接返回这个区间的值
        return tree[i].sum;
    if(tree[i].r < l || tree[i].l > r)  return 0;//如果这个区间和目标区间毫不相干，返回0
    int s = 0;
    if(tree[i * 2].r >=l )  s += search(i * 2 ,l,r);//如果这个区间的左儿子和目标区间又交集，那么搜索左儿子
    if(tree[i * 2 + 1].l <= r)  s += search(i * 2 + 1,l,r);//如果这个区间的右儿子和目标区间又交集，那么搜索右儿子
    return s;
}
int query(int u,int l,int r)//u是当前节点,求区间最大值
{
    if(tr[u].l >= l && tr[u].r <= r)
        return tr[u].v;//树中节点已经被完全包含在[l,r]中,v 即是区间的最大值
    int mid = tr[u].l + tr[u].r >> 1;
    int v = 0;
    if(l <= mid)//和左边有交集
        v = query(u << 1,l,r);//左端点不需要取max,右端点自己max即可更新答案
    if(r > mid) //和右边有交点
        v = max(v,query(u << 1 | 1,l,r));
    return v;
}
//单点修改
void modify(int u,int x,int v)//单点修改 把a[x]的值修改为v,进行加减操作可以
{
    if(tr[u].l == x && tr[u].r == x)//如果找到叶节点直接修改
        tr[u].v  = v;
    else  //否则判断到底是往左递归还是往右递归
    {
        int mid = tr[u].l + tr[u].r >> 1;//取中点
        if(x <= mid)
            modify(u << 1,x,v);
        else modify(u << 1 | 1,x,v);//u << 1 | 1 等价于u << 1 + 1,位移运算符操作后,某位肯定为 0, | 1表示加1
        //递归完成后，当前节点最大值信息一定要记得更新
        pushup(u);//从下往上回溯更新信息
        //pushup函数需要根据具体要求实现tr[u].v = max(tr[u << 1].v,tr[u << 1 | 1].v);区间最大值的写法
    }
}
```

#### 求区间子段最大和（最小和取负)  -- 线段树上二分

```cpp
#include<bits/stdc++.h>//求区间子段最大和(连续),结构体中加入最大前缀和和最大后缀和,最大连续子段和
using namespace std;
const int N = 5e5 + 10;
int n,m;
int w[N];
struct Node
{
    int l,r;
    int sum,lmax,rmax,tmax;//区间和,最大前缀和,最大后右缀和,最大连续子段和
}tr[N * 4];
void pushup(Node &u,Node &l,Node &r)//自己(父节点),左儿子,右儿子
{
    u.sum = l.sum + r.sum;//左和 = 左和加右和
    u.lmax = max(l.lmax,l.sum + r.lmax);//左边前缀和=max(左边前缀,左边和加右边前缀)
    u.rmax = max(r.rmax,r.sum + l.rmax);//右边后缀=max(右边后缀,右边和+左边后缀)
    u.tmax = max(max(l.tmax,r.tmax),l.rmax + r.lmax);//总的最大值=max未横跨两个区间最大和,左儿子的最大后缀和和右儿子的最大前缀和
}
void pushup(int u)//儿子节点向上更新父亲节点
{
    pushup(tr[u],tr[u << 1],tr[u << 1 | 1]);
}
void build(int u,int l,int r)
{
    if(l == r)
        tr[u] = {l,r,w[r],w[r],w[r],w[r]};//子段中最少包含一个数,不能为0
    else
    {
        tr[u] = {l,r};
        int mid = l + r >> 1;
        build(u << 1,l,mid),build(u << 1 | 1,mid + 1,r);
        pushup(u);
    }
}
int modify(int u,int x,int v)
{
    if(tr[u].l == x && tr[u].r == x)//这个点是叶子节点
        tr[u] = {x,x,v,v,v,v};
    else
    {
        int mid = tr[u].l + tr[u].r >> 1;
        if(x <= mid) //单点修改最后只会落到一个区间内,不会有重叠.
            modify(u << 1,x,v);
        else 
            modify(u << 1 | 1,x,v);
        pushup(u);
    }
}
Node query(int u,int l,int r)
{
    if(tr[u].l >= l && tr[u].r <= r)//在区间内部直接返回
        return tr[u];
    else 
    {
        int mid = tr[u].l + tr[u].r >> 1;
        if(r <= mid) 
            return query(u << 1,l,r);//完全在左边
        else if(l > mid) return query(u << 1 | 1,l,r);//完全在右边
        else //在左右两边的
        {
            auto left = query(u << 1,l,r);
            auto right = query(u << 1 | 1,l,r);
            Node res;
            pushup(res,left,right);
            return res;
        }
    }
}
int main()
{
    _;
    cin >> n >> m;
    for(int i=1;i<=n;i++)
        cin >> w[i];
    build(1,1,n);
    int k,x,y;
    while(m --)
    {
        cin >> k >> x >> y;
        if(k == 1)//表示查询
        {
            if(x > y) swap(x,y);
            cout << query(1,x,y).tmax << endl;//求[x,y]中的区间和 从根节点开始递归
        }
        else modify(1,x,y);//更改操作将将A[x]该为y,从根节点开始递归
    }
    return 0;
}//5 3  1 2 -3 4 5  1 2 3  2 2 -1  1 3 2  -- > 2  -1
```

#### 区间最大公约数

父区间的最大公约数 = 两个子区间的最大公约数在取最大公约数  ---> 转换为差分,将区间修改转换为点, `gcd(x , y , z) = gcd(x ,y - x ,z - y)`,存储差分数组,并且区间加减一个数也可以转换为差分对单点的修改,故转换为单点修改区间查询.

```cpp
struct Node
{
    int l,r;
    ll sum,d;
}tr[N * 4];
ll gcd(ll a,ll b)
{
    return b ? gcd(b,a % b) : a;
}
void pushup(Node &u,Node &l,Node &r)//算左右两边的信息
{//节点和两个儿子
     u.sum = l.sum + r.sum;
     u.d = gcd(l.d,r.d);
}
void pushup(int u)
{
    pushup(tr[u],tr[u << 1],tr[u << 1 | 1]);
}
void build(int u,int l,int r)
{
    if(l == r)
    {
        ll b = w[r] - w[r-1];//存进去的是差分数组,由辗转除法可知,两数的最大公约数和一个数与两数差的最大公约数一致
        tr[u] = {l,r,b,b}; 
    }
    else 
    {
        tr[u].l = l,tr[u].r = r;
        int mid = l + r >> 1;
        build(u << 1,l,mid),build(u << 1 | 1,mid + 1,r);
        pushup(u);
    }
}
void modify(int u,int x,ll v)
{
    if(tr[u].l == x && tr[u].r == x)
    {
        ll b = tr[u].sum + v;
        tr[u] = {x,x,b,b};
    }
    else 
    {      
        int mid = tr[u].l + tr[u].r >> 1;
        if(x <= mid)    
            modify(u << 1,x,v);
        else modify(u << 1 | 1,x,v);
        pushup(u);
    }
}
Node query(int u,int l,int r)
{
    if(l > r) return {0};
    if(tr[u].l >= l && tr[u].r <= r)    
        return tr[u];//在区间内部
    else
    {        
        int mid = tr[u].l + tr[u].r >> 1;
        if(r <= mid) return query(u << 1,l,r);//都在左半边
        else if(l > mid) return query(u << 1 | 1,l,r);
        else 
        {
            auto left = query(u << 1,l,r);
            auto right = query(u << 1 | 1,l,r);
            Node res;
            pushup(res,left,right);
            return res;
        }
    }
}
int main()
{
    _;
    cin >> n >> m;
    for(int i=1;i<=n;i++)
        cin >> w[i];
    build(1,1,n);
    int l,r;
    ll d;
    char op[2];
    while(m --)
    {    
        cin >> op >> l >> r;
        if(*op == 'Q')//查询
        {
            auto left = query(1,1,l);///求1到l的前缀和
            auto right = query(1,l + 1,r);//最大公约数
            cout << abs(gcd(left.sum,right.d)) << endl;//防止结果中有负数返回正的
        }  //(x,y,z) = (x,y-x,z-y)括号最大公约数 gcd(a[l],gcd(b[l+1],b[r]))
        else 
        {
            cin >> d;
            modify(1,l,d);
            if(r + 1 <= n) 
                modify(1,r + 1,-d);//差分数组的修改
        }
    }
}//5 5  1 3 5 7 9  Q 1 5  C 1 5 1  Q 1 5  C 3 3 6  Q 2 4  -- > 1 2 4
```

#### 加 乘混合懒标记

```cpp
void pushup(int u)
{
    tr[u].sum = (tr[u << 1].sum + tr[u << 1 | 1].sum) % p;
}
void eval(Node &t,int add,int mul)//对这个区间的改变,更新sum和懒标记
{                           //区间内的每个数都要加
    t.sum = ((ll)t.sum * mul +(ll)(t.r - t.l + 1) * add) % p;
    t.mul = (ll)t.mul * mul % p;//乘法直接将乘数直接相乘即可
    t.add = ((ll)t.add * mul + add) % p;//加法,需要先将原来的加数项乘于传入的乘数在加上传入的加数
}  
void pushdown(int u)    
{
    eval(tr[u << 1],tr[u].add,tr[u].mul);//先将根节点的懒标记传到儿子身上
    eval(tr[u << 1 | 1],tr[u].add,tr[u].mul);
    tr[u].add = 0,tr[u].mul = 1;//传到子儿子后,根节点的懒标记清空
}// modify 中的修改操作调用的也是 eval 函数
```

#### 权值线段树 -  $区间\ k\ 值$

```cpp
//建树
#define ls tr[u << 1]
#define rs tr[u << 1 | 1]
void build(int u,int l,int r)
{
	tr[u] = {l,r,0};
	if(l == mid)
	{
		tr[u] = a[l];//a[l] 表示数 l 有多少个
		return ;
	}
	build(u << 1,l,mid);
	build(u << 1 | 1,mid +1,r);
	pa = mer(ls,rs);	
}
//修改
void modify(int u,int l,int r,int cnt)//表示数 k 的个数多 cnt 个 l==r=k
{
	if(pa.l == pa.r)
	{
		pa.cnt += cnt;
		return ;
	}
	int mid = pa.l + pa.r >> 1;
	if(l <= mid)
		modify(u << 1,l,r,cnt);
	if(r > mid)
		modify(u << 1 | 1,l,r,cnt);
	pa = mer(ls,rs,pa.l,pa.r);
	
}
//查询
node query(int u,int l,int r)//查询数 l 有多少个 l==r
{
	if(pa.l >= l && pa.r <= r)
		return pa;
	int mid = pa.l + pa.r >> 1;
	node res = {-1,-1};
	if(l <= mid)
		res = mer(res,query(u << 1,l,r),-1,-1);
	if(r > mid)
		res = mer(res,query(u << 1 | 1,l,r,res.l,res.r);
	return res;
}
//查询第 k 值
int kth(int u,int l,int r,int k)
{
	if(l == r) 
		return l;
	int mid = l + r >> 1;
    int Ln = sum[u << 1];//左儿子中有多少数据
    int Rn = sum[u << 1 | 1];//有儿子中有多少数据
	if(k <= Rn)
		return kth(u << 1 | 1,mid + 1,r,k);
	else return kth(u << 1,l,mid,k - Rn);
}
```

#### 扫描线

```cpp
#define maxn 300
int lazy[maxn << 3];  // 标记了这条线段出现的次数
double s[maxn << 3];
struct node1 {
  double l, r;
  double sum;
} cl[maxn << 3];  // 线段树
struct node2 {
  double x, y1, y2;
  int flag;
} p[maxn << 3];  // 坐标
// 定义sort比较
bool cmp(node2 a, node2 b) { return a.x < b.x; }
// 上传
void pushup(int rt) {
  if (lazy[rt] > 0)
    cl[rt].sum = cl[rt].r - cl[rt].l;
  else
    cl[rt].sum = cl[rt * 2].sum + cl[rt * 2 + 1].sum;
}
// 建树
void build(int rt, int l, int r) {
  if (r - l > 1) {
    cl[rt].l = s[l];
    cl[rt].r = s[r];
    build(rt * 2, l, (l + r) / 2);
    build(rt * 2 + 1, (l + r) / 2, r);
    pushup(rt);
  } else {
    cl[rt].l = s[l];
    cl[rt].r = s[r];
    cl[rt].sum = 0;
  }
  return;
}
// 更新
void update(int rt, double y1, double y2, int flag) {
  if (cl[rt].l == y1 && cl[rt].r == y2) {
    lazy[rt] += flag;
    pushup(rt);
    return;
  } else {
    if (cl[rt * 2].r > y1) update(rt * 2, y1, min(cl[rt * 2].r, y2), flag);
    if (cl[rt * 2 + 1].l < y2)
      update(rt * 2 + 1, max(cl[rt * 2 + 1].l, y1), y2, flag);
    pushup(rt);
  }
}
int main() {
  int temp = 1, n;
  double x1, y1, x2, y2, ans;
  while (scanf("%d", &n) && n) {
    ans = 0;
    for (int i = 0; i < n; i++) {
      scanf("%lf %lf %lf %lf", &x1, &y1, &x2, &y2);
      p[i].x = x1;
      p[i].y1 = y1;
      p[i].y2 = y2;
      p[i].flag = 1;
      p[i + n].x = x2;
      p[i + n].y1 = y1;
      p[i + n].y2 = y2;
      p[i + n].flag = -1;
      s[i + 1] = y1;
      s[i + n + 1] = y2;
    }
    sort(s + 1, s + (2 * n + 1));  // 离散化
    sort(p, p + 2 * n, cmp);  // 把矩形的边的横坐标从小到大排序
    build(1, 1, 2 * n);       // 建树
    memset(lazy, 0, sizeof(lazy));
    update(1, p[0].y1, p[0].y2, p[0].flag);
    for (int i = 1; i < 2 * n; i++) {
      ans += (p[i].x - p[i - 1].x) * cl[1].sum;
      update(1, p[i].y1, p[i].y2, p[i].flag);
    }
    printf("Test case #%d\nTotal explored area: %.2lf\n\n", temp++, ans);
  }
  return 0;
}
```

## 图论

### 树的直径

#### $dfs + dfs $

#### 边权使用 

求边权或者直径端点 , 直径信息的时候使用

```cpp
const int N = 10000 + 10;
int n, c, d[N];
vector<int> E[N];
void dfs(int u, int fa) {
  for (int v : E[u]) {
    if (v == fa) continue;
    d[v] = d[u] + 1;
    if (d[v] > d[c]) c = v;
    dfs(v, u);
  }
}
int main() {
  cin >> n;
  for (int i = 1; i < n; i++) {
    int u, v;
    cin >> u >> v;
    E[u].push_back(v), E[v].push_back(u);
  }//使用vector的方式存树.
  dfs(1, 0);
  d[c] = 0, dfs(c, 0);
  cout << d[c] << endl;
  return 0;
}
```

#### $dp$

##### 边权

```cpp
// 边权代码
const int N = 10000 + 10;

int n, d = 0;
int dp[N];
vector<int> E[N];

void dfs(int u, int fa) {
  for (int v : E[u]) {
    if (v == fa) continue;
    dfs(v, u);
    d = max(d, dp[u] + dp[v] + 1);
    dp[u] = max(dp[u], dp[v] + 1);
  }
}

int main() {
  scanf("%d", &n);
  for (int i = 1; i < n; i++) {
    int u, v;
    scanf("%d %d", &u, &v);
    E[u].push_back(v), E[v].push_back(u);
  }
  dfs(1, 0);
  printf("%d\n", d);
  return 0;
}
```

##### 点权

```cpp
void dfs(int u,int fa)
{
	for(auto L : g[u])
	{
		if(L == fa) continue;
		dfs(L,u);
		c = max(c,dp[u] + dp[L] + (d[u] - 1) * (qmi(2,m) - 1) + 1);//后续表示的是 u 节点的权值，即是边权中的边权
		dp[u] = max(dp[u],dp[L]);//这里不加表示的是将dp[u]更新为子树L向u扩展时所能提供的最大直径，最后递归结束之后在更新 u 节点的贡献
	}//
	dp[u] += (d[u] - 1) * (qmi(2,m) - 1) + 1;
}
pair<int,int> dp1[N],p;//有两个关键字的点权直径
void dfs1(int u,int fa)
{
	for(auto L : g[u])
	{
		if(L == fa) continue;
		dfs1(L,u);
		p = max(p,{dp1[u].first + dp1[L].first + (d[u] - 1),dp1[u].second + 1 + dp1[L].second});
		dp1[u] = max(dp1[u],dp1[L]);
	}
	dp1[u].first += (d[u] - 1);
	dp1[u].second += 1;
}
```

#### 处理出直径

```cpp
bool mark(int u,int fa)//判断直径上的点    u 起始传入的是另一个直径的端点
{
    if(u == en)// 直径的终点
    {
        st[u] = 1;
    }
    for(auto L : g[u])
    {
        if(L == fa) continue;
        st[u] = max(st[u],mark(L,u));
    }
    return st[u];
}
```

### 树的重心

如果在树中选择某个节点并删除，这棵树将分为若干棵子树，统计子树节点数并记录最大值。取遍树上所有节点，使此最大值取到最小的节点被称为整个树的重心。 即是  把这个点删去后,剩余**联通块中点最大值最小**,满足这个条件的点是树的重心.

-   树的重心如果不唯一，则至多有两个，且这两个重心相邻。
-   以树的重心为根时，所有子树的大小都不超过整棵树大小的一半。
-   树中所有点到某个点的距离和中，到重心的距离和是最小的；如果有两个重心，那么到它们的距离和一样。
-   把两棵树通过一条边相连得到一棵新的树，那么新的树的重心在连接原来两棵树的重心的路径上。
-   在一棵树上添加或删除一个叶子，那么它的重心最多只移动一条边的距离。

```cpp
const int N = 100010,M = N*2;//删除树中的一个点，使得剩下的连通块中点数最大值的最小值
vector<int> g[N];
bool st[N];//idx存的是边
int ans = N;//最小的最大值
int dfs(int u)//以u为根的子树中点的数量
{
	st[u] = true;//标记一下，这点点已经被搜过了
	int sum = 1,res = 0;//res是每一个连通块的最大值
	for(auto j : g[u])
	{
		if(!st[j]) 
		{
			int s = dfs(j);//可能会分为多个连通块 
			res = max(res,s);//把这个点删除后每一个联通块点的最大值
			sum += s;//这个连通块一共多少点算上当前u
		}  //相减的剩下的点数
	} //n - sum 代表这个指向这个点的连通块点数
	res = max(res,n-sum);//被删除的连通块和剩下的连通块
	ans = min(ans,res);
	return sum;
}
int main()
{ 
	cin >> n;
	for(int i=0;i<n-1;i++)
	{
		int a,b;
		cin >> a >>b;
		g[u].push_back(v),g[v].push_back(u);
	}
	dfs(1);//从第一个节点开始深搜-搜的是图的节点编号
	cout << ans << endl;
}
```

### 拓扑排序

```cpp
bool topsort()   //如果是有向图,环内的元素就是更新后度数为不为 0 的点(为1),如果是有向图,环内的元素就是更新后度数不为 1 的点,如果不加bool数组,可能导致端点遍历过后被其他端点继续遍历,导致度数重复错误的相减,例如无向图度数可能减为 0 ,但实际上拓扑后最小为 1 
{
    pre(i,1,n)
        if(d[i] == 1)//入度为 1 的点入队
            q.push(i),st[i] = 1;//bool数组标记
    while(q.size())
    {
        auto t = q.front();
        q.pop();
        for(int i=h[t];~i;i=ne[i])
        {
            int j = e[i];
            if(st[j]) continue;
            d[j] --;
            if(d[j] == 1)
                q.push(j),st[j] = 1;
        }
    }
    return q.size() == n;//true代表无环,否则代表有环,不在队列内的点构成一个环
}
```

### 最短路

#### 单源正权最短路  --- Dijkstra

> - 堆优化的 Dijkstra 算法,-mlogn,找到目前权值最小的点,用这个点更新其他点到根节点的权值,直至堆为空.

```c++
int dijkstra()
{
	memset(dist,0x3f,sizeof dist);
	dist[1]=0;
	priority_queue<PII,vector<PII>,greater<PII>> heap;//小根堆
	heap.push({0,1});//将起点放进去
	while(heap.size())//堆是空的
	{
		auto t = heap.top();//小根堆，堆顶就是最小值
		heap.pop();
		int ver = t.second,distance = t.first;
		if(st[ver]) continue;//这个点是冗余备份，即这个点已经处理过了 
		st[ver] = 1; 
		for(int i=h[ver];i!=-1;i=ne[i])
		{
			int j = e[i];
			if(dist[j] > distance + w[i])
			{
				dist[j] = distance + w[i];
				heap.push({dist[j],j});
                  pre[j] = i;//前驱数组,用于求出最短路径
			}
		}
	}
	if(dist[n] == 0x3f3f3f3f) return -1;//图是不连通的
	return dist[n]; 
}
void find(int x)	//递归输出最短路径,起点是dij算法的起始点
{
	if (pre[x] == 1) 
		cout << 1;
	else 
		find(pre[x]);
	cout << " -> " << x;
	return;
}
for (int i = 2; i <= G.vex; i++)
{
    cout << "起点 v1 到 v" << i << " 的路径为： ";
    find(i);
    cout << endl;
}
```

#### 在矩阵中 Dijkstra 算法，矩阵不能过大

[图式Dijkstra](https://ac.nowcoder.com/acm/problem/268703)

定义小根堆的时候`priority_queue<array<int,3>,vector<array<int,3>>,greater<array<int,3>> q` 分别表示距离，起点和终点，后续即是常规算法

```cpp
void dijkstra(int x,int y,vector<string> &mp,vector<vector<int>> &d,vector<vector<int>> &st)
{
    priority_queue<array<int,3>,vector<array<int,3>>,greater<array<int,3>>> q;
    q.push({0,x,y});//(x,y)到当前起点距离是 0 
    st[x][y] = 1;
    d[x][y] = 0;
    while(q.size())
    {
        auto [dis,a,b] = q.top();
        q.pop();
        for(int i=0;i<4;i++)
        {
            int nx = a + dx[i],ny = b + dy[i];
            if(nx >= 0 && nx < n && ny >= 0 && ny < m && !st[nx][ny])
            {
                st[nx][ny] = 1;
                d[nx][ny] = min(d[nx][ny],d[a][b] + (mp[nx][ny] - '0'));
                q.push({d[nx][ny],nx,ny});
            }
        }
    }
}
```

#### 单源负权最短路 ---- Spfa    --- 	求 负环

```c++
int spfa()//st 数组和Dijk 的区别是Dijk只遍历一遍,Spfa是判断当前点是否在队列里,需要时时更新
{//如果没有负环,点最多出现 n 次,因为使用的是更新最短距离所以没有负环的情况下每个点最多出现一次
    memset(dist,0x3f,sizeof dist);//判断负环时不必将距离初始化为0x3f3f3f3f;判断最短路需要初始化,并且不需要cnt数组
	queue<int> q;
	for(int i=1;i<=n;i++)//最短路不需要,只需要找起点入队,更新st[起点]即可
	{//判断存在负环，但不一定是1经过负环，任意一个起点都有可能
		st[i] = 1;
		q.push(i);
	}
	while(q.size())
	{
		int t = q.front();//代表从t到j点有边
		q.pop();
		st[t] = 0;
		for(int i=h[t];i!=-1;i=ne[i])
		{
			int j = e[i];
			if(dist[j] > dist[t] + w[i])
			{
				dist[j] = dist[t] + w[i];
				cnt[j] = cnt[t] + 1;
				if(cnt[j] >= n) return 1;//存在负环,判断最短路的时候不能加
				if(!st[j])
				{
					q.push(j);
					st[j] = 1;
				}
			}
		}
	}
	return 0;//表示不存在负环
}
```

#### Spfa 算法 判断是否存在正环

求正环的问题可以转换为求负环的问题,只是边点权重的分配不同。同时也可以直接转换为求某点的最长路，加上一定的经验，**当点的入队次数超过最多点的2倍时，认为图中存在正环**，没有正环的情况下，入队肯定不会超过2倍，

最短路与最长路的区别  ：

```c++
//最短路
if(dist[j] > distance + w[i])//只有可以使边权变小才会更新
{
    dist[j] = distance + w[i];
    heap.push({dist[j],j});
}
//最长路 
if(dist[j] < dist[t] + wf[t] - mid * wt[i]) //只有可以使边权变大才会更新,边更新变大
```

- 01 分数规划 + 最长路 问题
- L 个点，P 条边的有向图，每个点都有一个权值 f[i] ，每条边都有一个权值 t[i]，求图中的一个环，使环上各点的权值之和 / 环上各边的权值之和最大   ------>  01 分数规划，点权和边权都存在，可以将点权放到边权上，出边入边都可，由此转换为 $\sum\text{fi - mid * }\sum\text{ti>0 }\Longrightarrow\sum\text{ (fi - mid * ti)\ >\ 0}.$，输出的是结果的最大值。对于点权 f[i] 将它附到出边上，即是 f[i] 实际上是下标为 i 的边的出发点的点权，如果重定义每个边的权值为( f[i] - mid * t[i] )，那么问题转换为转换为**权值后的图中是否存在正环**。

```c++
 const int N = 1010,M = 5010;
 int n,m;
 int wf[N];
 int h[N],e[M],wt[M],ne[M],idx;
 double dist[N];
 int q[N],cnt[N];
 bool st[N];
void add(int a,int b,int c)
{
	e[idx] = b,ne[idx] = h[a],wt[idx] = c,h[a] = idx ++;
}
bool check(double mid)
{
	//memset(dist,0,sizeof dist);最长路问题可以不用初始化,因为如果存在环一定会不断地更新,初始化与否不重要
	memset(st,0,sizeof st);
	memset(cnt,0,sizeof cnt);
	int hh = 0,tt = 0;//循环队列
	for(int i=1;i<=n;i++)
	{
		q[tt ++] = i;
		st[i] = true;
	}
	while(hh != tt)
	{
		int t = q[hh ++];
		if(hh == N) hh = 0;
		st[t] = false;
		for(int i=h[t];~i;i=ne[i])
		{
			int j = e[i];
			if(dist[j] < dist[t] + wf[t] - mid * wt[i])
			{//最长路：边更新变大，与最短路相反
				dist[j] = dist[t] + wf[t] - mid * wt[i];
				cnt[j] = cnt[t] + 1;
				if(cnt[j] >= n) return true;//正环一定可以使得满足条件
				if(!st[j])
				{
					q[tt ++] = j;
					if(tt == N) tt = 0;
					st[j] = true;
				}
			}
		}
	}
	return false;//因为题目要求的是环中的结果,所以如果没有正环,则代表一定不成立,收缩右值
}//false 包括没有达成环,和没有正环
int main()
{
	_;
	cin >> n >> m;
	memset(h,-1,sizeof h);
	for(int i=1;i<=n;i++)
		cin >> wf[i];
	while(m --)
	{
		int a,b,c;
		cin >> a >> b >> c;
		add(a,b,c);
	}
	double l = 0,r = 1010;//二分答案
	while(r - l > 1e-4)
	{
		double mid = (l + r) / 2;//mid 是二分答案,找到答案的值
		if(check(mid)) l = mid;
		else r = mid;
	}
	cout << r << endl;
	return 0;
}
```

- 单词环   前面两个字母和后面两个字母相同时，可以连接在一起，求单词环的平均长度，即是 wi 表示单词的长度，si 表示单词的个数

  $\sum\text{wi}/\sum\textbf{si 最大,}\sum\text{wi}/\sum\text{1>M , }\Rightarrow\sum\text{(Mi-M}*1)>0\Rightarrow $ 图中是否存在正环，判断无解的时候只需要判断 M = 0 的时候即可。

  等价于将前两个字母和后两个字母哈希为两个数，表示从前面的数到后面的数建一条边，最多26 * 26 = 676 个点

  ```c++
  const int N = 700,M = 100010;//点的数量，边的数量
  int n;
  int h[N],e[M],w[M],ne[M],idx;
  double dist[N];
  int q[N],cnt[N];
  bool st[N];
  void add(int a,int b,int c)
  {
  	e[idx] = b,w[idx] = c,ne[idx] = h[a],h[a] = idx ++;
  }
  bool check(double mid)
  {
  	memset(st,0,sizeof st);//dist 可以不初始化,因为如果存在正环会不断的更新距离,一定会进入if判断
  	memset(cnt,0,sizeof cnt);
  	int hh = 0,tt = 0;
  	for(int i=0;i<676;i++)
  	{
  		q[tt ++] = i;
  		st[i] = true;
  	}
  	int count = 0;	
  	while(hh != tt)
  	{
  		int t = q[hh ++];
  		if(hh == N) hh = 0;
  		st[t] = false;
  		for(int i=h[t];~i;i=ne[i])
  		{
  			int j = e[i];
  			if(dist[j] < dist[t] + w[i] - mid * 1)
  			{//最长路：边更新变大，与最短路相反
  				dist[j] = dist[t] + w[i] - mid;
  				cnt[j] = cnt[t] + 1;
  				if(++ count > 2 * n) return true;//点更新的次数大于2*n经验上就是存在正环
  				if(cnt[j] >= N) return true;
  				if(!st[j])
  				{
  					q[tt ++]  =j;
  					if(tt == N) tt = 0;
  					st[j] = true;
  				}
  			}
  		}
  	}
  	return false;
  }
  int main()
  {
  	_;
  	char  str[1010];
  	while(cin >> n,n)
  	{
  		memset(h,-1,sizeof h);
  		idx = 0 ;
  		for(int i=0;i<n;i++)
  		{
  			cin >> str;
  			int len = strlen(str);
  			if(len >= 2)
  			{
  				int left = (str[0] - 'a') * 26 + str[1] - 'a';//将前两个字母哈希为数值
  				int right = (str[len - 2] - 'a') * 26 + str[len - 1] - 'a';//将后两个字母哈希为数值
  				add(left,right,len);//前两个字母和后两个字母间建边,权值是字符长度
  			}
  		}
  		if(!check(0)) cout << "NO solution" << endl;//判断无解
  		else 
  		{
  			double l = 0,r = 1000;//二分答案
  			while(r - l > 1e-4)
  			{
  				double mid = (l + r) / 2;
  				if(check(mid)) l = mid ;
  				else r = mid;
  			}
  			cout << r << endl;
  		}
  	}
  	return 0;
  }//3   intercommunicational   alkylbenzenesulfonate   tetraiodophenolphthalein ---> 0
  ```


### 多源最短路 -- floyd

```c++
void floyd()
{
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)//这样的循环顺序可以保证后面的数据更新是
				d[i][j]=d[j][i]=min(d[i][j],d[i][k]+d[k][j]);//用到的前面的数据是更新过的
}//读入的时候需要去重边,保存较小的边
if(d[a][b]>INF/2) puts("impossible");//图不连通,判断的时候不能直接用INF,可能有负权边
```

### $dfs$ 序 欧拉序

[dfs序和欧拉序 - Styx-ferryman - 博客园 (cnblogs.com)](https://www.cnblogs.com/stxy-ferryman/p/7741970.html)

#### dfs 序

![树的dfs序](./../Images/%E6%A0%91%E7%9A%84dfs%E5%BA%8F.png)

树的DFS序列,也就是树的深搜索,他的概念是 : 树的每一个节点在深度优先遍历中进出栈的时间序列.树的DFS序,简单来说就是对树从根开始深搜,按搜到的时间顺序把所有的节点排队,上图的一个DFS序就是 : ` 1 4 6 6 3 9 9 3 4 7 7 2 5 5 8 8 2 1`,**树的DFS序不是唯一的**,对于一棵树进行DFS序,需要把回溯的时候的节点编号也记录一下,于是每个数字会出现两次,DFS序的长度是 2 * N,**一个数字出现两次的位置所夹的区间正好是以这个数为根的一个子树**,例如`2 8 8 5 5 2`,子树是285      (大部分都认为DFS序每个节点都直会出现一次,出现两次的是欧拉序,这里直接归到DFS序里面,方便比较)

- DFS序的性质和应用 : 把一颗子树放到一个区间里,这个性质把树状结构变成了线性结构.我们只需要在这个线性结构上进行区间修改区间查询,而不需要遍历整颗子树来做到区间修改和区间查询,主要用于树链剖分

```c++
const int maxn=1e5+10;//部分DFS序解释每个节点只出现过一次,只需要加一个st数组即可,按照两次统计能快速解决子树问题
int n;
int idx,e[maxn<<1],ne[maxn<<1],h[maxn];
int id[maxn],cnt;
stack<int> st;
void add(int x,int y)
{
    e[idx] = y,ne[idx] = h[x],h[x] = idx ++;
}
void dfs(int x,int f)
{
    id[++ cnt] = x;
    for(int i=h[x];~i;i=ne[i])
    {
        int y = e[i];
        if(y == f)
            continue;
        dfs(y,x);
    }
    id[++ cnt] = u;//访问到叶子节点了,或者回溯之后当前节点所有的节点遍历过了,将当前节点在加入id一次
//如果一个点只需要出现一次的时候这个不必加上,这个主要是叶子节点和树遍历完毕dfs之后没有子节点进不去for循环再加一个叶子节点一共两次。
}
int main()
{
    cin >> n;
    fill(h,h + 1 + n,-1);
    for(int i=1;i<n;i++)
    {
        int x,y;
        cin >> x >> y;
        add(x,y),add(y,x);
    }
    dfs(1,0);
    for(int i=1;i<=cnt;i++)
        cout << id[i] << " ";
    return 0;
}
```

#### 时间戳

- 概念 : 按照深度优先遍历的过程,按每个节点第一次被访问的顺序,依次给予这些节点 1 - N 的标记,这个标记就是时间戳
- DFS序的概念是按照深度优先搜索时间顺序的节点编号序列,数组下标存的是时间 ; 时间戳是按照深搜时间顺序的时间编号序列.数组下标是节点编号,也就是 id[i] = x,其中 i 是时间,x 是节点,id 是DFS序,dfn[x] = i,i 是时间,x 是节点,dfn 是时间戳.两者有点互为反函数的意思,在tarjan算法中也有所体现.

#### 欧拉序

- 定义 : 从根节点出发回到根节点为止,按深度优先遍历的顺序所经过的所有点的顺序.

![欧拉序](./../Images/%E6%AC%A7%E6%8B%89%E5%BA%8F.png)

这个图的一个欧拉序就是 : `1 2 8 2 5 2 1 7 1 4 3 9 3 4 6 4 1`,与DFS序类似欧拉序同样不唯一,并且性质 : 每个点在欧拉序中出现的次数等于这个点的度数,因为DFS到的时候加进一次,回去的时候也加进. 所以总点数是 `n + n - 1 = 2 * n - 1`,`n` 个点,`n - 1` 条边; 

```c++
#include<bits/stdc++.h>
using namespace std;
vector<int> g[40010];
int len,a[80020];
void dfs(int u,int fa)
{
    a[++ len] = u;//先入欧拉序
    int sz = g[u].size();
    for(int i=0; i<sz; i++)
    {
        if(g[u][i] != fa)
        {
            dfs(g[u][i],u);
            a[++ len] = u;//非递归到叶节点, 叶子节点没有子节点所以不会进入for循环，叶子节点只会记录一次，在一条路递归结束一次之后会一次进行这一步操作，保证回溯的时候对应的节点记录上。实现了 1 2 8 2 5 2 1 ... 的效果,相当于从下往上走,叶子结点直接入欧拉序一次
        }
    }
}
int main()
{
    int t;
    cin >> t;
    while(t--)
    {
        int n,m;
        len = 0;
        memset(a,0,sizeof(a));
        cin >> n;
        for(int i=1; i<=n; i++)
            g[i].clear();
        for(int i=1; i<=n-1; i++)
        {
            int a,b;
            cin >> a >> b;
            g[a].push_back(b);
            g[b].push_back(a);
        }
        dfs(1,0);
        for(int i=1;i<=len;i++)
            cout << a[i] << " ";
    }
}
```

##### 求欧拉序,子树信息

```cpp
int dep[NN], seq[NN], fir[NN], idx, L[NN], R[NN], cnt,
inline void DFS(CI now = 1, CI fa = 0)
{
    seq[++idx] = now;//欧拉序中的节点信息
    dep[now] = dep[fa] + 1;
    fir[now] = idx;//映射关系,节点在欧拉寻中的对应编号
    L[now] = ++cnt; // 当前子树的左节点
    for (auto to : v[now])
        if (to != fa)
            DFS(to, now), seq[++idx] = now;
    R[now] = cnt;//当前子树的右节点
}
```



##### 欧拉序求树上LCA

- 欧拉序主要用于求LCA问题,也即是将树上的LCA问题转换为区间的RMQ问题(最值),根据欧拉序的性质,两个点第一次出现的位置之间一定有它们的LCA,并且LCA一定是这个区间中深度最小的点,所以预处理时,就可以将树上的LCA问题变成两个节点在欧拉序中深度最小值RMQ

![欧拉序求LCA](./../Images/%E6%AC%A7%E6%8B%89%E5%BA%8F%E6%B1%82LCA.png)

```cpp
namespace LCA_Solver
{
	const int NN = 200005;
	int dep[NN], seq[NN], fir[NN], idx, L[NN], R[NN], cnt, mxd[NN][20], _log[NN];
	inline void DFS(CI now = root, CI fa = 0)// root 指定的根
	{
		seq[++idx] = now;//欧拉序对应数组
		dep[now] = dep[fa] + 1;
		fir[now] = idx;//数组对应欧拉序
		L[now] = ++cnt; // 欧拉序 , 子树的左端点
		for (auto to : v[now])
			if (to != fa)
				DFS(to, now), seq[++idx] = now;
		R[now] = cnt;//子树的右端点
	}
	inline int mindep(CI x, CI y) // 寻找 LCA
	{
		return dep[x] < dep[y] ? x : y;
	}
	inline void init_RMQ(CI n) // ST 预处理祖先
	{
		_log[0] = -1;
		for (RI i = 1; i <= n; ++i)
			_log[i] = _log[i >> 1] + 1;
		for (RI i = 1; i <= n; ++i)
			mxd[i][0] = seq[i];
		for (RI j = 1; (1 << j) <= n; ++j)
			for (RI i = 1; i + (1 << j) - 1 <= n; ++i)
				mxd[i][j] = mindep(mxd[i][j - 1], mxd[i + (1 << j - 1)][j - 1]);
	}
	inline int LCA(int x, int y)//利用 ST 表快速找到祖先
	{
		x = fir[x];
		y = fir[y];
		if (x > y)
			swap(x, y);
		int k = _log[y - x + 1];
		return mindep(mxd[x][k], mxd[y - (1 << k) + 1][k]);
	}
}
using namespace LCA_Solver;//正常使用即可 
DFS();
init_RMQ(idx);//多组数据记得初始化
//对 两点 lca 进行操作 , 和求取 以 x 为根的子树的信息
pre(i, 1, 100000) 
{
    for (auto [x, y] : vec[i])					// lcm 为 i 的加上
        if(y <= n) // 需要修改部分
            tr.add(L[LCA(x,y)], (x == y ? 1 : 2)); // 将lca为i的子树上加上答案
    for (auto [x, id] : q[i])
        ans[id] = tr.ask(L[x], R[x]);//需要修改部分
}
```



#### 两种写法的欧拉序及dfs序总结

![欧拉序总结](./../Images/%E6%AC%A7%E6%8B%89%E5%BA%8F%E6%80%BB%E7%BB%93.png)

1. 欧拉序 : 1 2 4 4 5 5 2 3 6 6 7 7 3 1         时间戳 : 1 2 3 3 5 5 2 8 9 9 11 11 8 1      节点数量为 2 * N

-  树上任意一点 x 的子树,在**第一次出现 **x 和**最后一次出现** x 之间的所有出现的数,另外有个性质是这些出现的次数和为偶数,
-  树上任意两点 x 和 y,路径上的点,为**最后一个** x 到**第一个** y 之间,出现奇数次的数,另外加上**lca**,例如:4 到 7 的树上路径,截取为4 5 5 2 3 6 6 7,出现奇次的数字为4 2 3 7,加上lca=1,故树上路径的最终节点是 4 2 1 3 7
-  两点之间的路径 : 设每个点第一次最后一次出现的位置为first[x],last[x],那么对于路径x -> y,设 f[x] <= f[y] (不满足swap,均是简写),这个操作的意义在于,如果x,y在一条链上,则 x 一定是 y 的祖先或者等于 y,如果lca(x,y)=x,则直接把 ( f[x],f[y] ) 的区间扯过来用,反之使用 ( l[x],f[y] )区间,(不用f[x]到l[x]的路径是因为中间的点一定不在路径上,里面的点都出现过两次,但是求路径的时候我们需要找的是出现奇数次的点),但这个区间内不包括lca(x,y),故需要最后加上
-  通常将树上问题,转换为区间问题求解,比如:树上莫队,求解树链上不同数的个数等等.

```c++
void dfs(int u) {
	sa[++tim] = u;//欧拉序列数组
	dfn[u] = tim;//时间戳数组
	for (son...) dfs(son);
	sa[++tim] = u;//访问到叶节点直接将叶节点入数组,或者一个节点的字节点完全被访问结束再入这个节点一次.
}
```

2. 欧拉序 : 1 2 4 2 5 2 1 3 6 3 7 3 1          时间戳 : 1 2 3 2 5 2 1 8 9 8 11 8 1,       节点数量为 2 * N - 1

- 树上任意一点的子树为,第一次出现 x和最后一次 x之间出现的所有数,出去本节点的数,例如 : 2 的子树,截取为 2 4 2 5 2,除去节点为4 5
- 树上任意两点x和y,两点的**lca**,为**第一次**出现 x 和**第一次**出现 y 区间内,**时间戳最小**的那个值,例如 : 4到7的lca,截取为4 2 5 2 1 3 6 3 7,这里的时间戳是指第一次进入节点的时间,时间戳为3 2 5 2 1 8 9 8 11,时间戳最小的是1,.找到 1 对应的节点即可
- 通常用于求 LCA,结合ST表,在O(1)的时间求解LCA,适合频繁求LCA的问题. 

```c++
void dfs(int u) {//一笔不断遍历整棵树,每个节点出现的次数
	sa[++tim] = u;
	dfn[u] = tim;
	for (son...) {
		dfs(son);
		sa[++tim] = u;
	}
}
```

3. DFS序 : 1 2 4 5 3 6 7     时间戳 : 1 2 3 4 5 6 7,仅进入节点的时候记录,

- 树上任意点 x 的子树包括x,为当前第一次出现 x 的位置到往后 sz[x] 个节点的区间,sz[x] 表示dfs时计算的以 x 为根的树大小,假设 sz[x]包含了x,例如 : 2的子树,sz[2]=3,那么截取为2 4 5,如果不包含x,取x往后,区间大小为sz[x]-1即可,即是4 5
- 树上两点x 和 y 的 LCA,需要配合树链剖分,将树链变成一块块连续的序列
- 通常结合树链剖分等进行维护树上链上的信息,比如 : 给某条链全部节点加上 1 ,求解最大值最小值.

```c++
void dfs(int u) {
	sa[++tim] = u;
	dfn[u] = tim;
	for (son...) dfs(son);
}
```

### 树链剖分

**树剖**是指通过**轻重边**剖分将树分割成多条链，然后利用数据结构来维护这些链（本质是一种优化暴力）

明确定义 ：

- 重儿子 ： 父亲节点的所有儿子中子树节点数目最多（size最大）的结点；
- 轻儿子 ： 父亲节点中除了重儿子以外的儿子；
- 重边 ： 父亲节点和重儿子连成的边；
- 轻边 ： 父亲节点和轻儿子连成的边；
- 重链 ： 由多条重边连接而成的路径；
- 轻链 ： 由多条轻边连接而成的路径。                             

![树链剖分1图](./../Images/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%861%E5%9B%BE.png)

```cpp
//变量声明
int f[N],d[N],si[N],son[N],rk[N],top[N],id[N];
//数组依次是 ：f[N] 保存节点 u 的父亲节点  ；d[N] 保存节点 u 的深度 ；si[N] 保存以 u 为根的子树大小 ；son[N] 保存重儿子 ；rk[N] 保存当前 dfs标号在树中所对应的节点 ；top[N] 保存当前节点所在链的顶端节点 ；id[N] 保存树中每个节点剖分以后得新编号（DFS的执行顺序）
```

1、对于一个点我们首先求出它所在的子树大小，找到他的重儿子（即处理出size，son数组）

2、在`dfs`过程中顺便记录其父亲以及深度（即处理出`f，d`数组），操作1,2可以一次`dfs`实现。

```cpp
void dfs(int u,int fa,int dep)//当前节点，父节点，深度
{
    f[u] = fa;
    d[u] = dep;
    si[u] = 1;//点本身先记一个size
    for(int i=h[u];~i;i=ne[i])
    {
        int j = e[i];
        if(j == fa) continue;
        dfs(j,u,dep + 1);//层数加一
        si[u] += si[j];//更新父节点的size
        if(si[j] > si[son[u]])
            son[u] = j;//更新重儿子
    }
}
dfs(root,0,1);
```

![树链剖分2](./../Images/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%862.png)

3、第二遍`dfs`，然后连接重链，同时标记每一个节点的`dfs序`,并且为了用数据结构来维护重链，在`dfs`时保证一条重链上各个节点`dfs序`连续（即处理出数组`top,id,rk`）

```cpp
void dfs2(int u,int t)//当前节点，重链顶端
{
    top[u] = t;
    id[u] = ++ cnt;//标记dfs序
    rk[cnt] = u;//序号 cnt 对应节点 u 
    if(!son[u]) return ;
    dfs2(son[u],t);
    //选择优先进入重儿子来保证一条重链上各个节点 dfs序连续，一个点和他的重儿子处于同一条重链，所以重儿子所在重链顶端还是 t
    for(int i=h[u];~i;i=ne[i])
    {
        int j = e[i];
        if(j != son[u] && j != f[u])//不是重儿子，不是父节点，当前点一定是新的重链，top即是j，从j接着dfs2,
            dfs2(j,j);//一个点位于轻链底端，那么它的top必然是自身，，，，例如 2,3 点
    }
}
```

![树链剖分3](./../Images/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%863.png)

4、两遍`dfs`就是树链剖分的主要处理，通过`dfs`我们已经保证一条重链上各个节点`dfs`序连续，可以通过数据结构（例如线段树）来维护一条重链的信息。

性质：

- 如果（u，v)是一条轻边，那么`size(v)  < size(u) / 2`
- 从根节点到任意节点的路所经过的轻重链的个数必定都小于`logn`，时间复杂度为`O(nlog^2n)`

 [树链剖分模版](https://www.luogu.com.cn/problem/P3384)

一共 4 个操作，1、将树从`x`到`y`结点最短路径上所有节点的值都加上`z`；  2、表示求树从`x`到`y`结点最短路径上所有节点值之和；  3、表示将以`x`为根节点的子树内所有节点值都加上`z` ； 4、表示求以`x`为根节点的子树所有节点值之和。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define _ ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define endl '\n'
#define int long long 
#define len(u) (tr[u].r - tr[u].l + 1)//！！！括号一定要加！！！
#define pa tr[u]
#define ls tr[u << 1]
#define rs tr[u << 1 | 1]
const int N = 2e5 + 10;
int h[N],e[N << 1],ne[N << 1],idx;//建图，本题的最短路径是节点数最少，边权均为 1，类似LCA，top
struct tree                       //实现快速跳跃，不断的寻找在同一条重链上的两点
{
    int l,r,sum,lazy;
}tr[N << 2];
int n,m,r,rt,mod;
int a[N];
int f[N],dep[N],son[N],si[N],top[N],id[N],rk[N],cnt;//dfs树链剖分使用
void add(int a,int b)
{
    e[idx] = b,ne[idx] = h[a],h[a] = idx ++;
}
void dfs1(int u,int fa)
{
    si[u] = 1;
    f[u] = fa;
    dep[u] = dep[fa] + 1;
    for(int i=h[u];~i;i=ne[i])
    {
        int j = e[i];
        if(j == fa) continue;
        dfs1(j,u);
        si[u] += si[j];
        if(si[j] > si[son[u]])
            son[u] = j;
    }
}
void dfs2(int u,int tp)
{
    top[u] = tp,id[u] = ++ cnt,rk[cnt] = u;
    if(!son[u])
        return ;
    dfs2(son[u],tp);
    for(int i=h[u]; ~i;i=ne[i])
    {
        int j = e[i];
        if(j != son[u] && j != f[u])
            dfs2(j,j);
    }
}
void pushup(int u)
{
    pa.sum = (ls.sum + rs.sum) % mod;
}
void build(int u,int l,int r)
{
    if(l == r)
        tr[u] = {l,r,a[rk[l]] % mod,0};//注意这里需要将对应的dfs序的时间戳转换为原数组的值
    else 
    {
        tr[u] = {l,r,0,0};
        int mid = l + r >> 1;
        build(u << 1,l,mid);
        build(u << 1 | 1,mid + 1,r);
        pushup(u);
    }
}
void pushdown(int u)
{
    ls.lazy = (ls.lazy + pa.lazy) % mod;
    rs.lazy = (rs.lazy + pa.lazy) % mod;
    ls.sum = (ls.sum + (len(u << 1) * pa.lazy % mod)) % mod;
    rs.sum = (rs.sum + (len(u << 1 | 1) * pa.lazy % mod)) % mod;
    pa.lazy = 0;
}
void modify(int u,int l,int r,int c)
{
    c %= mod;
    if(pa.l >= l && pa.r <= r)
    {
        pa.lazy = (pa.lazy + c) % mod;
        pa.sum = (pa.sum + len(u) * c % mod) % mod;
        return ;
    }
    pushdown(u);
    int mid = pa.l + pa.r >> 1;
    if(l <= mid)
        modify(u << 1,l,r,c);
    if(r > mid)
        modify(u << 1 | 1,l,r,c);
    pushup(u);
}
int query(int u,int l,int r)
{
    if(pa.l >= l && pa.r <= r)
    {
        return pa.sum % mod;
    }
    pushdown(u);
    int mid = pa.l + pa.r >> 1,s = 0;
    if(l <= mid)
        s = (s + query(u << 1,l,r)) % mod;
    if(r > mid)
        s = (s + query(u << 1 | 1,l,r)) % mod;
    return s % mod;
}
int sum(int x,int y)
{//注意这里的最短路径是指节点数最少，点有权值，边没有边权，即是每个边的边权均为 1
    int s = 0;
    while(top[x] != top[y])//类似于LCA的功能不断地向上跳x,y，直到x，y在同一条重链上，然后直接计算
    {
        if(dep[top[x]] < dep[top[y]])
            swap(x,y);//不断交换x，y，x向上跳跃，直至共重链即可直接求解区间和
        s = (s + query(1,id[top[x]],id[x])) % mod;
        x = f[top[x]];
    }
    if(id[x] > id[y])
        swap(x,y);//此时x，y在同一条重链上，直接求线段树区间和即可
    return (s + query(1,id[x],id[y])) % mod;
}
void updates(int x,int y,int c)
{
    c %= mod;
    while(top[x] != top[y])
    {
        if(dep[top[x]] < dep[top[y]])
            swap(x,y);
        modify(1,id[top[x]],id[x],c);
        x = f[top[x]];
    }
    if(id[x] > id[y])
        swap(x,y);
    modify(1,id[x],id[y],c);
}
signed main()
{
    _;
    cin >> n >> m >> r >> mod;
    for(int i=1;i<=n;i++)
        cin >> a[i];
    fill(h + 1,h + 1 + n,-1);
    for(int i=1;i<n;i++)
    {
        int u,v;
        cin >> u >> v;
        add(u,v),add(v,u);
    }
    dfs1(r,0);
    dfs2(r,r);
    build(1,1,n);
    for(int i=1;i<=m;i++)
    {
        int op,x,y,k;
        cin >> op;
        if(op == 1)
        {
            cin >> x >> y >> k;
            updates(x,y,k);
         }
        else if(op == 2)
        {
            cin >> x >> y;
            cout << sum(x,y) << endl;
        }
        else if(op == 3)
        {
            cin >> x >> y;
            modify(1,id[x],id[x] + si[x] - 1,y % mod);
        }
        else 
        {
            cin >> x;
            cout << query(1,id[x],id[x] + si[x] - 1) << endl;
        }
    }
}
```

例题

[树的统计](https://www.luogu.com.cn/problem/P2590)

[软件包管理器](https://www.luogu.com.cn/problem/P2146) 本题询问答案的时候直接使用前后差值即可，1表示安装，0表示未安装，-1为初始条件！！！初始**不能**使用 0

 [松鼠的新家](https://www.luogu.com.cn/problem/P3258)

### 最近公共祖先

`dis(x，y) = dis(x)  + dis(y) - 2 * dis(lca)`

#### 倍增加DP $O(nlogn)$

```cpp
int e[N],ne[N],h[500010],idx;
void add(int a,int b)
{
    e[idx] = b,ne[idx] = h[a],h[a] = idx ++;
}
int dp[500010][20];//用来保存父节点,表示第 2^j 个祖先是 x 
int depth[500010]; //保存深度 
bool st[500010];//预处理出父亲切点 
void DFS(int k)
{
	//预处理出DP数组
	for(int i=1;(1<<i)<depth[k];i++)//小于是因为 0 也是一个父节点，即一个距离已经被占用
		dp[k][i] = dp[dp[k][i-1]][i-1];
	for(int i=h[k];i;i=ne[i])
    {
        int j = e[i];
		//求解直接公共祖先；
		if(st[j]) continue;
		st[j] = true; 
		depth[j] = depth[k]+1;
		dp[j][0] = k;// 2 ^ 0 表示第一个祖先
		DFS(j);
	}
	return; 
} 
int lca(int u,int v)
{
	if(depth[u] < depth[v]) swap(u,v);
	//弹节点 
	int k=log2(depth[u]-depth[v]);//返回的浮点数由int接受等价于__lg,二进制最后一个 1 是第几位
	for(int i=k;i>=0;i--)
		if(depth[dp[u][i]]>=depth[v])u=dp[u][i];
	if(u == v)
        return u;
	//查询
	k = log2(depth[u]);//返回的是浮点数,但是int接受直接下取整
	for(int i=k;i>=0;i--)
    {
		if(dp[u][i] == dp[v][i])
            continue;
		u = dp[u][i];
		v = dp[v][i];
	} 
	return dp[u][0];
}
int main()
{
	//LCA模板题
	int n,m,s;
	cin >> n >> m >> s;
	int u,v;
	for(int i=0;i<n-1;i++)
    {
		cin >> u >> v;
		add(u,v),add(v,u);
	} 
	//这里要初始化为1，避免与深度为0的0产生歧义。 
	depth[s] = 1;
	st[s] = true;
	DFS(s);
	for(int i=0;i<m;i++)
    {
		cin >> u >> v;
		cout << lca(u,v) << endl;
	}
	return 0;
} 
```

#### 欧拉序转换为 RMQ $O(nlgn)$

```cpp
namespace LCA_Solver
{
	const int NN = 200005;
	int dep[NN], seq[NN], fir[NN], idx, L[NN], R[NN], cnt, mxd[NN][20], _log[NN];
	inline void DFS(CI now = root, CI fa = 0)// root 指定的根
	{
		seq[++idx] = now;//欧拉序对应数组
		dep[now] = dep[fa] + 1;
		fir[now] = idx;//数组对应欧拉序
		L[now] = ++cnt; // 欧拉序 , 子树的左端点
		for (auto to : v[now])
			if (to != fa)
				DFS(to, now), seq[++idx] = now;
		R[now] = cnt;//子树的右端点
	}
	inline int mindep(CI x, CI y) // 寻找 LCA
	{
		return dep[x] < dep[y] ? x : y;
	}
	inline void init_RMQ(CI n) // ST 预处理祖先
	{
		_log[0] = -1;
		for (RI i = 1; i <= n; ++i)
			_log[i] = _log[i >> 1] + 1;
		for (RI i = 1; i <= n; ++i)
			mxd[i][0] = seq[i];
		for (RI j = 1; (1 << j) <= n; ++j)
			for (RI i = 1; i + (1 << j) - 1 <= n; ++i)
				mxd[i][j] = mindep(mxd[i][j - 1], mxd[i + (1 << j - 1)][j - 1]);
	}
	inline int LCA(int x, int y)//利用 ST 表快速找到祖先
	{
		x = fir[x];
		y = fir[y];
		if (x > y)
			swap(x, y);
		int k = _log[y - x + 1];
		return mindep(mxd[x][k], mxd[y - (1 << k) + 1][k]);
	}
}
using namespace LCA_Solver;//正常使用即可 
DFS();
init_RMQ(idx);//多组数据记得初始化
//对 两点 lca 进行操作 , 和求取 以 x 为根的子树的信息
pre(i, 1, 100000) 
{
    for (auto [x, y] : vec[i])					// lcm 为 i 的加上
        if(y <= n) // 需要修改部分
            tr.add(L[LCA(x,y)], (x == y ? 1 : 2)); // 将lca为i的子树上加上答案
    for (auto [x, id] : q[i])
        ans[id] = tr.ask(L[x], R[x]);//需要修改部分
}
```

### 树上启发式合并

让高度小的树成为高度较大的树的子树，这个优化可以称为启发式合并算法。

当要维护树中所有以**每个节点为根的子树**的某个值, 而且**以 root 为根的树**的值可以从**以 root 的 son 为根的子树**转移过来.

从叶子向上回溯时更新答案 , 可以是时间复杂度大幅减低 $O(n^2) \ 优化到 O(nlogn)$

先将所有的轻子树全部预处理出来再跑重子树

```cpp
void dfs(int x, int fa) {
    for (auto c : eg[x]) {
        if (c == fa)continue;
        if (c == son[x])continue;
        dfs(c, x); // dfs 跑完所有轻子树内部的答案
        clear(c, x); //注意: 跑完后我们要清空这个轻子树的贡献, 不能影响计算其他轻子树内的贡献.
    }
    if (son[x]) // 计算重子树的答案, 不去clear, 直接保留, 这样就传给了上一层.
        dfs(son[x], x);

    for (auto c : eg[x]) { // 暴力计算所有轻子树的贡献
        if (c == fa)continue;
        if (c == son[x])continue;
        add(c, x);
    }
    if (!num[clo[x]])sum++; // 根节点本身
    num[clo[x]]++;
    ans[x] = sum;
}
```

启发式合并第二种写法 : 保证每次都是小节点更新大节点的信息 , 每次交换后只是暂时使得父节点问题目前是子节点的问题 , 但是后面有一步更新操作, 将小节点的信息重新并到大节点中 , 至此 父节点信息完全更新为加上子节点信息的完整值 , 但是子节点的信息可能就是错误的, 这种写法只能用于子节点计算贡献之后就用不到子节点的信息, 只需要保证父节点的信息正确即可 , 如果需要使用子节点的信息更新贡献 , 则需要在交换之前就计算一下 , 但是只是用于**结论类** , 复杂度一定不能是完全遍历子节点得到的结果 , 否则和暴力一样的复杂度, 等于没有启发式

[CF1923F](https://codeforces.com/contest/1923/problem/E)

```cpp
auto dfs = [&](auto self,int u,int fa) -> void 
{
    dp[u][c[u]] = 1 ;
    for(auto L : g[u])
    {
        if(L == fa) continue;
        self(self,L,u);
        //先计算 u 作为端点的情况 , 下面的 if 就是需要子节点信息计算贡献,但是基本是O(1)的,复杂度较低,可以直接交换
        if(dp[L][c[u]])
        {
            ans += dp[L][c[u]];
            dp[L][c[u]] = 0;//清零,防止对后续操作进行影响,相当于简单路径中间再一次出现了c[u]颜色
        }
        //启发式合并,每个点最多被计算log次
        if(dp[u].size() < dp[L].size())
        {
            dp[u].swap(dp[L]);
        }
        //根节点 u 作为中间节点
        for(auto [x,y] : dp[L])//判断当前子节点中包含的每个颜色 , 完全贡献 父节点 u 的操作
        {//因为没到一个节点,个数都是 1 , 保留的都是离自己最近的
            if(dp[u][x])
                ans += dp[u][x] * dp[L][x];//
            dp[u][x] += dp[L][x];//分配律 , a * x + b * c = (a + b) * c ,直接将前面的信息加一起乘即可 . 
        }
        //注意这种启发式合并的意义是每次都使用最小的子节点更新最大的子节点,这样能保证较小的计算量,
        //但是后续的for循环将L的节点信息重新并到u中了,所以整体来看减少的复杂度,但是信息更新是没有问题的
    }
};
```

#### [子树中有多少颜色不同的点](https://www.luogu.com.cn/problem/U41492)

```cpp
int n,c[N],ans[N],cnt[N],sum;
vector<int> g[N];
int son[N],si[N];//处理出重儿子和 si
void dfs(int u,int fa)//当前节点，父节点，深度
{
    si[u] = 1;//点本身先记一个size
    for(auto j : g[u])
    {
        if(j == fa) continue;
        dfs(j,u);//层数加一
        si[u] += si[j];//更新父节点的size
        if(si[j] > si[son[u]])
            son[u] = j;//更新重儿子
    }
}
void add(int u,int fa)
{
    if(!cnt[c[u]]) sum ++ ;
    cnt[c[u]] ++ ;
    for(auto L : g[u])
    {
        if(L == fa) continue;
        add(L,u);
    }
}
void del(int u,int fa)
{
    -- cnt[c[u]];
    if(cnt[c[u]] == 0) sum -- ;
    for(auto L : g[u])
    {
        if(L == fa) continue;
        del(L,u);
    }
}
void dsu(int u,int fa)
{
    for(auto L : g[u])
    {
        if(L == fa || son[u] == L) continue;//先跳过重儿子
        dsu(L,u);//dfs 跑完所有轻子树内部的答案
        del(L,u);//注意: 跑完后我们要清空这个轻子树的贡献, 不能影响计算其他轻子树内的贡献
    }
    if(son[u]) dsu(son[u],u);//重子树不清空
    for(auto L : g[u])
    {
        if(L == fa || son[u] == L) continue;//先跳过重儿子
        add(L,u);
    }
    if(cnt[c[u]] == 0) sum ++ ;//此步是加上根节点的信息,可以和 add 合并,在add里面加入一个(deep=1&&L==son[u] continue)即可
    cnt[c[u]] ++ ;//更换 add 书写之后将 45 - 51 直接替换为 add(u,fa,1);
    ans[u] = sum;
}
void solve()
{
	cin >> n;
    pre(i,2,n)
    {
        int u,v;cin >> u >> v;
        g[u].push_back(v),g[v].push_back(u);
    }
    pre(i,1,n) cin >> c[i];
    dfs(1,0);
    dsu(1,0);
    int q;cin >> q;
    pre(i,1,q)
    {
        int x;cin >> x;
        cout << ans[x] << endl;
    }
}
```

#### 带清空

```cpp
void dsu(int u,int fa)
{
    for(auto L : g[u])
    {
        if(L == fa || L == son[u]) continue;
        dsu(L,u);
        del(L,u);
        sum = mx = 0;//在这个轻子树清空时,同时清空 mx 和 sum
    }
    if(son[u]) dsu(son[u],u);
    for(auto L : g[u])
    {
        if(L == fa || L == son[u]) continue;
        add(L,u);
    }
    cnt[c[u]] ++ ;
    if(cnt[c[u]] > mx)
        sum = c[u],mx = cnt[c[u]];
    else if(cnt[c[u]] == mx)
        sum += c[u];
    ans[u] = sum;
}
```

### 连通性相关	

- `dfn[x]`: 当前节点的 dfs 序.
- `low[x]`: x 向下搜索能到达的最小 dfs 序.

![割点](../Images/%E5%89%B2%E7%82%B9.png)

- 对于一个有向图。连通分量 ：对于分量中的任意两点 u，v，必然可以从 u 走到 v，且从 v 走到 u 。一般按照DFS的顺序来求解。（强连通分量 ： 极大连通分量）。
- 作用 ：令一个有向图缩点为有向无环图（PAG），也即是拓扑图（缩点指的是将所有的连通分量缩成一个点，即是将环变为点），这样求最短路或者最长路可以直接递推来求解。O（n + m）
- 分类 ： 1、树枝边 ： x  是 y 的一个父节点。2、前向边：x 是 y 的祖先节点。3、后向边：x 是 y 的子节点，不必是直接子节点。4、横叉边：x 和 y 不在同一个分支，由 x 搜到另一个分支的边，这个 y 此时已经被搜过了。
- 解释 : 如果按照DFS从左到右的顺序搜索，由 x 搜到左边的点这时左边的点被搜过是横叉边，如果搜到右边的点，未搜过的，是树枝边。
- 判断 ： 如果一个点在强连通分量（SCC）中：1、存在后向边指向祖先节点（后向边一定向上走）。2、它走到一个横叉边上，且横叉边的点走到了祖先节点。

#### tarjan 求有向图的强连通分量

```cpp
const int Maxn = 1e5 + 10;
//任意两点直接可达
int dfn[Maxn], low[Maxn], dfncnt, s[Maxn], in_stack[Maxn], tp;
int scc[Maxn], sc;  // 结点 i 所在 SCC 的编号
int sz[Maxn];       // 强连通 i 的大小
void tarjan(int u) {//代表第几个点在处理。递归的是点。
    low[u] = dfn[u] = ++dfncnt, s[++tp] = u, in_stack[u] = 1;
    for (int i = head[u]; i; i = eg[i].nex) {
        const int &v = eg[i].to;
        if (!dfn[v]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);//递归出来，比较谁是谁的儿子／父亲，就是树的对应关系，涉及到强连通分量子树最小根的事情。
        } else if (in_stack[v]) {
            low[u] = min(low[u], dfn[v]);//比较谁是谁的儿子／父亲。就是链接对应关系
        }
    }
    if (dfn[u] == low[u]) {//发现是整个强连通分量子树里的最小根。
        ++sc;
        while (s[tp] != u) {
            scc[s[tp]] = sc;
            sz[sc]++;
            in_stack[s[tp]] = 0;
            --tp;
        }
        scc[s[tp]] = sc;
        sz[sc]++;
        in_stack[s[tp]] = 0;
        --tp;
    }
}
 for(int i=1;i<=n;i++) // 可能图不是联通的
         if(!DFN[i])  tarjan(i);//当这个点没有访问过，就从此点开始。防止图没走完
```

#### 双连通分量

**边双连通 ： **在一张联通的无向图中，对于两个点 `u`和`v` 中 , 如果无论删去哪条边(只能删除一条) 都不能使他们不连通 , 称 `u v`边双连通

**点双联通 : **在一张联通的无向图中 , 对于两个点 `u, v`, 如果无论删去哪个点 (只能删去一个 , 且不能删去 `u` 和 `v` ) 都不能使他们不连通 , 称 `u` 和 `v` 点双联通

边双连通**具有**传递性 , 点双联通 **不 具有**传递性

对于一个无向图中的 **极大** 边双连通的子图，我们称这个子图为一个 **边双连通分量**。

对于一个无向图中的 **极大** 点双连通的子图，我们称这个子图为一个 **点双连通分量**。

##### 边双连通

```cpp
const int N = 5e5 + 5, M = 2e6 + 5;
int n, m, ans;
int tot = 1, hd[N];
vector<int> g[N];
bool bz[M << 1];
int bcc_cnt, dfn[N], low[N], vis_bcc[N];
vector<vector<int>> bcc;
void tarjan(int x, int in) {
  dfn[x] = low[x] = ++bcc_cnt;
  for (auto v : g[x]) {
    if (dfn[v] == 0) {
      tarjan(v, i);
      if (dfn[x] < low[v]) bz[i] = bz[i ^ 1] = 1;
      low[x] = min(low[x], low[v]);
    } else if (i != (in ^ 1))
      low[x] = min(low[x], dfn[v]);
  }
}
void dfs(int x, int id) {
  vis_bcc[x] = id, bcc[id - 1].push_back(x);
  for (auto v : g[x]) {
    if (vis_bcc[v] || bz[i]) continue;
    dfs(v, id);
  }
}
void total()
{
  scanf("%d%d", &n, &m);
  int u, v;
  for (int i = 1; i <= m; i++) {
    scanf("%d%d", &u, &v);
    if (u == v) continue;
      g[u].push_back(v),g[v].push_back(u);
  }
  for (int i = 1; i <= n; i++)
    if (dfn[i] == 0) tarjan(i, 0);
  for (int i = 1; i <= n; i++)
    if (vis_bcc[i] == 0) {
      bcc.push_back(vector<int>());
      dfs(i, ++ans);
    }
  printf("%d\n", ans);
  for (int i = 0; i < ans; i++) {
    printf("%llu", bcc[i].size());
    for (int j = 0; j < bcc[i].size(); j++) printf(" %d", bcc[i][j]);
    printf("\n");
  }
}
```

##### 点双连通

1.  两个点双最多只有一个公共点，且一定是割点。
2.  对于一个点双，它在 DFS 搜索树中 dfn 值最小的点一定是割点或者树根。

我们根据第二个性质，分类讨论：

1.  当这个点为割点时，它一定是点双连通分量的根，因为一旦包含它的父节点，他仍然是割点。
2.  当这个点为树根时：
    1.  有两个及以上子树，它是一个割点。
    2.  只有一个子树，它是一个点双连通分量的根。
    3.  它没有子树，视作一个点双。

```cpp
const int N = 5e5 + 5, M = 2e6 + 5;
int n, m;
vector<int> g[N];
int ans;
int dfn[N], low[N], bcc_cnt;
int sta[N], top, cnt;
bool cut[N];
vector<int> dcc[N];
int root;
void tarjan(int u) {
  dfn[u] = low[u] = ++bcc_cnt, sta[++top] = u;
  if (u == root && hd[u] == 0) {
    dcc[++cnt].push_back(u);
    return;
  }
  int f = 0;
  for (auto v : g[x]) {
    if (!dfn[v]) {
      tarjan(v);
      low[u] = min(low[u], low[v]);
      if (low[v] >= dfn[u]) {
        if (++f > 1 || u != root) cut[u] = true;
        cnt++;
        do dcc[cnt].push_back(sta[top--]);
        while (sta[top + 1] != v);
        dcc[cnt].push_back(u);
      }
    } else
      low[u] = min(low[u], dfn[v]);
  }
}

int main() {
  scanf("%d%d", &n, &m);
  int u, v;
  for (int i = 1; i <= m; i++) {
    scanf("%d%d", &u, &v);
    g[u].push_back(v),g[v].push_back(u);
  }
  for (int i = 1; i <= n; i++)
    if (!dfn[i]) root = i, tarjan(i);
  printf("%d\n", cnt);
  for (int i = 1; i <= cnt; i++) {
    printf("%llu ", dcc[i].size());
    for (int j = 0; j < dcc[i].size(); j++) printf("%d ", dcc[i][j]);
    printf("\n");
  }
  return 0;
}
```

#### tarjan 算法求割点

```cpp
// v:当前点 r：本次搜索树的root
void tarjan(ll u, ll r) {
	dfn[u] = low[u] = ++deep;
	ll child = 0;
	for (auto v : g[u]) {
		if (!dfn[v]) {
			tarjan(v, r);
			low[u] = min(low[u], low[v]);
			if (low[v] >= dfn[u] && u != r) cut[u] = 1;//不是根而且他的孩子无法跨越他回到祖先  割点
			if (r == u)child++; //如果是搜索树的根，统计孩子数目
		}
		low[u] = min(low[u], dfn[v]);//已经搜索过了
	}
	if (child >= 2 && u == r)cut[r] = 1;
}
```

#### tarjan 算法求桥

```cpp
void tarjan(int tis, int fa)
{   low[tis] = dfsn[tis] = ++cnt;
    for (auto c : eg[tis]){
        if (!dfsn[c]){
            tarjan(c, tis);
            low[tis] = min(low[c], low[tis]);
             if(low[c]>dfsn[tis]){
                 //(tis,c) is bridge
                 // this，c is 割点   桥一定是割点，割点不一定是桥
             }
        }
        else if(fa!=c)
            low[tis] = min(low[tis], dfsn[c]);//反向边仅在此出现
    }
}
```

#### tarjan缩点

将强连通分量缩成一个点

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e4 + 5;
int n, m, tot, val[N];
vector<int> g[N];
int dfn[N], low[N], co[N], col;
stack<int> stk; // STL并没有慢多少
void Tarjan(int u)
{
    low[u] = dfn[u] = ++tot;
    stk.push(u);
    for (auto v : g[u])
    {
        if (!dfn[v])
        {
            Tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if (!co[v])
        {
            low[u] = min(low[u], dfn[v]);
        }
    }
    //单纯去环型
    if (low[u] == dfn[u])
    {
        co[u] = ++col;
        while (stk.top() != u)
            co[stk.top()] = col, stk.pop();
        stk.pop();
    }
    //环上价值累加型
    // if (low[u] == dfn[u]) {
    //     col++;
    //     while (1) {
    //         int cur = st.top();
    //         co[cur] = col;
    //         vis[cur] = 0;
    //         w[num] += w1[cur];
    //         v[num] += v1[cur];
    //         st.pop();
    //         if (cur == u) break;
    //     }
    // }
}
struct DAG_T//缩点之后建立新的有向无环图的过程
{
    int n, m, tot, val[N];
    vector<int> g[N];
    int f[N], indeg[N], ans = 0;
    bool vis[N];
    void dfs(int u)// 需要结合具体流程修改
    {
        //vis[u] = true;
        //for (auto v : g[u])
        //{
        //    if (!vis[v])
        //        dfs(v);
        //    f[u] = max(f[u], f[v]);
        //}
        //f[u] += val[u];
        //ans = max(ans, f[u]);
    }
    void init()
    {
        memset(val, 0, sizeof(val));
        n = ::col;
        for (int i = 1; i <= ::n; ++i)
        {
            val[::co[i]] += ::val[i];
        }
        for (int i = 1; i <= ::n; ++i)
        {
            for (auto v : g[i])
            {
                if (::co[i] != ::co[v])
                {
                    g[::co[i]].push_back(::co[v]);
                }
            }
        }
    }
    void solve()
    {
        for (int i = 1; i <= n; ++i)
            if ((!indeg[i]) && !(vis[i]))
            {
                dfs(i);
            }
    }
} DAG;
int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; ++i)
        cin >> val[i];
    int u, v;
    for (int i = 1; i <= m; ++i)
        cin >> u >> v,g[u].push_back(v);
    tot = 0;
    for (int i = 1; i <= n; ++i)
        if (!dfn[i])
            Tarjan(i);
    DAG.init();  // 重新建图，此时是一个有向无环图（DAG）
    DAG.solve(); // DFS+DP
    cout << DAG.ans << endl;
}
```

#### 森林缩点连接虚拟节点

```cpp
vector<int> e[N], g[N];
int n, m, cnt = 0, num = 0;
int w1[N], v1[N], dfn[N], low[N], col[N], vis[N], w[N], v[N], in[N];
stack<int> st;
void tarjan(int u) {
    dfn[u] = low[u] = ++cnt;
    vis[u] = 1;
    st.push(u);
    for (auto v : e[u]) {
        if (!dfn[v]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if (vis[v]) {
            low[u] = min(low[u], dfn[v]);
        }
    }
    if (low[u] == dfn[u]) {
        num++;
        while (1) {
            int cur = st.top();
            col[cur] = num;
            vis[cur] = 0;
            w[num] += w1[cur];
            v[num] += v1[cur];
            st.pop();
            if (cur == u) break;
        }
    }
}
void build(int n)//森林缩点 添加一个虚拟节点 形成树
{
    for (int i = 1; i <= n; i++) 
        if (!dfn[i]) tarjan(i);
    for (int i = 1; i <= n; i++) { //建新图的过程 , 有向无环图
        for (auto v : e[i]) {
            int x = col[i], y = col[v];
            if (x != y) {
                g[x].push_back(y);
                in[y]++;
            }
        }
    }
    for (int i = 1; i <= num; i++) {
        if (!in[i]) {// 环
            g[n + 1].push_back(i);
        }
    }
}
```



### 最小生成树

#### Prim - 稠密图 边多 $O(n^2)$

```cpp
int prim()//g数组是邻接矩阵,存的是两点之间的最小边权
{
	memset(dist,0x3f,sizeof dist);
	int res = 0;//最小生成树里面所有边的长度之和
	for(int i=0;i<n;i++)
	{
		int t = -1;
		for(int j=1;j<=n;j++)
			if(!st[j] && (t==-1||dist[t]>dist[j]))
				t = j;
		if(i && dist[t] == INF) return INF;//不是第一个点，并且距离集合最近的点是正无穷，代表不连通
		if(i) res += dist[t];//只要不是第一个点加上距离   dist表示这个点到集合的问题
		for(int j=1;j<=n;j++)//先加和在更新，防止自环
			dist[j] = min(dist[j],g[t][j]);//到集合的距离		
		st[t] = true;
	}
	return res;//t == INF 不连通的图
}
```

#### Kruskal - 稀疏图 边少 $O(mlog n)$

```cpp
struct Edge//结构体存储所有边	
{
	int a,b,w;	
	bool operator< (const Edge &W) const
 	{
		return w < W.w;//重载小于号，方便排序
	}
}edges[N];
int find(int x)
{
	if(p[x] != x) p[x] = find(p[x]);
	return p[x];
}
//核心代码
sort(edges,edges+m);
for(int i=1;i<=n;i++) p[i] = i;
int res = 0,cnt=0;
for(int i=0;i<m;i++)
{
    int a = edges[i].a,b = edges[i].b,w = edges[i].w;
    a = find(a),b = find(b);//并查集找根节点
    if(a!=b) //a b 未连通
    {
        p[a] = b;//合并
        res += w;
        cnt ++;//存了多少条边
    }
}//cnt < n - 1,代表的是图不连通,并查集里面的点小于n个,根节点未计入
```

### 次小生成树

- **非严格次小生成树 :**在无向图中,边权最小的满足边权和 **大于等于** 最小生成树边权的生成树,依次枚举未被选上的边(u->v),找到这条边为端点的最小生成树路径内的边权最大的边,用为选中的边代替权值最大的边,$\ M^{`}\ =\ M\ +\ w\ -\ w^{`}.对所有替换到的答案\ M^{`}\ 取最小值即可$,

- 严格次小生成树 : 边权最小的满足边权和 **严格大于** 最小生成树边权和的生成树.替换的边要严格大于路径中最大边权的权值.

```cpp
const int N = 510,M = 10010;
int n,m;
struct Edge
{
	int a,b,w;
	bool f;//表示是不是非树边
	bool operator<(const Edge &t)const
	{
		return w < t.w;
	}
}edge[M];
int p[N],dist[N][N];
vector<int> g[N];
int find(int x)
{
	if(x != p[x])
		p[x] = find(p[x]);
	return p[x];
}
void dfs(int u,int fa,int maxd,int d[])//maxd存的是从根节点到当前点的边权最大值
{
	d[u] = maxd;
	for(auto [j,w] : g[u])
	{
		int j = e[i];
		if(j != fa)
		{
			dfs(j,u,max(maxd,w),d);//维护的时候更新一下最大值即可
		}
	}
}
int main()
{
	_;
	cin >> n >> m;
	memset(h,-1,sizeof h);
	for(int i=0;i<m;i++)
	{
		int a,b,w;
		cin >> a >> b >> w;
		edge[i] = {a,b,w};
	}
	sort(edge,edge + m);
	for(int i=1;i<=n;i++) p[i] = i;
	ll sum = 0;
	for(int i=0;i<m;i++)
	{
		int a = edge[i].a,b = edge[i].b,w = edge[i].w;
		int pa = find(a),pb = find(b);
		if(pa != pb)
		{
			p[pa] = pb;
			sum += w;
            g[a].push_back({b,w}),g[b].push_back({a,w});
			edge[i].f = 1;//标记是树边
		}
	}
	for(int i=1;i<=n;i++)
		dfs(i,-1,0,dist[i]);//传入父节点是因为是双向边防止死循环
	for(int i=0;i<m;i++)
	{
		if(!edge[i].f)//是非树边
		{
			int a = edge[i].a,b = edge[i].b,w = edge[i].w;
			if(w > dist[a][b])
			{
				res = min(res,sum + w - dist[a][b]);
			}
		}
	}
	cout << res << endl;
	return 0;
}//4 4   1 2 100   2 4 200   2 3 250   3 4 100  ----> 450
```

### 有向图的最小生成树

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define maxn 102
#define INF 0x3f3f3f3f
struct UnionFind {
  int fa[maxn << 1];
  UnionFind() { memset(fa, 0, sizeof(fa)); }
  void clear(int n) { memset(fa + 1, 0, sizeof(int) * n); }
  int find(int x) { return fa[x] ? fa[x] = find(fa[x]) : x; }
  int operator[](int x) { return find(x); }
};
struct Edge {
  int u, v, w, w0;
};
struct Heap {
  Edge *e;
  int rk, constant;
  Heap *lch, *rch;
  Heap(Edge *_e) : e(_e), rk(1), constant(0), lch(NULL), rch(NULL) {}
  void push() {
    if (lch) lch->constant += constant;
    if (rch) rch->constant += constant;
    e->w += constant;
    constant = 0;
  }
};
Heap *merge(Heap *x, Heap *y) {
  if (!x) return y;
  if (!y) return x;
  if (x->e->w + x->constant > y->e->w + y->constant) swap(x, y);
  x->push();
  x->rch = merge(x->rch, y);
  if (!x->lch || x->lch->rk < x->rch->rk) swap(x->lch, x->rch);
  if (x->rch)
    x->rk = x->rch->rk + 1;
  else
    x->rk = 1;
  return x;
}
Edge *extract(Heap *&x) {
  Edge *r = x->e;
  x->push();
  x = merge(x->lch, x->rch);
  return r;
}
vector<Edge> in[maxn];
int n, m, fa[maxn << 1], nxt[maxn << 1];
Edge *ed[maxn << 1];
Heap *Q[maxn << 1];
UnionFind id;
void contract() {
  bool mark[maxn << 1];
  // 将图上的每一个结点与其相连的那些结点进行记录。
  for (int i = 1; i <= n; i++) {
    queue<Heap *> q;
    for (int j = 0; j < in[i].size(); j++) q.push(new Heap(&in[i][j]));
    while (q.size() > 1) {
      Heap *u = q.front();
      q.pop();
      Heap *v = q.front();
      q.pop();
      q.push(merge(u, v));
    }
    Q[i] = q.front();
  }
  mark[1] = true;
  for (int a = 1, b = 1, p; Q[a]; b = a, mark[b] = true) {
    // 寻找最小入边以及其端点，保证无环。
    do {
      ed[a] = extract(Q[a]);
      a = id[ed[a]->u];
    } while (a == b && Q[a]);
    if (a == b) break;
    if (!mark[a]) continue;
    // 对发现的环进行收缩，以及环内的结点重新编号，总权值更新。
    for (a = b, n++; a != n; a = p) {
      id.fa[a] = fa[a] = n;
      if (Q[a]) Q[a]->constant -= ed[a]->w;
      Q[n] = merge(Q[n], Q[a]);
      p = id[ed[a]->u];
      nxt[p == n ? b : p] = a;
    }
  }
}
ll expand(int x, int r);
ll expand_iter(int x) {
  ll r = 0;
  for (int u = nxt[x]; u != x; u = nxt[u]) {
    if (ed[u]->w0 >= INF)
      return INF;
    else
      r += expand(ed[u]->v, u) + ed[u]->w0;
  }
  return r;
}
ll expand(int x, int t) {
  ll r = 0;
  for (; x != t; x = fa[x]) {
    r += expand_iter(x);
    if (r >= INF) return INF;
  }
  return r;
}
void link(int u, int v, int w) { in[v].push_back({u, v, w, w}); }
int main() {
  int rt;
  scanf("%d %d %d", &n, &m, &rt);
  for (int i = 0; i < m; i++) {
    int u, v, w;
    scanf("%d %d %d", &u, &v, &w);
    link(u, v, w);//单向边
  }
  // 保证强连通
  for (int i = 1; i <= n; i++) link(i > 1 ? i - 1 : n, i, INF);
  contract();
  ll ans = expand(rt, n);
  if (ans >= INF)
    puts("-1");
  else
    printf("%lld\n", ans);
  return 0;
}
```

### 二分图

#### 染色法

-   染色法判断是不是二分图,二分图一定不含奇数环,不含奇数环的是二分图

```cpp
//链式前向星建边,略,无向图,边是点的二倍
bool dfs(int u,int c)
{
	color[u] = c;//记录当前点的颜色是c
	for(int i = h[u];i!=-1;i=ne[i])//遍历点的领点
	{
		int j = e[i];
		if(!color[j])//没有染色
		{
			if(!dfs(j,3-c)) return false;
		}//没有染色，染成另外一种颜色1或2
		else if(color[j]==c)
			return false;//边的端点颜色一样
	}
	return true;
}
bool flag = true;//表示染色是不是有矛盾
for(int i=1;i<=n;i++)//染色
    if(!color[i])
    {
        if(!dfs(i,1))
        {
            flag = false;
            break;
        }
    }
//flag = 1,表示是二分图,否则不是二分图
```

#### 匈牙利算法 - 建单项边

求二分图最大匹配数,如果现在匹配的两个点都是单独的,就匹配在一起,否则就遍历其中一个点的其他匹配可否更换,,如果可以更换就更换,否则匹配失败 

```cpp
int match[N];//右边的相对应的点//match[j]=a,表示女孩j的现有配对男友是a
bool st[N];//st[]数组我称为临时预定数组，st[j]=a表示一轮模拟匹配中，女孩j被男孩a预定了。
bool find(int x)//这个函数的作用是用来判断,如果加入x来参与模拟配对,会不会使匹配数增多
{	 //遍历自己喜欢的女孩
	for(int i=h[x];i!=-1;i=ne[i])//左半部分
	{
		int j = e[i];
		if(!st[j])//如果在这一轮模拟匹配中,这个女孩尚未被遍历
		{
			st[j] = true;//更新状态
			if(match[j]==0||find(match[j]))//右半部分对应的点未匹配左半部分或者右半部分匹配的左边有其他选择，
			{ //如果女孩j没有男朋友，或者她原来的男朋友能够预定其它喜欢的女孩。配对成功,更新match
				match[j] = x;
				return true;
			}	
		}
	}//自己中意的全部都被预定了。配对失败。
	return false;
}
for(int i=1;i<=n1;i++)
{//因为每次模拟匹配的预定情况都是不一样的所以每轮模拟都要初始化
    memset(st,false,sizeof st);//将右半部分清空，保证只匹配一次,macth不能清楚,所以不会影响匹配结果 n
    if(find(i)) res++;
}
```

### 网络流

```cpp
namespace Network_Flow
{
    const int NN=2005,MM=1e7+5;
    struct edge
    {
        int to,nxt,v;
    }e[MM<<1]; int cnt=1,head[NN],cur[NN],dep[NN],s,t;
    inline void addedge(CI x,CI y,CI z)
    {
        e[++cnt]=(edge){y,head[x],z}; head[x]=cnt;
        e[++cnt]=(edge){x,head[y],0}; head[y]=cnt;
    }
    inline void clear(void)
    {
        memset(head,0,(t+1)*sizeof(int)); cnt=1;
    }
    #define to e[i].to
    inline bool BFS(void)
    {
        memset(dep,0,(t+1)*sizeof(int)); dep[s]=1;
        queue <int> q; q.push(s);
        while (!q.empty())
        {
            int now=q.front(); q.pop();
            for (RI i=head[now];i;i=e[i].nxt)
            if (e[i].v&&!dep[to]) dep[to]=dep[now]+1,q.push(to);
        }
        return dep[t];
    }
    inline int DFS(CI now,CI tar,int dis)
    {
        if (now==tar) return dis; int ret=0;
        for (RI& i=cur[now];i&&dis;i=e[i].nxt)
        if (e[i].v&&dep[to]==dep[now]+1)
        {
            int dist=DFS(to,tar,min(dis,e[i].v));
            if (!dist) dep[to]=0;
            dis-=dist; ret+=dist;
            e[i].v-=dist; e[i^1].v+=dist;
            if (!dis) return ret;
        }
        if (!ret) dep[now]=0;
        return ret;
    }
    #undef to
    inline int Dinic(int ret=0)
    {
        while (BFS()) memcpy(cur,head,(t+1)*sizeof(int)),ret+=DFS(s,t,INF); return ret;
    }
}
using namespace Network_Flow;
```



## 杂项

-   排序后相邻异或最小，同或最大

## 匿名函数

每次初始化 , `clear`可能会非常慢 , 直接考虑匿名函数开内部`vector,map`等`STL`,或者使用函数时传入动用的容器 , 

```
[捕获列表](参数列表) mutable(可选) 异常属性 -> 返回类型 {
// 函数体
}

[]：默认不捕获任何变量；
[=]：默认以值捕获所有变量；
[&]：默认以引用捕获所有变量；
[x]：仅以值捕获x，其它变量不捕获；
[&x]：仅以引用捕获x，其它变量不捕获；
[=, &x]：默认以值捕获所有变量，但是x是例外，通过引用捕获；
[&, x]：默认以引用捕获所有变量，但是x是例外，通过值捕获；
[this]：通过引用捕获当前对象（其实是复制指针）；
[*this]：通过传值方式捕获当前对象；
```

### 不需要递归类

```cpp
auto check = [=](int x) -> bool {//check 是函数名,自拟即可, [] 内的元素一般选择 = 或则和 &  -> 后面是返回值
    if (!ok) return false;
    return true;
};
```

### 需要递归类

```cpp
auto dfs = [=](auto self,int x) -> void{//数据类型自给 , 返回不变
    //书写的代码内容
    self (self,x);
};
dfs(dfs,x);
```



****

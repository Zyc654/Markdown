## [我要遍历这棵树(1)](http://10.36.65.50:81/contest/1086/problem/G)

观察到对于固定的根 , 当前答案是所有节点直接子节点数量的全排列 ,即是 `ans = ans * (pw[son[now]])` , 先指定根节点为 `1` , 发现转换根之后只会更改两点的直接子节点数 , 即是当前父节点直接子节点数减一 , 当前节点直接子节点加一 , 

```cpp
ans[x] = (ans[fa] / (fa所有连边的全排列) / ans[x] * (fa所有连边减掉x的全排列) ) * (x 所有儿子子树的答案乘积) * (x所有连边的全排列);
```

实际上就是在 x 的父亲的答案 `ans[fa]`中去掉子树 `ans[x]`贡献. 再把 fa 去掉 son 后的部分作为 son 的子树重新计算以 x 为根的整颗树的答案.



## [开心](http://10.36.65.50:81/contest/1086/problem/L)

依赖背包 , (树上背包) , 由于此题中可能出现环或森林 , 但是依赖背包(树上背包)只能在一个树上操作, 且环中的数据一定是不可以获得的 , 起点套终点 , 谁都买不了 , 所以需要加一个虚拟节点 , 表示新的头节点 , 将森林转换为树上背包问题 .

由于这题


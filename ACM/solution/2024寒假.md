[toc]

# ***前缀和 差分 二分 三分 kmp***

## 前缀和&&差分

> 前缀和是指某序列的前n项和，可以把它理解为数学上的数列的前n项和，而差分可以看成前缀和的逆运算。合理的使用前缀和与差分，可以高效解决区间求和以及区间修改问题。
>
> 首先给定一个原数组a： a[1], a[2], a[3],,,,,, a[n];
>
> 然后我们构造一个数组b ： b[1], b[2], b[3],,,,,, b[i];
>
> 其中 a[i] = b[1] + b[2] + b[3] + ,,,,,, + b[i]
>
> a数组中的每一个元素都是b数组从1到i的区间和。
>
> 我们就把a数组是b数组的前缀和数组，反过来我们把b数组叫做a数组的差分数组。
>
>
> ![image-20230107213028206](../../Downloads/讲义.assets/image-20230107213028206.png)

## 区间求和

> **先来了解这样一个问题：**
>
> 输入一个长度为`n`的整数序列。接下来再输入`m`个询问，每个询问输入一对`l`, `r`。对于每个询问，输出原序列中从第`l`个数到第`r`个数的和。
>
> 我们很容易想出暴力解法，遍历区间求和。
>
> ```c++
> const int N = 1e5 + 10;
> int a[N];
> int n,m;
>     cin >> n >> m;
>     for(int i = 1; i <= n; i++) 
>         cin >> a[i];
>     while(m--)
>     {
>         int l, r;
>         int sum = 0;
>         cin >> l >> r;
>         for(int i = l; i <= r; i++)
>             sum += a[i];
>         cout << sum << endl;
>     }
> ```
>
> 这样的时间复杂度为`O(n * m)`，如果`n`和`m`的数据量级大一点就可能卡超时，而我们如果使用前缀和的方法来做的话就能够将时间复杂度降到`O(n + m)`，大大提高了运算效率。
>
> **具体做法：**
>
> 首先做一个预处理，定义一个`sum[]`数组，`sum[i]`代表`a`数组中前`i`个数的和。
>
> **求前缀和运算：**
>
> ```c++
> const int N = 1e5 + 10;
> int sum[N], a[N]; //sum[i]=a[1]+a[2]+a[3].....a[i];
> for(int i = 1;i <= n; i++)//前缀和,差分初始下标尽量为 1 ,可以免去 0 - 1 = -1 的麻烦。
> { 
>     sum[i] = sum[i - 1] + a[i]; 
> }
> ```
>
> 对于每次查询，只需执行`sum[r] - sum[l - 1]` ，时间复杂度为`O(1)`
>
> ![image-20230107213425463](../../Downloads/讲义.assets/image-20230107213425463.png)
>
> 这样，对于每个询问，只需要执行 `sum[r] - sum[l - 1]`。输出原序列中从第`l`个数到第r个数的和的时间复杂度变成了`O(1)`。
>
> 我们把它叫做**一维前缀和**。

## 二维前缀和

> 先给出问题：
>
> 输入一个n行m列的整数矩阵，再输入q个询问，每个询问包含四个整数 `x1, y1, x2, y2`，表示一个子矩阵的左上角坐标和右下角坐标。对于每个询问输出子矩阵中所有数的和。
>
> 同一维前缀和一样，我们用一个二维数组s存储这个二维前缀和，`s[i][j]`  表示二维数组中，左上角(1, 1)到右下角(i, j)所包围的矩阵元素的和。接下来推导二维前缀和的公式。
>
> ![image-20230107214034432](../../Downloads/讲义.assets/image-20230107214034432.png)
>
> sum数组的初始化
>
> ```c++
> s[i][j] = s[i - 1][j] + s[i][j - 1] + a[i][j] - s[i - 1][j - 1];
> ```
>
> 
>
> **紫色面积**是指`(1, 1)`左上角到`(i, j - 1)`右下角的矩形面积, **绿色面积**是指`(1, 1)`左上角到`(i - 1, j )`右下角的矩形面积。**每一个颜色的矩形面积都代表了它所包围元素的和。**
>
> ![在这里插入图片描述](../../Downloads/讲义.assets/image-20230107213706709.png)
>
> 从图中我们很容易看出，整个外围蓝色矩形面积`s[i][j] `= 绿色面积`s[i - 1][j] `+ 紫色面积`s[i][j - 1] `- 重复加的红色的面积`s[i - 1][j - 1] `+ 小方块的面积`a[i][j]`;
>
> 因此得出二维前缀和预处理公式
>
> ```c++
> s[i][j] = s[i - 1][j] + s[i][j - 1] + a[i][j] - s[i - 1][j - 1];
> ```
>
> 
>
> 初始化完毕后我们去求以`(x1,y1)`为左上角和以`(x2,y2)`为右下角的矩阵的元素的和。
>
> ![image-20230107214016697](../../Downloads/讲义.assets/image-20230107214016697.png)
>
> **紫色面积**是指 `(1, 1)`左上角到`(x1 - 1, y2)`右下角的矩形面积 ，**黄色面积**是指`(1, 1)`左上角到`(x2, y1 - 1)`右下角的矩形面积；
>
> **不难推出：**
>
> ![在这里插入图片描述](../../Downloads/讲义.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYyOTI4NQ==,size_16,color_FFFFFF,t_70.png)
>
> 绿色矩形的面积 `= `整个外围面积`s[x2, y2]` - 黄色面积`s[x2, y1 - 1] `- 紫色面积`s[x1 - 1, y2]` + 重复减去的红色面积 `s[x1 - 1, y1 - 1]`
>
> 因此二维前缀和的结论为：
>
> 以`(x1, y1)`为左上角，`(x2, y2)`为右下角的子矩阵的和为：
> **`sum = s[x2, y2] - s[x1 - 1, y2] - s[x2, y1 - 1] + s[x1 - 1, y1 - 1]`**

## 区间修改

> 这个问题既然出现在了讲义里那不难想到区间修改问题我们可以使用差分高效解决
>
> 差分操作和前缀和一样数组下标都从**1**开始比较好（初始化操作统一便于书写）。
>
> 这里用b数组表示原数组对应的差分数组 他表示的当前元素i与前一个元素的差值
>
> **有这么一个问题：**
>
> 给定区间`[l, r]`，让我们把`a`数组中的`[l, r] `区间中的每一个数都加上`c`,即 `a[l] + c , a[l + 1] + c , a[l + 2] + c ...... a[r] + c`;
>
> 我们找不变量
>
> 差分数组的构建：
>
> ![img](../../Downloads/讲义.assets/20201215214337143.png)
>
> `b[l] + c`后，`l`后面的数组都会加`c`。`r`后面的数据也会被改变，要改回来就得`b[r + 1] - c`
>
> ```c++
> #include<bit/stdc++.h>
> using namespace std;
> const int N = 1e5 + 10;
> int a[N],b[N]; 
> int main()
> {
>     int n,m;
>     cin >> n >> m;
>     for(int i = 1;i <= n; i++) 
>     {
>         cin >> a[i];
>         b[i] = a[i] - a[i - 1];      //构建差分数组
>     }
>     int l, r, c;
>     while(m--)
>     {
>         cin >> l >> r >> c;
>         b[l] += c;     //表示将序列中[l, r]之间的每个数加上c
>         b[r + 1] -= c;
>     }
>     for(int i = 1;i <= n; i++) 
>     {
>         b[i] += b[i - 1];  //求前缀和运算
>         cout << b[i] << " ";
>     }
>     return 0;
> }
> ```

## 二维差分

- 在一个区域内进行操作，对区域内进行整个加法或者减法操作。

例如在`(x1,y1)和(x2,y2)之间的每个数都加上c`,如下图所示

![二维差分](../../Downloads/讲义.assets/二维差分.png)

在我们要的区间开始位置`(x1,y1)`处`+c`,根据前缀和的性质,那么影响的就是整个黄色区域(二图),多影响了两个蓝色的位置,所以在每个蓝色位置的开始位置即是`(x1 , y2  + 1),和(x2 , y1 + 1)`位置减去一个`c` 来抵消产生的影响,同样的可以观察图五中有重复减去的绿色位置,故在`(x2 + 1,y2 + 1)`位置重新加上`c`,抵消影响。

代码表示为

```c++
s[x1][y1] += c;
s[x1][y2 + 1] -= c;
s[x2 + 1][y1] -= c;
s[x2 + 1][y2 + 1] += c;
//差分数组求前缀和数组得到原数组
for(i : 1 - n)
    for(j : 1 - m)
        s[i][j] = s[i - 1][j] + s[i][j - 1] + a[i][j] - s[i - 1][j - 1];
```

- 初始下标最好为 1 。

## 二分、三分

### 概念

- 二分就是一分为二。简单来说二分就是在有序序列中，通过不断的二分，进而不断地缩小范围去寻找满足我们条件的解。**广义二分**是说如果有一个临界值使得临界值一边的数据满足一种性质，另一边满足另一种性质，即使不是有序的但也可以利用二分去寻找这个临界值，也就是说问题满足单调性就可以二分。
- 二分主要分为**二分查找**、**二分答案**也叫**二分检验**，二分类型分为**整数二分**、**实数域上二分**

### 整数二分模板

```c++
// 将区间分为[L,mid],[mid+1,R],寻找满足条件的左值
bool check(mid){//判断条件函数 
}
//终止条件是left==right 
    while(left < right)
    {
        int mid = (left + right) >> 1;
        if(check(mid)) 
            right = mid;//判断如果mid这个值满足[L,mid]这个区间里面的的数的性质，则将r=mid，缩小范围 
        else 
            left = mid + 1; //否则另l=mid+1，+1的原因是mid不满足条件不能取 
    }
    cout << right << endl;


// 将区间分为[L,mid-1],[mid,R],求满足要求的最大值,右端点
    while(left < right)
    {
        int mid = (left + right + 1) >> 1;//这里一定要加1
        if(check(mid)) left = mid;//判断如果mid这个值满足[mid,R]这个区间里面的的数的性质，则将l=mid，缩小范围 
        else right = mid - 1; //否则另r=mid-1，+1的原因是mid不满足条件不能取 
    }
    cout << right << endl;
//实数域上二分只需要把循环条件改成r-l>某一精度eps（如：1e-k-2）保留k位小数
```

## 二分答案

- 二分答案也叫二分检验，这类问题通常用于答案的值域已经确定，并且很难从问题的本身去找到答案的情况。这样就可以从答案值域入手，判定这个值符不符合题目要求，根据判定结果缩小范围从而找到最优值。

## 01分数规划

![image-20230108121936361](../../Downloads/讲义.assets/image-20230108121936361.png)

也即是 $\sum a_{i} - \sum b_{i}\ * ans >= 0$,二分答案 `ans`

## 三分

- 三分搜索的实现主要是判断`midl`和`midr`所在值的大小。以凸函数为例（凹函数类似，只是判`mid`大小的时候保留小的即可（其实也是保留离极值最近的`mid`）），我们直接通过`left`和`right`为端点三分出`midl，midr`，接下来只需要判断`f(midl)`和`f(midr)`值的大小，如果`f(midl)`大于`f(midr)`，那么说明`midl`靠近极值，此时令`right=midr`，否则说明`midr`靠近极值，此时则令`left=midl`，总之就是要保留离极值最近的那一个`mid`，然后重复前面的过程，直到`left和right`十分接近，最终`f(left)`就等于了极值。
- ![image-20230108113023036](../../Downloads/讲义.assets/image-20230108113023036.png)

```c++
while (r - l > eps)//0.
    {
        double mid = (r - l) / 3.0;
        double m1 = l + mid;
        double m2 = m1 + mid;

        if (f(m1) < f(m2))
            l = m1;
        else
            r = m2;
    }
```

## `kmp`模式串匹配

### 概念

- `KMP`算法要解决的问题就是在字符串（也叫主串）中的模式（pattern）定位问题。说简单点就是我们平时常说的关键字搜索。

- 串的模式匹配设有两个字符串`S`和`T`,设`S`为主串，也称`正文串`;设`T为子串,也称为模式`。
  在`主串S`中查找与模式T相匹配的子串，如果匹配成功，确定相匹配的子串中的第一个字符在主串S中出现的位置。模式匹配算法有BF算法和`KMP算法`，BF也就是最简单的暴力将模式串中的每一个字符依次与主串匹配，任一模式串字符匹配失败，重新开始匹配。这里详细介绍其改进算法`KMP`。
- `KMP算法`可以在`O(n+m)`的时间数量级上完成串的模式匹配操作。其改进在于:每当一趟匹配过程中出现字符比较不等时，不需回溯`i指针`，而是利用已经得到的“部分匹配”的结果将模式向右“滑动”尽可能远的一段距离后，继续进行比较。

### BF暴力求解

> 从左到右一个个匹配，如果这个过程中有某个字符不匹配，就跳回去，将模式串向右移动一位。
>
> ![img](../../Downloads/讲义.assets/17083647-9dfd3e4a709c40dd98d9817927651960.png)
>
> 之后我们只需要比较`i`指针指向的字符和`j`指针指向的字符是否一致。如果一致就都向后移动，如果不一致,`i`指针回溯。
>
> ![img](../../Downloads/讲义.assets/17083659-e6718026bf4f48a0be2d5d6076be4c55.png)
>
> i指针移回第`2`位（假设下标从`1`开始），`j`移动到模式串的第`1`位，然后又重新开始匹配。
>
> ![img](../../Downloads/讲义.assets/17083714-7de56d2c1cc84dbfa376cf410ba6f053.png)
>
> 

### KMP

> - 参考上面的解法，**我们串中的位置用指针`i,j`来说明，第一个位置下标以`1`开始**，如果是人为来寻找的话，肯定不会再把i移动回溯第2位，**因为主串匹配失败的位置`(i=4)`前面除了第一个`A`之外再也没有`A`了**，我们为什么能知道主串前面只有一个`A`？**因为我们已经知道前面三个字符都是匹配的！（这很重要）**。移动过去肯定也是不匹配的。所以，i可以不动，我们只需要移动j即可
>
> ![img](../../Downloads/讲义.assets/17083828-cdb207f5460f4645982171e58571a741.png)
>
> - 该算法其思想就如同我们上边所看到的一样：“利用已经部分匹配这个有效信息，保持`i`指针不回溯，只修改`j`指针，让模式串尽量地移动到有效的位置。”
>
> 
>
> 所以，整个`KMP`的重点就在于**当某一个字符与主串不匹配时，**`i`指针不回溯，只有`j`指针的移动，我们使用`next`数组存储其失匹时应该移动到的位置。`t为主串 p为模式串`
>
> 关键代码
>
> - 字符串下标为 1 时的 `KMP匹配`过程
>
> ```c++
> //KMP匹配过程
> for(int i=1,j=0;i<=m;i++)// i 遍历 s 所有数组
> {
>     while(j && s[i] != p[j + 1]) 
>         j = ne[j];// j没有退回起点且匹配失败,j 回到可以利用的位置
>     if(s[i] == p[j + 1]) 
>         j ++;
>     if(j == n)
>     {
>         //匹配成功
>         cout << i - j << " ";//i从1开始i-n即是开始位置
>         j = ne[j];//匹配结束，更新最大后缀对应的前缀结尾，快速匹配前一部分字符
>     }
> }
> ```
>
> - 初始下标为 0 开始的 `KMP匹配`
>
> ```c++
> while (i < t.size() && j < (int)p.size()) 
> {
>     if (j == -1 || t[i] == p[j]) 
>     { // 当j为-1时，要移动的是i，当然j也要归0
>         i++;
>         j++;
>     } 
>     else 
>     {
>         // i不需要回溯了
>         // i = i - j + 1;
>         j = next[j]; // j回到指定位置
>     }
> }
>     if (j == p.length()) 
>         return i - j;//主串中成功匹配的模式串的首字母位置
>     else 
>     	return -1;
> ```
>
> 
>
> next数组求解关键代码
>
> - 字符串下标为 1 开始时的 `KMP匹配` 求`ne`数组
>
> `ne`数组相当于失匹之后目前还能利用多少位
>
> ```c++
> //求next过程,这个板子中将字符串下标转换为 从 1 开始,注意
> for(int i=2,j=0;i<=n;i++)
> {      //需要特别注意i是从1开始计数的，j是从0开始,j = 0 表示匹配未开始
>     while(j && p[i] != p[j + 1]) j = ne[j];//未到起始，且匹配失败，回答前缀的结尾，快速匹配
>     if(p[i] == p[j + 1]) j ++;//匹配成功，前缀结尾终点后移
>     ne[i] = j;//更新后缀对应的前缀结尾
> }
> // abcbabbabc 
> 
> ```
>
> - 下标 0 开始
>
> ```c++
> next[0] = -1;
> int j = 0;
> int k = -1;
> while (j < p.size() - 1)//知道模式串全部位置都求出来 
> {
>     if (k == -1 || p[j] == p[k]) 
>     {
>         next[++ j] = ++k;
>     } 
>     else 
>     {
>         k = next[k];
>     }
> }
> ```
>
> - `KMP`判断是否为重复子串
>
> ```c++
> //KMP 判断字符串是否是由子字符串重复循环构成
> if(len % (len - ne[len]) == 0)//len表示字符串 s 的长度,就是字符串第一位到next[len]位与len -next[len]位到第len位是匹配的
> cout << len / (len - ne[len]) << endl;//判断,len-next[len] 即是重复子字符串的长度
> ```
>
> 
>
> 始终记住一点，`next[j]`的值（也就是k）表示当模式串当前字母与主串失匹时，`j`指针下一个应该移动的位置。
>
> 当`j`为0时，如果这时候不匹配
>
> ![img](../../Downloads/讲义.assets/17084258-efd2e95d3644427ebc0304ed3d7adefb.png)
>
> **`j`已经在最左边了，不可能再移动了，这时候要应该是i指针后移**。所以在代码中才会有`next[0] = -1`这个初始化(对于下标为`1`的时候不必初始化为 `-1`,`0`即是表示`j`处于最左端)
>
> `next[j]`的每一个`k`值都是`j`位之前的子串中，前缀集和后缀集中可能的最大重复子串的长度。
>
> 主串与模式串当前字母相等，可能的最大重复子串长度加一
>
> 不相等，移动到当前模式串可能匹配的最大重复子串的最后一个位置`next[j]`
>
> ![img](../../Downloads/讲义.assets/17122358-fd7e52dd382c4268a8ff52b85bff465d.png)
>
> ![img](../../Downloads/讲义.assets/17122439-e349fed25e974e7886a27d18871ae48a.png)
>
> 理解上难，用起来不难。

## 例题讲解：

[[CQOI2010]扑克牌](https://www.luogu.com.cn/problem/P5815)

> 二分答案 

[[HNOI2003]激光炸弹](https://www.luogu.com.cn/problem/P2280)

> 二维前缀和

[小咪买东西](https://ac.nowcoder.com/acm/problem/14662)

> 01分数规划
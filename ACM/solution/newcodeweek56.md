## E

恶心的地方在于可能会跨过某一天 , 虽然开始的时间不会到达24小时 , 但是可以跨过一段时间 , 不能直接将时间转换为分钟比大小 , 考虑也就 1440 分钟 , 所以直接标记每一分钟判断是否满足条件 , 此部分复杂度 $O(24N)$

之后直接判断当前口味是否是喜欢的 , 询问时间是否是开心时间 , 是否来的比较早 即可 ! ! ! ! ! 

坑点在于时间跨天 , 这样便只能数组标记当前分钟是否是开心时间 , 使用 `scanf` 可以采用格式读入 , 比较方便 , 或者使用 `cin` 读字符串

```cpp
scanf("%d:%d %d:%d", &hh1, &mm1, &hh2, &mm2);
```



---

## [F](https://ac.nowcoder.com/acm/contest/88392/F)

方法一 : hash 加 二分

对每一个位置进行反转`hash` 找出反转之后的`hash`值 , 之后二分判断 `lcp` , 判断当前长度 哈希值 是否相等即可 , 

满足哈希的前提 : 模数不冲突的前提下较长长度满足前缀相同那么较短的前缀一定也满足 , 总复杂度在 $O(nlogn)$



方法二 : Z 函数

算是一个`Z函数的扩展应用`

难点在于反转怎么处理 , 思考一下 , 如果整个将 `s` 字符串反转 , 那么当枚举到 `i` 的时候 , 我们判断后 `i` 位和 `t`字符串的最长公共前缀 , 那么即是将反转后的最长公共前缀处理出来 , 在加上未反转的即可得到最终答案 , 未反转的可以通过倒序遍历预处理出来 , 注意需要判断反转后是否刚好将当前区域覆盖才能继续判断下一位未反转的贡献 . 

例如 

```cpp
//s = abcdefg , 反转前三位得 cbadefg 完全反转得到 gfedcba , 只判断后三位即是前三位反转的情况 . 
```

每次判断第 `i`位的时候只需要判断当前后 `i` 位和 `t` 字符串前 `i` 个字符之间的关系即可 , 如果恰好前面部分反转之后全部相等 , 加上后面的答案即是反转这部分的答案 . 








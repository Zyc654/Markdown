## [点击跳转](#jump)

## [CF 911 F](https://codeforces.com/contest/911/problem/F)

树的直径 , 由于一个树图中树的直径的两个端点距离其他点的距离最远,所以首先删除的点一定不是在直径上的点 , 借助直径的两个端点 , 将其余的节点删除 , 最后在依次删除直径上的点 , 注意其余的点删除的时候需要判断离哪一个端点更远

```cpp
bool mark(int u,int fa)//判断直径上的点
{
    if(u == en)
    {
        st[u] = 1;
    }
    for(auto L : g[u])
    {
        if(L == fa) continue;
        st[u] = max(st[u],mark(L,u));
    }
    return st[u];
}
```



---

## [CF 1900D](https://codeforces.com/contest/1900/problem/D)

[Codeforces Round 911 (Div. 2)（C~E）（DFS、数论（容斥）、SCC缩点 + DAG图上DP）-CSDN博客](https://blog.csdn.net/weixin_61825750/article/details/134636113)

最初思路是枚举 `gcd`, 二三维枚举 `j,k` 表示 `gcd` 的倍数 , 由于 调和级数 复杂度是 $logn$ 的 , 最初分析复杂度是 $N(log)^2$  `max(N) = 8e4`

但是 `T` 了 , 大概是 `gcd(j,k) == i` 使复杂度额外增加一个 `log` ? ? ? 修改 `gcd` 的时候 判断 `k == i || j % k != 0` 此时 `gcd(j,k) == i` ? ? ? 

同样不懂这样有问题 

**正解 :** 

预处理每个数的因子 `nlogn`

最终的答案使每个因子产生的贡献 , 也即是 **区间之和就是（右端点的因子大小 * 区间内该因子的个数）的总和,但是小因子倍数的大因子是重复计算的,由于是gcd,所以应该减去小因子的贡献**

具体的说就是 例如枚举到因子 6 ,此时 `gcd` 应该是 6 , 但是 1 , 2 , 3 也是 6 的因子,导致在计算 6 的因子时 ,1 2 3 被重复计算了一次 , 所以 到此时 6 的贡献应该是 6 - 3 - 2 -  1 , 即是 `w[j] -= w[i]` , 其中 `w[i]` 的初值是 `i` , `i 是 j 的因子` 这样即可以消除重复的个数

```cpp
pre(i,1,n)
{
    int sum = 0;
    for(auto L : ve[a[i]])
        sum += w[L] * cnt[L],cnt[L] ++ ;// 因为当前 i 是右端点,所以先计算和 在将 i 的影响加入的cnt数组中
    ans += sum * (n - i);
}
```



---





[Codeforces Round 921 (Div. 2)  --- 1925](https://www.cnblogs.com/value0/p/17993429#:~:text=Codefo)

## [CF1925C](https://codeforces.com/contest/1925/problem/C)

考虑寻找前 `k` 个字符至少出现一次的区间, 如果区间个数大于 `n` 次 , 可以判断一定会包含所有可能情况的长度为 `n` 的子序列 , 否则一定不满足

不满足的样例 : 考虑每次截取当前区间最后一个字母, 那么这个字母在这个区间一定只出现过一次 , 不足的部分使用最后一个区间内未出现过的字母补全即可 









## [CF 1925 D](https://codeforces.com/contest/1925/problem/D)

观察到每次从`n` 个人中选出一对的情况是 $C_n^2$ , 所以每一对被选取的概率都是 $p = \frac{1}{C_n^2}$ , 选不到这个人的概率是 `1 - p` , 对于不是朋友的组合 每次选到对答案的贡献都是 `0` ,所以这部分贡献为 $0 * C_k^i * p^i * (1 - p) ^{k - i}$ , 即是 `0`

对于该对是朋友的情况下的贡献是 : 由于每次选取一对朋友组 , 都会使 `f[x] + 1` , 所以对答案的贡献是 $C_k^i * p^i * (1- p) ^ {k-i} * \sum_{j=0}^{i-1}(f[x] + j)$ ,即是每次选取该组 , 都会使 `f[x] + 1` 累加求和即可 . 

对于所有的 `m` 对朋友 , 有贡献为 $C_k^i * p^i * (1- p) ^ {k-i} * \sum_{x=1}^{m}\sum_{j=0}^{i-1}(f[x] + j)$ ,观察到 , $\sum_{x = 1}^mf[x]$ 是可以合并的 , 即是初始朋友权值的总和 , 合并之后可以发现 $ans = C_k^i * p^i * (1- p) ^ {k-i} * \sum_{j=0}^{i-1}(sum + j * m)$ , 其中 `sum` 表示初始权值总和 ,在结合等差公式可知 , 



$\sum_{j=0}^{i-1}(sum + j * m) = cnt * sum + \frac{cnt\ *\ m\ *\ (cnt - 1)}{2}$





从 `0` 到 `k` 遍历一遍即可求得答案 . 




---



[Codeforces Round 924 -- 1928](https://codeforces.com/blog/entry/125740)



## [CF 1928 C](https://codeforces.com/contest/1928/problem/C)

列出表达式可知 

```
y * (2k - 2) + x == n
y * (2k - 2) + (X - 2) == n
```

也即是求出 `n - x 和 n - x + 2` 可以整除 `2k - 2` 的数据即可 , 也即是说 `2k - 2` 一定是 `n - x 和 n - x + 2` 的因子 , 又因为 `2k - 2` 一定是偶数 , 所以直接求出两个数对于的偶数因子即可 , 复杂度是$\sqrt n$ , 但是需要注意的是 `k >= x` 只有这样才会使数据能到达 `x` ,否则到达 `k` 便反序了, 一定不可能变为 `x`

整体复杂度$t\sqrt n$





## [CF 1928 D](https://codeforces.com/contest/1928/problem/D)

注意到一定是尽量均分的时候每一个物种的贡献最大 , 但是累加起来却不一定 , 考虑对于每个物种暴力判断分为 `1 ~ c[i]` 个组的最大贡献 , 那么对于最终的答案 , 只需要从`1 - max(c[i])` 之间枚举组合一下即可以得到最优的结果 (当前分组 , 每一个物种的分组情况都是最优 , 那么最终的结果一定是所有物种组合的最优解 , 遍历一遍即可得到答案 )

假设目前有 `c` 个 , 需要分为 `r` 组 , 那么考虑优先尽量均分的原则 , 假设每一组暂时都是 $\frac cr$ 人 , 则一共有 `c % r` 组是 `k + 1` 人 , 记作 `tp1` ,一共有 `r - c % r` 组是 `k`人 , 标记为 `tp` ,那么这么多对答案的正贡献是
$$
{tp*(tp-1)\over2}*k^2+{(tp1)*(tp1-1)\over2}*(k+1)^2+tp*tp1*k*(k+1)
$$
即是 , 人数为 `k` 的分组组合 , 一共有 $tp*(tp-1)\over2$ 对 , 由于每一组内有 `k` 人 , 则贡献是 ${tp*(tp-1)\over2}*k^2$ , 同理人数为 `k + 1`分组情况 , 对于不同人数之间的组合两两组合即可 , 贡献是 $tp * tp1 * k * (k + 1)$

注意到 , 当物种数量为 `c[i]` 分为 `c[i]` 组一定是局部最优解 , 不必每次取最大值 , 问题关键在于不同物种之间的组合之间不是 **当前局部最优加当前局部最优一定等于全局最优** 所以只能枚举每个物种每个分组的最优解 , 判断分组数为`x` 时当前 `次局部最优之间的组合`这时候一定是次局部所有物种之间的最优解 , 枚举所有的局部 ,即是所有的分组情况即可得到全局最优解 . 



---



[Codeforces Round #925 (Div. 3) Editorial - Codeforces](https://codeforces.com/blog/entry/125878)

## [CF 1931E](https://codeforces.com/contest/1931/problem/E)

两人都会选当前后缀 0 数量最多的数据操作 , 最大保留 , 次大舍去 , 以此类推 , 预处理后缀 0 后 , 排序 , 奇偶判断即可 





## [CF 1931 F](https://codeforces.com/contest/1931/problem/F)

对于每一组元素除了第一个元素 , 后面的元素前后相对顺序是固定的, `a 在 b 前面则原数组 a 一定在 b 前面` , 如果后续出现 `b 在 a 前面` 即是无解

转换为判断两个元素的前后顺序是否是固定的 , 除去第一个元素 , 每个点向后一个点建立一条单向边 , 如果存在两点顺序不是固定的 , 则所建的图中一定存在环 , 拓扑排序判断无向图中是否存在环即可

```cpp
while(!q.empty())
{
    auto t = q.front();
    q.pop();
    cnt ++ ;
    for(auto L : g[t])
    {
        d[L] -- ;
        if(!d[L]) q.push(L);
    }
}
if(cnt != n) cout << "NO" << endl;
else cout << "YES" << endl;
```











---

## [CF1836 C](https://codeforces.com/contest/1836/problem/C)

字典序第一位肯定是依次增加的 , 直接暴力枚举第二位的左右端点即可求得,每次减去对应长度 暴力!





---

[Educational Codeforces Round 162 (Rated for Div. 2) - value0 - 博客园 (cnblogs.com)](https://www.cnblogs.com/value0/p/18031804)

## [CF 1923 D](https://codeforces.com/contest/1923/problem/D)

二分 , 注意边界细节的处理

注意到 , 在寻找 `i` 答案的时候 , 需要分为从左边推过来 , 或者从右边推过来 , 我们需要寻找的是 : 当前连续区间总和大于 `a[i]` , 且有这段区间内一定是存在相邻两个数不想等的,  只要存在哪怕一个 , 这一段区间一定可以合并为一个数据, 大小为区间和 , 花费时间为 `len`

答案是具有单调性的, 区间和以及区间内不等数量都是单调增的 , 所以直接前后缀和即可求得答案 , 需要特别处理的是相邻的元素大于`a[i]`直接返回长度 1 , 细节问题需要额外注意 , `pr[]` 求的是后缀不等数据和 , `sr` 求解的是后缀和 , 

```cpp
auto checkl = [&] (int x) -> int
{
    if(x == 1) return inf;
    int l = 1,r = x - 1,ans = inf;
    if(a[r] > a[x]) return 1;
    while(l <= r)
    {
        int mid = l + r >> 1;
        if(pr[mid] - pr[x - 1] && sr[mid] - sr[x] > a[x])//区间和不能算上a[x] ,即使[mid,x-1]的区间和,
        {
            l = mid + 1;
            ans = x - mid;
        }
        else r = mid - 1;
    }
    return ans;
};
```



## [CF 1923 E](https://codeforces.com/contest/1923/problem/E)

启发式合并 

注意到回溯到当前根节点时 , 对答案的贡献分为两种 : 

-    当前父节点作为根节点时 , 求解的是子树中包含`c[u]`的个数 , 注意这个个数只包含距离当前父节点最近的 , 即使路径内部不能再有 `c[u]` , 具体实现是遍历时 `dp[u][c[u]] = 1` , 但是如果回溯中当前子节点中查找到`c[u]`,此时加上`dp[L][c[u]]` ,并且将`dp[L][c[u]] = 0` , 防止对上面父节点进行干扰 .
-   当前父节点作为终点节点时 , 如下图子树中红色的为颜色相同的节点, 此时对答案的贡献是数量积的和



![](./../Images/3156354-20240224231450294-1900879821.png)



启发式在每次将小节点向大节点合并 , 这样复杂度可以减低 , 在更新的时候将信息更新到父节点中 , 此时父节点便是更新后的完全信息 , 

```cpp
auto dfs = [&](auto self,int u,int fa) -> void 
{
    dp[u][c[u]] = 1 ;
    for(auto L : g[u])
    {
        if(L == fa) continue;
        self(self,L,u);
        //先计算 u 作为端点的情况
        if(dp[L][c[u]])
        {
            ans += dp[L][c[u]];
            dp[L][c[u]] = 0;
        }
        //启发式合并,每个点最多被计算log次
        if(dp[u].size() < dp[L].size())
        {
            dp[u].swap(dp[L]);
        }
        //根节点 u 作为中间节点
        for(auto [x,y] : dp[L])//判断当前子节点中包含的每个颜色
        {
            if(dp[u][x])
                ans += dp[u][x] * dp[L][x];//
            dp[u][x] += dp[L][x];
        }
        //注意这种启发式合并的意义是每次都使用最小的子节点更新最大的子节点,这样能保证较小的计算量,
        //但是后续的for循环将L的节点信息重新并到u中了,所以整体来看减少的复杂度,但是信息更新是没有问题的
    }
};
```

注意到 : 由于 `dp[L][c[u]] = 0` 的存在 , 当前子树每一种颜色个个数一定不会超过 2 ,保留的是当前父节点和距离父节点最近的两个 , 这样就不会出现路径中存在和端点颜色一样的节点 , 积的和 , 可以利用分配律优化到和的积, 降低复杂度 . 





---

## [CF 1941 E](https://codeforces.com/contest/1941/problem/E)

连续 `k` 行 ,求最小值 

滑动窗口优化 DP , 保证滑动窗口的长度之后 , 对头一直都是当前的最优解



## [CF 1941 F](https://codeforces.com/contest/1941/problem/F)

二分 , 每次考虑将最大值平均分 , 每次二分查找之后需要比较的是两个节点的答案 , 即是 `p , p--` , 两个节点都可能会使答案更优 , 最后和次大值比较即可 



## [CF 1941 G](https://codeforces.com/contest/1941/problem/G)

`01bfs` , 权值为 0 或者 1 ,每次将权值为 0 的放到队头 , 将权值为 `1` 的放到队尾 , 这样一定可以保证总权值较小 , 



```cpp
std::vector<std::map<int, std::vector<int>>> adj(n);
for (int i = 0; i < m; i++)
{
    int u, v, c;
    std::cin >> u >> v >> c;
    u--, v--;
    adj[u][c].push_back(v);
    adj[v][c].push_back(u);
}
std::map<std::pair<int, int>, int> dis;
std::deque<std::tuple<int, int, int>> q;
int b, e;
std::cin >> b >> e;
b--, e--;
q.emplace_back(0, b, 0);
while (!q.empty())
{
    auto [d, x, a] = q.front();
    q.pop_front();
    if (dis.count({x, a}))
    {
        continue;
    }
    dis[{x, a}] = d;
    if (a)
    {
        q.emplace_front(d, x, 0);
        for (auto y : adj[x][a])
        {
            q.emplace_front(d, y, a);
        }
    }
    else
    {
        for (auto &[a, _] : adj[x])
        {
            q.emplace_back(d + 1, x, a);
        }
    }
}
```



---

## [洛谷 UVA 1599](https://www.luogu.com.cn/problem/UVA1599)

题意 : 求最短路的基础上的边的颜色的字典序最小值 , 其中边的权值均为 1

注意到不能单纯的直接从起点`bfs` 寻找最短路, 当前最优的最短路可能最终无法到达终点 , 导致此时更新的答案都是错误的, 需要不停的回溯 , 此时会导致时间复杂度爆炸 , 考虑 : 先从终点进行一边最短路算法 , 处理出可以到达起点的距离数组 `dis`

接着从起点`bfs` ,同时处理出最小字典序 , 注意到如果当前路径上的两个点是可以到达终点的最短路 ,此时一定满足 `dis[v] + 1 = dis[u]`  , 其中当前遍历到的点是 `u` ,当前边的另一端点是 `v` , 由于`bfs`算法中 , 当前队列 `q` 中存储的点都是这一层需要走的点 , 即是目前层所有的点 , 考虑将队列中所有点存在`vector` 中, 同时清空队列 , 依次遍历当前`vector` ,第一次处理出下一层中的最小颜色 ,  第二次循环中 , 判断 如果当前点是最短路中的点 而且 `color = mi` 同时这个点没有被标记过 , 将这些点放入队列中 , 标记 , 继续操作即可 

最终形成的最小颜色`mi` 序列 即是最终所求的答案 . 

[press](D:\mine\vsc\CodeForces\total\理想路径_Ideal_Path.cpp)



---

## [CF 1945 F](https://codeforces.com/contest/1945/problem/F)

选取 `k` 个 , 其中 `p[1 ... k - 1]` 的不能再次使用了, 由于每次取得是最小值 * 数量 , 所以肯定需要排序 

难点在于处理什么时候会遇到已经被标记的位置 , 或者这个位置被选取了,但是新加入的数据将这个位置标记了, 需要减去这个数的数量, 继续向后找数据 .

 考虑将上一个数据的 `p` 数组标记一下 , 这样后续遍历时 只有遇到 `!st[now]` 的点 , `cnt ++ `表示这个数据是合理的 , 否则继续像后找 , 同时 , 如果 `cnt ++` 表示这个数据可选 , 需要将 `vis[v[now].second]` 标记 , 代表这个数据现在是占据 `1` 的 , 后续步骤开始之前 , 如果遇到 `p[i - 1] == v[now].second 同时 st[p[i - 1]] = 1` , 此时需要将 `cnt --` 这个数据被剔除 , `while` 判断条件里面 一定要是`cnt < i && now <= n` 不然最后一个数据选上之后会导致不够 `i` 个数据 , 未跳出去 . 





---

## [CF 1975 D](https://codeforces.com/contest/1975/problem/D)

思路是先将两个点尽量合到一个点上 , 之后从这个点开始 `a` 走一步, `b` 紧跟走一步, 最终所有的步数就是 `2 * (n - 1) - mx` (`mx`表示从汇点到其他点的最大距离, 因为最后一次可以不会来, 这条最长边上每个边只会走一遍)

可以使用`vector` 模拟栈操作, 原因是可以直接找到最终汇聚的点 , 直接使用栈 , 反而找不到汇聚的点 , 如果最终可以汇合到一个点 , 汇合所需要的步骤有 `path.size() / 2 + 1`  (deep 是从 0 开始计数的) , 因为是先判断这个点是不是 `b`  ,此时的`deep` 还没有加一 , 少了一步最终汇合的操作  , 如果最终不能汇合到同一点, 代表此时从这个点开始就要进行操作了, `ans = 1` 同上, 代表欠缺的一个 `deep` , 主要区别在于`now` 的取值, 因为和汇合到同一个点和不可以汇合到同一个点 , 汇合点在`path` 里面的下标有差别 .  

之后进行一次 `dfs` 判断最大距离即可 .



---

## [CF 1977 C](https://codeforces.com/contest/1977/problem/C)

















---

## [CF 1981 C](https://codeforces.com/contest/1981/problem/C)























---

## [CF 1980 F](https://codeforces.com/contest/1980/problem/F2)

模拟 , 离散化 , 前缀

由于右下角是必须包含的 , 所以遍历的顺序一定是倒着的 , 主要问题在于求解对于当前喷泉 , 删除之后对答案是否有贡献 , 注意到 , 如果有贡献 , 那么一定满足删去这个喷泉之后可以使本行边界后移 , 而且可以观察到 向下是没有影响的,因为下一行是下一组的最左边界,和当前没有关系,所以每次只会向上影响 , 向上可能会影响的较多 , 向上找的时候暴力查找即可 , 找到第一个志愿等于当前删除之后的边界即结束 . 对于每组影响都需要重新更新当前最左边界和上一组进行比较























































<span id="jump"> </span>


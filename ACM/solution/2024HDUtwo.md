[2024“钉耙编程”中国大学生算法设计超级联赛（2） - Luckyblock - 博客园 (cnblogs.com)](https://www.cnblogs.com/luckyblock/p/18317006)

[2024“钉耙编程”中国大学生算法设计超级联赛（2） - 空気力学の詩 - 博客园 (cnblogs.com)](https://www.cnblogs.com/cjjsb/p/18316724)

## 1008 成长，生命，幸福

[Problem - 7452 (hdu.edu.cn)](https://acm.hdu.edu.cn/showproblem.php?pid=7452)

本题一个 x 度的节点成长 m 次得到的节点数是 $(x - 1) * (2^m - 1) + 1$ 个，对于 m 较小直接使用暴力求解直径即可，大概在 20 左右 此时不会超过 mod(1e9)没有取模的问题，直接暴力判断直径即可，对于 m 较大的情况，牵扯到取模此时不能比较取模后的答案，此时只比较系数即可，两个系数一个是`度数和-节点数`，第二个是`节点数`,最后在计算答案即可

m 较小的时候不能采用直接两个关键字是因为 m 较小时，$2^m-1$ 比较小，`1` 的个数可能比较多，第二关键字可能会对第一关键字产生影响，此时最大值的更新可能会出现问题。

边权直径转换为点权直径

---

## 1012 图计算

类似题 ： [洛谷P8026](https://www.luogu.com.cn/problem/P8026)  [press](luoguP8036.md)

本质上都是对每一个点建立一个长度为 d 的字符串，表示该点在第 i 个图中的祖先是谁

两个点在图 i 中联通，当且仅当在第 i 个图中`p[u] = p[v]`，即是两者祖先相等，对应到每个点的字符串中即是第 i 位的字母相同

将 n 个字符串 `hash`判断两个字符串是否相等，不需要常规 hash ，给长度为 d 的字符串每一位一个随机数表示，那么当前字符串的 `hash`值是  $\textstyle\sum w(i)\times S(i)$ 使用 `ull` 自动溢出即可。

合并的时候不能直接路径压缩，常规路径压缩之后会导致每次需要修改的点数量非常多，采用 按秩合并，内部路径压缩，平均复杂度 `ndlogn`

对于有序点对答案是 $\textstyle\sum k^2$，其中 k 表示相同字符串的数量，对于有序点对但是是 $\textstyle\sum k*(k-1)/2$ ,

一 ： 暂时没看明白 

维护 `k * (k - 1)`，每次 k 只会增加或者删除 1，每次修改加上的数据是  `2k`  ，减去的数据是 `2x - 2`

二 ：每次直接整个删除 k 的贡献，即是每次直接减去 `k * (k-1)`，修改 k ,在整体加上 `k * (k - 1)`



对于输入有初始边两种解决方案

一： 只对 1 图进行根节点，和字节点的更新，将 1 图 复制 d 遍，得到 d + 1 个图，在对每个图中更新每个点当前位的 hash 值，加到一起得到整个字符串的 hash 值，后面额外加边同  [洛谷P8026](https://www.luogu.com.cn/problem/P8026) 操作

```cpp
pre(j,1,n)
{
    rt[1][j] = j;//初始化操作，初始无边，每个节点的祖先都是自己
    p[1][j].clear();
    p[1][j].push_back(j);//第 i 个图，点 j 为根的最初并查集，元素只有自己
}
pre(i,1,m)
{
    int a,b;cin >> a >> b;
    int k = 1;
    merge(1,a,b);
}
pre(i,2,d + 1)
{
    pre(j,1,n)
    {
        rt[i][j] = rt[1][j];//初始化操作，初始无边，每个节点的祖先都是自己
        p[i][j].clear();
        for(auto L : p[1][j])
            p[i][j].push_back(L);
    }
}
pre(i,1,n)
{
    h[i] = 0;
    pre(j,1,d + 1)
    {
        h[i] += 1ll * w[j] * rt[1][i];
    }
    mp[h[i]] = mp[h[i]] + 1;
}
for(auto [x,y] : mp)
    ans += 1ll * y * (y - 1);//更新当前初始状态的答案
```



二 ： 初始图按照空图的方式扩展 d 遍，计算字符串的权值，给定的边在在每一个图中按照加边的方式处理

```cpp
 pre(i,1,d + 1)
 {
     pre(j,1,n)
     {
         rt[i][j] = j;//初始化操作，初始无边，每个节点的祖先都是自己
         h[j] += (ull)j * w[i];//每个字符串的hash值，ull
         p[i][j].push_back(j);//第 i 个图，点 j 为根的最初并查集，元素只有自己
     }
 }
ans = 0;
mp.clear();
pre(i,1,n)
    fun(h[i],1);
pre(i,1,m)
    cin >> a[i] >> b[i];
for(int j=1;j<=d + 1;j++)
{
    pre(i,1,m)
    {
        merge(j,a[i],b[i]);
    }
}
```


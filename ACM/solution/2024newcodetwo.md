## B MST

一 ： 分类

如果当前询问的点数比较小，小于 $\sqrt{n}$ 为标准，此时直接采取双层循环找有用的边即可，然后`克鲁斯卡尔`算法直接跑最小生成树即可，对于点数大于 $\sqrt{n}$ 的询问，直接对所有边跑`库鲁斯卡尔算法`直到边数到达 `k - 1`，此时即是最小生成树所需的边，输出答案即可。

二 ： 离线

离线的本质在于将询问全部存下来，将每一点的询问情况存储下来，整体跑一边库鲁斯卡尔算法之后，从前往后依次遍历每一条边，找出边的两个端点，从`si`小的端点开始便利存储情况，如果此次存储序号在另一端点中存在，即是这条边可以存在于此次询问，直接当前询问中加入的边达到 `k - 1`次，对于每一个询问找出边之后需要初始化对应的并查集，可以开二维并查集,并且将询问中点值转换为编号，即是离散化，防止空间超限，并可以在并查集的时候对于的`p`数组只开对应的空间减少操作时间，最后对于每一次询问判断加入的边数是否等于对应`k - 1`即可。

**映射非常多，离线的缺点，非常绕，且不能写错**

---

## I  区间DP

[【雨巨讲题】2024牛客暑期多校第二场新手向讲题_哔哩哔哩_](https://www.bilibili.com/video/BV1V142187g9/?spm_id_from=333.337.search-card.all.click&vd_source=8b820a0cc3617564e32f6de08dff813f)

[代码查看 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/view-submission?submissionId=70472387)

`f[i]`表示$\  l_i\ 到\ r_i\ 通过全删掉(i->i)的最大得分$ 

在 i 到 i 之间的区间内，考虑每个元素是和 [i,i] 一起删除，还是之前单独自己删除，如果**和 i 一起删除**对答案的贡献就是 **i**，否则通过辅助数组 dp[x],表示从 $l_i$开始删除到第`x` 个元素的最大得分   

```cpp
max(dp[x - 1] + i,dp[l[a[x]] - 1] +	f[a[x]]);//后者需要满足的条件是l[a[x]] >= l[i]，且 x 是第二个a[x] 的位置
```

**注意：**上述 `i `指的是元素的值，从 第一个 `i `删除到第二个`i`，但是 `x`指的是元素的下标。

最后的 `dp[r[i]]`就是`f[i]`的答案。通过向原序列两端加上两个 0，此时对答案的贡献一定是 0，最后的`f[r[0]]`即是最终的答案。

此题需要**从短的区间算到长的区间**，因为大区间的更新需要用到内部小的区间，不能按照常规顺序。

对于交叉的情况，`023230`对于 2 和 3来说更新的时候并不会产生其他的影响，没有内含其他可删除的区间，但是到 0 的时候，额外考虑一起删除，删除 2，3等的贡献求 max 最终取得答案，两端补 0 的意义！

因为是按照区间长度从小到大开始更新，所以需要建立一个 辅助数组 b[]，来确定更新的顺序，当枚举到内含区间的右端点时注意到需要判断一下是一起删除更优还是独自删除更优。


























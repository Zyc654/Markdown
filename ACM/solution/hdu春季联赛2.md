## 1001

### 1. 当 L[i]L[i] 在第 kk 位为 1

此时，`L[i]` 在该位为 1，意味着在该位上我们有可能让 $b_i$ 比 `L[i] `小，从而使后面的位完全自由选择。分两种情况讨论：

-   **情况 1.1：a[i] 在第 k 位为 1**

    对于` b_i` 来说，在这一位有两个可能：

    -   **选择 1**：如果选择1，则当前位与 L[i] 相同（因为 L[i] 在该位为 1），但此时还不能确定 `b_i` 是否小于 L[i]，因此需要在后续位继续匹配。这条分支将在后续循环中处理，不在这一位立刻“放弃”自由选择。
    -   **选择 0**：如果在这一位选择 0，则立即导致 `b_i` 在这一位小于 L[i]（因为 L[i] 是 1而我们选了 0）。一旦确定 `b_i < L[i]` 在这一位上，就不需要再考虑后续位是否超界，所有较低位（从 k-1 到 0）的合法选择都可以自由选取。而这些较低位的合法选择总数正好就是预先计算好的 `pre[k-1]`。

    因此，当 L[i] 在第 kk 位为 1且 a[i]在该位为 1时，当前可以直接“贡献” `pre[k−1]` 种方案。

-   **情况 1.2：a[i] 在第 kk 位为 0**

    此时，由于 b_i 必须是 a[i]a[i] 的子集，所以在第 k 位上 b_i 只能取 0（不能取 1，因为 a[i] 的这一位为 0）。而 L[i] 在该位为 1，故此时 b_i 在这一位肯定比 L[i] 小。
     既然已经确定 b_i 在第 kk 位比 L[i] 小，那么后续所有低位都可以任意选取（只要符合“子集”要求），这时较低位的合法选择数就是 `pre[k]`（因为这里“自由位”从 k−1k-1 位到 0，再加上当前这一位其实没有选择余地，只是直接计入之前所有低位的自由选择数）。
     累加 `pre[k]` 后，直接 `break`（跳出循环），因为后面的位都不需要再和 L[i]L[i] 比较约束了。

------

### 2. 当 L[i] 在第 k 位为 0

在这种情况下，为了满足 b_i <= L[i]，当前位 b_i 必须与 L[i] 同样为 0。对于非最低位而言，因为当前位已经严格匹配 L[i]（均为 0），所以还不能确定 b_i < L[i] 或等于 L[i]——需要继续判断更低位。但当遍历到最低位 k == 0 时，

-   如果 L[i] 的最低位为 0，则 b_i 的最低位也只能是 0（即只有一种选择），所以在这种极限情况累加 1（表示唯一可能）。

------

### 总结

-   **累加 `pre[k-1]` 的原因**
     当 L[i]L[i] 在第 kk 位为 1且 a[i]a[i] 在该位为 1时，如果在这一位选择 0（与 L[i]L[i] 不同，保证 bi<L[i]b_i < L[i]），那么较低位可以任意选择（合法方案数为 `pre[k-1]`，因为较低位的自由选择数正好由 a[i]a[i] 较低位中 1 的个数决定）。
-   **累加 `pre[k]` 的原因**
     当 L[i]L[i] 在第 kk 位为 1但 a[i]a[i] 在该位为 0时，由于 bib_i 必须在这一位取 0（没有选择余地），而这一位和 L[i]L[i] 已经产生差距（0 < 1），所以后面所有位都可以自由选择（合法方案数为 `pre[k]`，这里 `pre[k]` 表示从第 k-1 位到第 0 位的合法选择数）。
-   **最低位 k==0k == 0 的特殊处理**
     当遍历到最低位，且当前位 L[i]L[i] 为 0时，bib_i 的这一位只能是 0，此时只有一种方案，所以累加 1。

```cpp
int n, a[N], c[N];
int pre[40];
void solve()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    for (int i = 1; i <= n; i++)
        cin >> c[i], c[i] = min(c[i], a[i]); // 最大的有意义的数才到a[i]
    int ans = 1;
    for (int i = 1; i <= n; i++)
    {
        int tp = 0;
        pre[0] = 1 << (a[i] & 1);
        for (int j = 1; j <= 32; j++)
            pre[j] = (pre[j - 1] << ((a[i] >> j) & 1)) % mod;
        for (int j = 32; j >= 0; j--)
        {
            if ((c[i] >> j) & 1)
            {
                if ((a[i] >> j & 1)) // c[i]  a[i] 在当前位 均为 1
                {
                    if (j == 0) // 如果当前是最后一位此时满足 <= c[i]
                        tp = (tp + pre[0]) % mod;
                    else
                        tp = (tp + pre[j - 1]) % mod; // 当前不是最后一位 注意需要满足 <= c[i] 所以本位取0 此时一定可以满足 继续判断后续
                }
                else // 如果 a[i] 当前位为 0 此时一定满足小于 c[i] 直接计算剩下的 j 位的总和即可
                {
                    tp = (tp + pre[j]) % mod;
                    break;
                }
            }
            else if (j == 0) // c[i] 此位是 0 但是是最后一位 需要加 1
                tp = (tp + 1) % mod;
        }
        ans = ans * tp % mod;
    }
    cout << ans << endl;
}
```





## 1003

注意到我们每次需要找到所有 `m` 个数据均满足 `c[i][j] < a[j]` 的 面试机会 , 对于每一次面试成功 会为自己的经验加上 `w[i][j]` 此时我们需要判断新一轮的大小关系 , 直接开 m 维小根堆 ,每一维存储当前 第`j`列直接的关系 ,每次更新 `a` 数组后重新判断和对于 `c` 的关系 从而来判断当前组是否所有的数据均满足要求 .
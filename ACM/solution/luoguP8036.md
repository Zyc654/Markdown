题目只考虑连通性，可以用`d`个并查集维护，两个点`u，v` 在图 `i` 上联通，当且仅当图 `i` 上 `u 和 v` 的并查集祖先相同

因此，两个点 `u` 和 `v` 在 d 张图上都联通，等价于在任意 `i`，`u 和 v `在第 `i` 张图的并查集祖先都相同。

**所以考虑维护每个点 u 维护一个长度为 d 的字符串 $s_u$，$s_u(i)$ 表示第 i 张图上 u 的并查集祖先。**

于是 u 和 v 在 d 张图上联通等价于 $s_u == s_v$  即是在每一张图中，u 和 v 的父节点都相同则是联通的

使用 hash 来判断字符串是否相同，对于哈希值相同的 k 个字符串，对答案的贡献是 $k^2$ (有序点对)

向第 k 张图中加边，会修改 $s_u$ 的第 k 个字符，u 是所有这次连边中在并查集上被更改祖先的点。

**注意：**不能使用路径压缩，使用路径压缩的话，每次加边需要更改的点的祖先是非常多的，只能通过`for`循环来修改每一个点

考虑 按秩合并(启发式合并) ,每次操作被更改祖先的次数不会超过`log n`次 (因为被更改一次祖先，他所在的并查集树的大小就会翻倍)，每次更改只会改变这一棵子树到达根节点之间的所有点，每个字符串被修改不超过 `dlog n`次，总次数为 `nd log n` 每一子树之间的合并仍然会路径压缩，但不会压缩到根节点

可能会卡 hash 常数，直接考虑对于长度为 d 的字符串随机化一个权值 `w[i]`，对于字符串 S 的`hash`值是 $\textstyle\sum w(i)\times S(i)$ 

[代码查看](/mine/vsc/luogu/P_8026_ONTAK_2015_Bajtocja.cpp)
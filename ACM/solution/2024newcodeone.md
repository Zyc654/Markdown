## A

$\sum_{1}^{n}  C_n^k * 2^{(n-k)(m-1)}*(2^k-1)^{(m-1)}$    选取 k 个作为当前子序列，向外扩展，剩下的数据随便组合，最后肯定可以删去得到当前序列使得 AND 和为 1

---

## B

正难则反，求出不满足的情况，用 A 的答案减去即可，注意到不满足的情况一定是当前选择 k 个子序列一个都不能删除，即是 k 个数中都有一位满足除了本身外其他的数该位都是 1，称这样的位为 特殊位  --- 至多 m-1 个特殊位分配到 k 个数中，且每个数至少分配一个特殊位，此时选中的子序列中每个点都不能删除，因此 k <= x <= m - 1，当特殊位的个数 >= k 时，一定满足当前 k 个数每一个数至少有一个特殊位

`f[i][j]`表示现在  i 个数有 j 个特殊位`f[0][0] = 1`

转移方程 : **`f[i][j] = i *  (f[i][j - 1] + f[i - 1][j - 1]) `** 即是前 i - 1 个数已经有 j - 1 个特殊位，此时第 j 个可以随便放在 i 中每一个数内，或者前 i - 1个数有 j - 1的特殊位，此时第 j 位只能放在第 i 个，但是此时又可以排列组合，此时可以将第 i 个数放在 i 个位置，因为求的是不满足的，所以 j >= i，才有效  

两题模数都太过逆天，不能使用小费马求解，用杨辉三角求组合数，加上自动取模机直接求模即可。



---

## I   

[代码查看 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/view-submission?submissionId=70195721)

首先明确一点所有的光路一定是链或者环，且两条之间不会有重复的部分

反证 ： 如果突然成环或者有重复的部分那么由于光路可逆可以反推出两条光路，出现问题 ！！！！

先从边界找图中的链，从边界进去，先转换一次方向再继续向后寻找，逆着找的，从后往前回溯得到的是从某点出发到这点出去的链，回溯的时候同步更新答案，对于找环的情况，如果链遍历结束之后存在未遍历到的点则代表在某个环中，更新时间戳找出环后给出答案即可

复杂度 O(4nm)



---

## D 

[D-XOR of Suffix Sums](https://ac.nowcoder.com/acm/contest/81596/D)

[代码查看 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/view-submission?submissionId=70389001)

后缀和 转换位 前缀和减前缀和

由于和位运算有关，考虑按照每一位来解决问题，在注意到，对每位而言，比如 1011，要想使最高位 1 发生变化，需要减去的数在 (0011,1011]之间，也即是(n % (1 << d),(n % (1 << d) | (1 << d)]，对于 0011 一样，使得最高位 1发生改变的是 (0011,1011]，也是 (n % (1 << d),(n % (1 << d) | (1 << d))，对于每次询问的操作，按照每一位来考虑，如果当前位 1 的个数是奇数，那么此时对答案的贡献就是 1 << d，否则对答案的贡献就是 0 .

**注意：**树状数组一定不能映射到 0 ，对于每一位而言，只需要存储后面的位的信息即可

即是  21 个树状数组开辟的空间是 （1 << (d  + 1)) + 1，最后加 1 是因为防止被映射到 0，整体右移一位, (d + 1) 是因为要比（11...1) 共 d 位大1，防止映射到 0，(1 << (d + 1))即可， + 1没啥实际意义

对于每次操作而言，注意当前询问的前缀和最后一个数据是不应该加入到树状数组中的，我们要寻找的就是与这一位的关系，那么这一位理所当然不能放进树状数组中，这也是 pop 先弹出前缀和数组 back 的原因，back 本来就没放入到后缀数组中，先pop_back，在继续将back 从树状数组中删除，消除影响，对于 push 而言，需要想将 back 加到树状数组中在 push_back 将前缀和更新一下

**区别：**相对于常规树状数组，在 add 和query 的时候一定是从 u + 1 开始的，因为取模可能会到 0 ，加一整体右移一位，消除 0 的影响，我们需要的答案是 (l,r] 之间的奇偶情况，即是 query(r) - query(l)

注意到如果当前前缀和最后一个数据当前位是 奇数的时候，此时当前位本来就是 1，有ask(l,r)个会使 1 变为 0，由于我们需要计算的是当前为有贡献的数量，所以当前算的应该是 `cnt - ask()`,对于当前位 是 0 的情况就是`ask()`，最终如果数量是奇数个，则代表当前位是有贡献的，否则贡献位 0


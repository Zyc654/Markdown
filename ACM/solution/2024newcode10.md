## F

暴力即可,  看似是$O(N^3)$的复杂度 , 实际上完全跑不满 .

只需要按照输入贪心的判断该点是否可以加入到满足的区域中, 如果这个点可以满足只需要遍历之前区域中的所有点 , 将两点之间的所有点都标记为不符合的情况 , 即是对应字符是 `0` , 最多只有 `1000000` 个点 , 完全可以直接全部标记 , 判断后续的点是否属于当前标记区域即可 , 否则 ,对答案的贡献是 `1` , 加入到满足的区域中 

判断两点直接的所有点可以直接使用**斜率**辅助 , 考虑当前直线上每两个相邻点之间的 `x , y` 的差值是一样的 , 即是两点之间的距离除以两距离的最大公因数 , 这样暴力判断改变后的点是否在当前矩形中即可 . 看似是 $O(N^3)$  , 实际完全跑不到 , 因为两点直接是可以筛除很多点的 , 复杂度大大降低 . 



## k

不难发现 , 最优策略肯定是优先使用一个方向的较大的数据将智力增加或减少 `1` 使得部分可以满足 `d = x` 对答案产生 `1` 的贡献 , 然后在转向判断另一个方向从当前方向每一个点转向会有多少另一方向的满足 , 取 `max`  , 直接二分判断即可 , 

当前方向可取要满足 绝对值较大的数据个数大于当前绝对值 , 然后判断 当前值和二分值之间的差值是否可以通过另一方向绝对值较大的凑出 ! 

```cpp
auto get = [&] () -> void 
{
    int z = ve.size(),f = v.size();
    for(int i=0;i<z;i++)
    {
        if(z - 1 - i >= ve[i])
        {
            int l = 0,r = f - 1,res = -1;
            while(l <= r)
            {
                int mid = l + r >> 1;
                if(-ve[i] + f - 1 - mid >= v[mid])
                    res = mid,l = mid + 1;
                else r = mid - 1;
            }
            ans = max(ans,i + 1 + res + 1);
        }
    }
};
```

用两个方向分别左右其实方向判断一次转向之后答案的`max` 取最大值即可 

### 项目实战

<span style="font-size:16px">[press](../../nodeT/项目学习/WebServer/5.1 项目实战.pdf)            [图解](../../nodeT/项目学习/WebServer/5.1 阻塞、非阻塞、同步、异步.png)</span>

#### 阻塞/非阻塞、同步/异步

<pre><span style="font-size:16px">  阻塞和非阻塞是描述操作行为的术语，主要和资源的占用情况有关；同步和异步则是从时间顺序和流程控制的角度来描述任务的执行方式。
1. 阻塞（Blocking）
   定义 ：阻塞是指在程序执行过程中，当一个操作（如 I/O 操作、等待资源等）发生时，调用该操作的线程会被挂起，直到该操作完成才能继续执行后续代码。
   特点
      阻塞操作会使得线程进入等待状态，不能有效地利用 CPU 时间；在阻塞期间，线程无法响应其他事件，这可能会导致程序的响应性变差。 
2. 非阻塞（Non Blocking）
   定义 ：非阻塞操作允许调用操作的线程在发起操作后继续执行其他任务，而不需要等待操作完成。在这种情况下，线程可以利用等待操作完成的时间来执行其他有用的工作，从而提高 CPU 利用率。
   特点
      非阻塞操作能够充分利用线程的执行时间，提高的程序并发性能；需要程序提供机制来检查操作的完成情况，例如轮询或者使用事件通知等机制。
3. 同步（Synchronous）
   定义 ：同步是指多个线程进程或者之间按照一定的顺序执行，通常通过共享变量、信号量等机制来协调它们的执行顺序。在同步操作中，一个线程的执行往往需要等待其他线程完成某些操作或者达到某种状态才能继续。
   特点
      同步操作可以保证线程之间的执行顺序，确保数据的一致性和正确性；但是同步可能会导致线程等待，降低程序的并发性能。
4. 异步（Asynchronous）
   定义 ：异步是指线程之间不需要按照严格的顺序执行，每个线程可以独立地执行自己的任务，而不需要等待其他线程完成特定操作。在这种模式下，线程之间通过事件通知、回调函数等方式来相互协作。
   特点
      异步操作可以使程序能够同时处理多个任务，提高并发能力；异步编程模式通常需要更复杂的逻辑来处理任务完成后的结果，因为任务的完成时间是不确定的。<b>异步和非阻塞结合，提高效率</b>
  总结来说，阻塞和非阻塞主要是针对操作在执行过程中对线程状态的影响；同步和异步是关于线程或进程之间如何协作和协调执行顺序。</span></pre>

### 常见的IO模型

<pre><span style="font-size:16px"> 以下是对阻塞（Blocking）、非阻塞（Non-blocking）、IO复用（IO Multiplexing）、信号驱动（Signal driven）和异步（Asynchronous）的总结：
1. 阻塞（Blocking）
  定义：阻塞是指在程序执行过程中，当一个操作（如 I/O 操作、等待资源等）发生时，调用该操作的线程会被挂起，直到该操作完成才能继续执行后续代码。
  特点：阻塞操作会使得线程进入等待状态，不能有效地利用 CPU 时间，在阻塞期间，线程无法响应其他事件，这可能会导致程序的响应性变差。
2. 非阻塞（Non Blocking）
  定义：非阻塞操作允许调用操作的线程在发起操作后继续执行其他任务，而不需要等待操作完成。
  特点：非阻塞操作能够充分利用线程的执行时间，提高程序的并发性能。通常需要程序提供机制来检查操作的完成情况，例如轮询或者使用事件通知等机制。
3. IO 复用（IO Multiplexing）
  定义：IO 复用是一种高效的 I/O 处理方式，它允许一个线程同时管理多个 I/O 操作。通过 IO 复用，线程可以等待多个 I/O 事件中的任何一个发生，当有事件发生时，线程会得到通知并进行相应的处理。
  特点：IO 复用能够提高系统的并发性能，减少线程的创建和切换开销。常见的 IO 复用技术包括 select、poll 和 epoll 等。
4. 信号驱动（Signal driven）
  定义：信号驱动是一种异步 I/O 处理方式，它允许线程注册对特定事件的兴趣。当事件发生时，系统会向线程发送一个信号，线程可以在这个信号的处理函数中进行相应的处理。
  特点：信号驱动能够实现异步事件通知，提高程序的响应速度。但是，信号处理函数的编写需要谨慎，因为信号的处理时机是不确定的。
5. 异步（Asynchronous）
  定义：异步是指线程之间不需要按照严格的顺序执行，每个线程可以独立地执行自己的任务，而不需要等待其他线程完成特定操作。在这种模式下，线程之间通过事件通知、回调函数等方式来相互协作。
  特点：异步操作可以使程序能够同时处理多个任务，提高并发能力。异步编程模式通常需要更复杂的逻辑来处理任务完成后的结果，因为任务的完成时间是不确定的。
它们之间的区别与联系：
   阻塞与非阻塞：阻塞和非阻塞主要是针对操作在执行过程中对线程状态的影响。阻塞操作会挂起线程，而非阻塞操作允许线程继续执行。
   同步与异步：同步是指多个线程或进程之间按照一定的顺序执行，通常通过共享变量、信号量等机制来协调它们的执行顺序。异步则是线程之间可以独立执行，通过事件通知等方式协作。同步和异步更多地是关于线程或进程之间的协作方式。
   非阻塞与 IO 复用：非阻塞操作和 IO 复用都可以用于提高并发性能。非阻塞操作允许线程在等待 I/O 操作时继续执行其他任务，而 IO 复用则允许一个线程同时管理多个 I/O 操作。
   信号驱动与异步：信号驱动是一种实现异步 I/O 的方式之一。通过信号驱动，线程可以在事件发生时得到通知，从而实现异步事件处理。

### Web Server

<pre><span style="font-size:16px">
  URL 是统一资源定位符（Uniform Resource Locator）的缩写，它是用于标识网络上资源位置的字符串，是互联网上标准资源地址的表示方法。
 URL 的结构
一个典型的 URL 由以下几个部分组成：
  协议（Protocol）：也称为方案（Scheme），它指定了访问资源时使用的协议。常见的协议有：
    http：超文本传输协议，用于传输网页内容。
    https：安全的超文本传输协议，使用 SSL/TLS 加密。
    ftp：文件传输协议，用于传输文件。
    mailto：用于发送电子邮件，后面通常跟电子邮件地址。
    file：用于访问本地文件系统。
  子协议（Subprotocol，可选）：在某些协议中，还可以有子协议，进一步指定访问方式。例如在 svn+ssh://example.com/repo 中，svn+ssh 是子协议，表示通过 SSH 协议访问 Subversion 仓库。
  用户名（Username，可选）：在需要身份验证的 URL 中，可以包含用户名。例如 username@hostname，用户名和主机名之间用 @ 分隔。
  密码（Password，可选）：如果需要提供密码进行身份验证，则跟在用户名之后，中间用冒号分隔。例如 username:password@hostname。
  主机（Host）：主机名（或 IP 地址），用于指定资源所在的服务器。主机名可以是域名（如 example.com）或 IP 地址（如 192.168.1.1）。
  端口号（Port，可选）：用于指定主机上提供资源服务的端口号。端口号紧跟在主机名之后，用冒号分隔。例如 :8080，其中 8080 是端口号。
  路径（Path）：用于指定资源在主机上的具体位置。例如 /path/to/resource。
  查询字符串（Query string，可选）：用于向服务器传递参数。查询字符串从问号 ? 开始，后面跟着一系列的键值对，键值对之间用 & 分隔。例如 ?key1=value1&key2=value2。
  片段标识符（Fragment identifier，可选）：用于指定文档中的某个部分，通常用于 HTML 页面。片段标识符从井号  开始，后面跟着片段名。例如 section1。
 URL 的语法
标准的 URL 语法如下：
protocol://[username[:password]@]host[:port]/path[?query][fragment]
 举例说明
http://www.example.com/index.html
  协议：http
  主机：www.example.com
  路径：/index.html
ftp://user:password@ftp.example.com:21/files/document.txt
  协议：ftp
  用户名：user
  密码：password
  主机：ftp.example.com
  端口号：21
  路径：/files/document.txt
https://example.com/search?q=query+string&lang=enresults
  协议：https
  主机：example.com
  路径：/search
  查询字符串：?q=query+string&lang=en
  片段标识符：results
URL 的主要作用是为用户提供更多的信息访问方式，使得用户可以通过浏览器等工具方便地获取网络上的各种资源。
</pre>

### GET 和 POST 的区别

<pre><span style="font-size:16px">
  GET 请求和 POST 请求是 HTTP 协议中最常用的两种请求方法，它们在多个方面存在区别，以下是详细对比：
 1. 作用和用途
   GET 请求
     主要用于从服务器获取资源，是 HTTP 协议中最基本的请求方法之一。
     例如，当我们访问一个网页，像浏览新闻资讯、查看产品列表等操作，通常会使用 GET 请求来获取页面内容。
   POST 请求
     用于向服务器提交数据，以创建新的资源或更新现有资源。
     常见的应用场景包括用户注册、登录、提交表单等操作，比如向服务器发送用户填写的个人信息来完成注册流程。
 2. 数据传输方式
   GET 请求
     数据是通过 URL 参数传递的。这些参数会附加在请求的 URL 后面，以键值对的形式存在，键值对之间用 “&” 分隔，格式为 “?”。
     例如，https://example.com/search?q=query+string&lang=en，其中 “q=query+string&lang=en” 是 GET 请求的参数部分。
   POST 请求
     数据是放在请求体（body）中传输的。这样可以传输更多的数据，并且数据不会像 GET 请求那样直接暴露在 URL 中。
     例如，当用户在登录页面输入用户名和密码并提交表单时，这些数据会放在 POST 请求的请求体中发送到服务器。
 3. 数据长度限制
   GET 请求
     由于数据是包含在 URL 中的，而 URL 长度有限制（具体限制因浏览器而异，但一般来说在 2 - 8KB 左右），所以 GET 请求能携带的数据量比较小。
     这限制了通过 GET 请求发送复杂数据的能力，例如不能用于上传大文件等操作。
   POST 请求
     没有理论上对数据长度的限制（实际上可能会受到服务器配置等限制），能够传输大量数据，如文件上传、长文本内容提交等场景。
 4. 安全性
   GET 请求
     数据直接暴露在 URL 中，这可能会带来安全风险。例如，如果 URL 被保存在浏览器历史记录、网页服务器日志或者通过邮件等渠道分享时，其中包含的敏感信息（如密码、个人身份信息等）可能会被泄露。
     因此，对于敏感数据的传输，不适合使用 GET 请求。
   POST 请求
     数据在请求体中传输，相对隐蔽，不容易被直接从 URL 中获取。不过，这并不意味着 POST 请求的数据是完全安全的，因为服务器端的日志文件等可能仍然会记录请求体中的内容。
     所以对于敏感数据的传输，还需要采取其他安全措施，如使用 HTTPS 协议来加密传输过程中的数据。
 5. 缓存
   GET 请求
     可以被缓存。浏览器、代理服务器等缓存机制会缓存 GET 请求的结果，这样当再次请求相同的 URL 时，可以快速返回缓存的内容，提高性能。
     例如，对一些静态页面或者经常访问的资源，使用 GET 请求可以利用缓存来减少服务器的负载和网络传输时间。
   POST 请求
     通常不会被缓存，因为 POST 请求一般用于提交数据并修改服务器状态，缓存 POST 请求的结果可能会导致数据不一致或者其他问题。
 6. 对资源的可重复性操作
   GET 请求
     是一种幂等操作。也就是说，对同一个 URL 发起多次相同的 GET 请求，其效果和发起一次 GET 请求是一样的，不会改变服务器上的资源状态。
     例如，多次访问一个新闻详情页面（使用 GET 请求），不会对新闻内容本身产生任何改变。
   POST 请求
     一般是非幂等操作。多次发送相同的 POST 请求可能会导致服务器上资源状态的改变。例如，多次提交一个表单用于添加新用户，可能会在数据库中创建多个相同的用户记录。
 7. 书签功能
   GET 请求
     因为数据是包含在 URL 中的，所以可以方便地将包含参数的 URL 作为书签保存。当用户再次点击这个书签时，可以直接访问带有这些参数的页面。
   POST 请求
     由于数据是在请求体中，无法通过简单的 URL 来包含这些数据，因此不能直接将 POST 请求对应的页面内容作为书签保存。
 8. 对数据类型的支持
   GET 请求
     一般只支持 ASCII 字符。如果需要传递其他类型的字符，需要进行编码，如 URL 编码。
   POST 请求
     可以支持多种数据类型，包括二进制数据（如文件上传）、JSON 数据、XML 数据等。这使得 POST 请求能够满足各种复杂的数据提交需求。
 9. 浏览器历史记录
   GET 请求
     访问的每个 GET 请求的 URL 都会记录在浏览器的历史记录中。这对于用户回溯浏览历史是有帮助的，但如前面所说，可能会带来安全和隐私方面的隐患。
   POST 请求
     浏览器历史记录中一般不会保存 POST 请求的具体数据，只是保存访问过的页面 URL。
 10. 应用场景
   GET 请求
     适用于获取不涉及敏感信息的资源，如浏览网页内容、获取公共 API 数据等。
   POST 请求
     适用于需要向服务器提交数据的场景，如用户登录、注册、提交表单、上传文件等。
</pre>

 总结表格
| 对比项目       | GET 请求                  | POST 请求                  |
| -------------- | ------------------------- | -------------------------- |
| 主要用途       | 获取资源                  | 提交数据以创建或更新资源   |
| 数据传输方式   | URL 参数                  | 请求体                     |
| 数据长度限制   | 较小                      | 较大                       |
| 安全性         | 较低（数据暴露在 URL 中） | 相对较高（数据在请求体中） |
| 缓存           | 可以缓存                  | 通常不缓存                 |
| 幂等性         | 是                        | 否                         |
| 书签功能       | 支持                      | 不支持                     |
| 数据类型支持   | ASCII 字符（需编码）      | 多种数据类型               |
| 浏览器历史记录 | 保存 URL                  | 保存页面 URL，不保存数据   |

### 线程池























